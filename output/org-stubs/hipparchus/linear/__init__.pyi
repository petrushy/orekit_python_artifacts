import java.io
import java.lang
import java.text
import java.util
import java.util.function
import org.hipparchus
import org.hipparchus.analysis
import org.hipparchus.complex
import org.hipparchus.fraction
import org.hipparchus.util
import typing



class AnyMatrix:
    def getColumnDimension(self) -> int: ...
    def getRowDimension(self) -> int: ...
    def isSquare(self) -> bool: ...

class CholeskyDecomposition:
    DEFAULT_RELATIVE_SYMMETRY_THRESHOLD: typing.ClassVar[float] = ...
    DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD: typing.ClassVar[float] = ...
    @typing.overload
    def __init__(self, realMatrix: 'RealMatrix'): ...
    @typing.overload
    def __init__(self, realMatrix: 'RealMatrix', double: float, double2: float): ...
    def getDeterminant(self) -> float: ...
    def getL(self) -> 'RealMatrix': ...
    def getLT(self) -> 'RealMatrix': ...
    def getSolver(self) -> 'DecompositionSolver': ...

class ComplexEigenDecomposition:
    DEFAULT_EIGENVECTORS_EQUALITY: typing.ClassVar[float] = ...
    DEFAULT_EPSILON: typing.ClassVar[float] = ...
    DEFAULT_EPSILON_AV_VD_CHECK: typing.ClassVar[float] = ...
    @typing.overload
    def __init__(self, realMatrix: 'RealMatrix'): ...
    @typing.overload
    def __init__(self, realMatrix: 'RealMatrix', double: float, double2: float, double3: float): ...
    def getD(self) -> 'FieldMatrix'[org.hipparchus.complex.Complex]: ...
    def getDeterminant(self) -> float: ...
    def getEigenvalues(self) -> typing.List[org.hipparchus.complex.Complex]: ...
    def getEigenvector(self, int: int) -> 'FieldVector'[org.hipparchus.complex.Complex]: ...
    def getV(self) -> 'FieldMatrix'[org.hipparchus.complex.Complex]: ...
    def getVT(self) -> 'FieldMatrix'[org.hipparchus.complex.Complex]: ...
    def hasComplexEigenvalues(self) -> bool: ...

class DecompositionSolver:
    def getColumnDimension(self) -> int: ...
    def getInverse(self) -> 'RealMatrix': ...
    def getRowDimension(self) -> int: ...
    def isNonSingular(self) -> bool: ...
    @typing.overload
    def solve(self, realMatrix: 'RealMatrix') -> 'RealMatrix': ...
    @typing.overload
    def solve(self, realVector: 'RealVector') -> 'RealVector': ...

class EigenDecomposition:
    @typing.overload
    def __init__(self, doubleArray: typing.List[float], doubleArray2: typing.List[float]): ...
    @typing.overload
    def __init__(self, doubleArray: typing.List[float], doubleArray2: typing.List[float], double3: float): ...
    @typing.overload
    def __init__(self, realMatrix: 'RealMatrix'): ...
    @typing.overload
    def __init__(self, realMatrix: 'RealMatrix', double: float): ...
    def getD(self) -> 'RealMatrix': ...
    def getDeterminant(self) -> float: ...
    def getEigenvector(self, int: int) -> 'RealVector': ...
    def getEpsilon(self) -> float: ...
    def getImagEigenvalue(self, int: int) -> float: ...
    def getImagEigenvalues(self) -> typing.List[float]: ...
    def getRealEigenvalue(self, int: int) -> float: ...
    def getRealEigenvalues(self) -> typing.List[float]: ...
    def getSolver(self) -> DecompositionSolver: ...
    def getSquareRoot(self) -> 'RealMatrix': ...
    def getV(self) -> 'RealMatrix': ...
    def getVT(self) -> 'RealMatrix': ...
    def hasComplexEigenvalues(self) -> bool: ...

_FieldDecompositionSolver__T = typing.TypeVar('_FieldDecompositionSolver__T', bound=org.hipparchus.FieldElement)  # <T>
class FieldDecompositionSolver(typing.Generic[_FieldDecompositionSolver__T]):
    def getColumnDimension(self) -> int: ...
    def getInverse(self) -> 'FieldMatrix'[_FieldDecompositionSolver__T]: ...
    def getRowDimension(self) -> int: ...
    def isNonSingular(self) -> bool: ...
    @typing.overload
    def solve(self, fieldMatrix: 'FieldMatrix'[_FieldDecompositionSolver__T]) -> 'FieldMatrix'[_FieldDecompositionSolver__T]: ...
    @typing.overload
    def solve(self, fieldVector: 'FieldVector'[_FieldDecompositionSolver__T]) -> 'FieldVector'[_FieldDecompositionSolver__T]: ...

_FieldLUDecomposition__T = typing.TypeVar('_FieldLUDecomposition__T', bound=org.hipparchus.FieldElement)  # <T>
class FieldLUDecomposition(typing.Generic[_FieldLUDecomposition__T]):
    @typing.overload
    def __init__(self, fieldMatrix: 'FieldMatrix'[_FieldLUDecomposition__T]): ...
    @typing.overload
    def __init__(self, fieldMatrix: 'FieldMatrix'[_FieldLUDecomposition__T], predicate: typing.Union[java.util.function.Predicate[_FieldLUDecomposition__T], typing.Callable[[_FieldLUDecomposition__T], bool]]): ...
    @typing.overload
    def __init__(self, fieldMatrix: 'FieldMatrix'[_FieldLUDecomposition__T], predicate: typing.Union[java.util.function.Predicate[_FieldLUDecomposition__T], typing.Callable[[_FieldLUDecomposition__T], bool]], boolean: bool): ...
    def getDeterminant(self) -> _FieldLUDecomposition__T: ...
    def getL(self) -> 'FieldMatrix'[_FieldLUDecomposition__T]: ...
    def getP(self) -> 'FieldMatrix'[_FieldLUDecomposition__T]: ...
    def getPivot(self) -> typing.List[int]: ...
    def getSolver(self) -> FieldDecompositionSolver[_FieldLUDecomposition__T]: ...
    def getU(self) -> 'FieldMatrix'[_FieldLUDecomposition__T]: ...

_FieldMatrixChangingVisitor__T = typing.TypeVar('_FieldMatrixChangingVisitor__T', bound=org.hipparchus.FieldElement)  # <T>
class FieldMatrixChangingVisitor(typing.Generic[_FieldMatrixChangingVisitor__T]):
    def end(self) -> _FieldMatrixChangingVisitor__T: ...
    def start(self, int: int, int2: int, int3: int, int4: int, int5: int, int6: int) -> None: ...
    def visit(self, int: int, int2: int, t: _FieldMatrixChangingVisitor__T) -> _FieldMatrixChangingVisitor__T: ...

_FieldMatrixPreservingVisitor__T = typing.TypeVar('_FieldMatrixPreservingVisitor__T', bound=org.hipparchus.FieldElement)  # <T>
class FieldMatrixPreservingVisitor(typing.Generic[_FieldMatrixPreservingVisitor__T]):
    def end(self) -> _FieldMatrixPreservingVisitor__T: ...
    def start(self, int: int, int2: int, int3: int, int4: int, int5: int, int6: int) -> None: ...
    def visit(self, int: int, int2: int, t: _FieldMatrixPreservingVisitor__T) -> None: ...

_FieldQRDecomposition__T = typing.TypeVar('_FieldQRDecomposition__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
class FieldQRDecomposition(typing.Generic[_FieldQRDecomposition__T]):
    @typing.overload
    def __init__(self, fieldMatrix: 'FieldMatrix'[_FieldQRDecomposition__T]): ...
    @typing.overload
    def __init__(self, fieldMatrix: 'FieldMatrix'[_FieldQRDecomposition__T], t: _FieldQRDecomposition__T): ...
    @typing.overload
    def __init__(self, fieldMatrix: 'FieldMatrix'[_FieldQRDecomposition__T], t: _FieldQRDecomposition__T, predicate: typing.Union[java.util.function.Predicate[_FieldQRDecomposition__T], typing.Callable[[_FieldQRDecomposition__T], bool]]): ...
    def getH(self) -> 'FieldMatrix'[_FieldQRDecomposition__T]: ...
    def getQ(self) -> 'FieldMatrix'[_FieldQRDecomposition__T]: ...
    def getQT(self) -> 'FieldMatrix'[_FieldQRDecomposition__T]: ...
    def getR(self) -> 'FieldMatrix'[_FieldQRDecomposition__T]: ...
    def getSolver(self) -> FieldDecompositionSolver[_FieldQRDecomposition__T]: ...

_FieldVector__T = typing.TypeVar('_FieldVector__T', bound=org.hipparchus.FieldElement)  # <T>
class FieldVector(typing.Generic[_FieldVector__T]):
    def add(self, fieldVector: 'FieldVector'[_FieldVector__T]) -> 'FieldVector'[_FieldVector__T]: ...
    @typing.overload
    def append(self, t: _FieldVector__T) -> 'FieldVector'[_FieldVector__T]: ...
    @typing.overload
    def append(self, fieldVector: 'FieldVector'[_FieldVector__T]) -> 'FieldVector'[_FieldVector__T]: ...
    def copy(self) -> 'FieldVector'[_FieldVector__T]: ...
    def dotProduct(self, fieldVector: 'FieldVector'[_FieldVector__T]) -> _FieldVector__T: ...
    def ebeDivide(self, fieldVector: 'FieldVector'[_FieldVector__T]) -> 'FieldVector'[_FieldVector__T]: ...
    def ebeMultiply(self, fieldVector: 'FieldVector'[_FieldVector__T]) -> 'FieldVector'[_FieldVector__T]: ...
    def getDimension(self) -> int: ...
    def getEntry(self, int: int) -> _FieldVector__T: ...
    def getField(self) -> org.hipparchus.Field[_FieldVector__T]: ...
    def getSubVector(self, int: int, int2: int) -> 'FieldVector'[_FieldVector__T]: ...
    def mapAdd(self, t: _FieldVector__T) -> 'FieldVector'[_FieldVector__T]: ...
    def mapAddToSelf(self, t: _FieldVector__T) -> 'FieldVector'[_FieldVector__T]: ...
    def mapDivide(self, t: _FieldVector__T) -> 'FieldVector'[_FieldVector__T]: ...
    def mapDivideToSelf(self, t: _FieldVector__T) -> 'FieldVector'[_FieldVector__T]: ...
    def mapInv(self) -> 'FieldVector'[_FieldVector__T]: ...
    def mapInvToSelf(self) -> 'FieldVector'[_FieldVector__T]: ...
    def mapMultiply(self, t: _FieldVector__T) -> 'FieldVector'[_FieldVector__T]: ...
    def mapMultiplyToSelf(self, t: _FieldVector__T) -> 'FieldVector'[_FieldVector__T]: ...
    def mapSubtract(self, t: _FieldVector__T) -> 'FieldVector'[_FieldVector__T]: ...
    def mapSubtractToSelf(self, t: _FieldVector__T) -> 'FieldVector'[_FieldVector__T]: ...
    def outerProduct(self, fieldVector: 'FieldVector'[_FieldVector__T]) -> 'FieldMatrix'[_FieldVector__T]: ...
    def projection(self, fieldVector: 'FieldVector'[_FieldVector__T]) -> 'FieldVector'[_FieldVector__T]: ...
    def set(self, t: _FieldVector__T) -> None: ...
    def setEntry(self, int: int, t: _FieldVector__T) -> None: ...
    def setSubVector(self, int: int, fieldVector: 'FieldVector'[_FieldVector__T]) -> None: ...
    def subtract(self, fieldVector: 'FieldVector'[_FieldVector__T]) -> 'FieldVector'[_FieldVector__T]: ...
    def toArray(self) -> typing.List[_FieldVector__T]: ...

_FieldVectorChangingVisitor__T = typing.TypeVar('_FieldVectorChangingVisitor__T', bound=org.hipparchus.FieldElement)  # <T>
class FieldVectorChangingVisitor(typing.Generic[_FieldVectorChangingVisitor__T]):
    def end(self) -> _FieldVectorChangingVisitor__T: ...
    def start(self, int: int, int2: int, int3: int) -> None: ...
    def visit(self, int: int, t: _FieldVectorChangingVisitor__T) -> _FieldVectorChangingVisitor__T: ...

_FieldVectorPreservingVisitor__T = typing.TypeVar('_FieldVectorPreservingVisitor__T', bound=org.hipparchus.FieldElement)  # <T>
class FieldVectorPreservingVisitor(typing.Generic[_FieldVectorPreservingVisitor__T]):
    def end(self) -> _FieldVectorPreservingVisitor__T: ...
    def start(self, int: int, int2: int, int3: int) -> None: ...
    def visit(self, int: int, t: _FieldVectorPreservingVisitor__T) -> None: ...

class IterativeLinearSolver:
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, iterationManager: org.hipparchus.util.IterationManager): ...
    def getIterationManager(self) -> org.hipparchus.util.IterationManager: ...
    @typing.overload
    def solve(self, realLinearOperator: 'RealLinearOperator', realVector: 'RealVector') -> 'RealVector': ...
    @typing.overload
    def solve(self, realLinearOperator: 'RealLinearOperator', realVector: 'RealVector', realVector2: 'RealVector') -> 'RealVector': ...
    def solveInPlace(self, realLinearOperator: 'RealLinearOperator', realVector: 'RealVector', realVector2: 'RealVector') -> 'RealVector': ...

class IterativeLinearSolverEvent(org.hipparchus.util.IterationEvent):
    def __init__(self, object: typing.Any, int: int): ...
    def getNormOfResidual(self) -> float: ...
    def getResidual(self) -> 'RealVector': ...
    def getRightHandSideVector(self) -> 'RealVector': ...
    def getSolution(self) -> 'RealVector': ...
    def providesResidual(self) -> bool: ...

class LUDecomposition:
    @typing.overload
    def __init__(self, realMatrix: 'RealMatrix'): ...
    @typing.overload
    def __init__(self, realMatrix: 'RealMatrix', double: float): ...
    def getDeterminant(self) -> float: ...
    def getL(self) -> 'RealMatrix': ...
    def getP(self) -> 'RealMatrix': ...
    def getPivot(self) -> typing.List[int]: ...
    def getSolver(self) -> DecompositionSolver: ...
    def getU(self) -> 'RealMatrix': ...

class MatrixDecomposer:
    def decompose(self, realMatrix: 'RealMatrix') -> DecompositionSolver: ...

class MatrixUtils:
    DEFAULT_FORMAT: typing.ClassVar['RealMatrixFormat'] = ...
    OCTAVE_FORMAT: typing.ClassVar['RealMatrixFormat'] = ...
    @staticmethod
    def bigFractionMatrixToRealMatrix(fieldMatrix: 'FieldMatrix'[org.hipparchus.fraction.BigFraction]) -> 'Array2DRowRealMatrix': ...
    @staticmethod
    def blockInverse(realMatrix: 'RealMatrix', int: int) -> 'RealMatrix': ...
    @staticmethod
    def checkAdditionCompatible(anyMatrix: AnyMatrix, anyMatrix2: AnyMatrix) -> None: ...
    @staticmethod
    def checkColumnIndex(anyMatrix: AnyMatrix, int: int) -> None: ...
    @staticmethod
    def checkMatrixIndex(anyMatrix: AnyMatrix, int: int, int2: int) -> None: ...
    @staticmethod
    def checkMultiplicationCompatible(anyMatrix: AnyMatrix, anyMatrix2: AnyMatrix) -> None: ...
    @staticmethod
    def checkRowIndex(anyMatrix: AnyMatrix, int: int) -> None: ...
    @staticmethod
    def checkSameColumnDimension(anyMatrix: AnyMatrix, anyMatrix2: AnyMatrix) -> None: ...
    @staticmethod
    def checkSameRowDimension(anyMatrix: AnyMatrix, anyMatrix2: AnyMatrix) -> None: ...
    @typing.overload
    @staticmethod
    def checkSubMatrixIndex(anyMatrix: AnyMatrix, int: int, int2: int, int3: int, int4: int) -> None: ...
    @typing.overload
    @staticmethod
    def checkSubMatrixIndex(anyMatrix: AnyMatrix, intArray: typing.List[int], intArray2: typing.List[int]) -> None: ...
    @staticmethod
    def checkSubtractionCompatible(anyMatrix: AnyMatrix, anyMatrix2: AnyMatrix) -> None: ...
    @staticmethod
    def checkSymmetric(realMatrix: 'RealMatrix', double: float) -> None: ...
    _createColumnFieldMatrix__T = typing.TypeVar('_createColumnFieldMatrix__T', bound=org.hipparchus.FieldElement)  # <T>
    @staticmethod
    def createColumnFieldMatrix(tArray: typing.List[_createColumnFieldMatrix__T]) -> 'FieldMatrix'[_createColumnFieldMatrix__T]: ...
    @staticmethod
    def createColumnRealMatrix(doubleArray: typing.List[float]) -> 'RealMatrix': ...
    _createFieldDiagonalMatrix__T = typing.TypeVar('_createFieldDiagonalMatrix__T', bound=org.hipparchus.FieldElement)  # <T>
    @staticmethod
    def createFieldDiagonalMatrix(tArray: typing.List[_createFieldDiagonalMatrix__T]) -> 'FieldMatrix'[_createFieldDiagonalMatrix__T]: ...
    _createFieldIdentityMatrix__T = typing.TypeVar('_createFieldIdentityMatrix__T', bound=org.hipparchus.FieldElement)  # <T>
    @staticmethod
    def createFieldIdentityMatrix(field: org.hipparchus.Field[_createFieldIdentityMatrix__T], int: int) -> 'FieldMatrix'[_createFieldIdentityMatrix__T]: ...
    _createFieldMatrix_0__T = typing.TypeVar('_createFieldMatrix_0__T', bound=org.hipparchus.FieldElement)  # <T>
    _createFieldMatrix_1__T = typing.TypeVar('_createFieldMatrix_1__T', bound=org.hipparchus.FieldElement)  # <T>
    @typing.overload
    @staticmethod
    def createFieldMatrix(field: org.hipparchus.Field[_createFieldMatrix_0__T], int: int, int2: int) -> 'FieldMatrix'[_createFieldMatrix_0__T]: ...
    @typing.overload
    @staticmethod
    def createFieldMatrix(tArray: typing.List[typing.List[_createFieldMatrix_1__T]]) -> 'FieldMatrix'[_createFieldMatrix_1__T]: ...
    _createFieldVector_0__T = typing.TypeVar('_createFieldVector_0__T', bound=org.hipparchus.FieldElement)  # <T>
    _createFieldVector_1__T = typing.TypeVar('_createFieldVector_1__T', bound=org.hipparchus.FieldElement)  # <T>
    @typing.overload
    @staticmethod
    def createFieldVector(field: org.hipparchus.Field[_createFieldVector_0__T], int: int) -> FieldVector[_createFieldVector_0__T]: ...
    @typing.overload
    @staticmethod
    def createFieldVector(tArray: typing.List[_createFieldVector_1__T]) -> FieldVector[_createFieldVector_1__T]: ...
    @staticmethod
    def createRealDiagonalMatrix(doubleArray: typing.List[float]) -> 'RealMatrix': ...
    @staticmethod
    def createRealIdentityMatrix(int: int) -> 'RealMatrix': ...
    @typing.overload
    @staticmethod
    def createRealMatrix(doubleArray: typing.List[typing.List[float]]) -> 'RealMatrix': ...
    @typing.overload
    @staticmethod
    def createRealMatrix(int: int, int2: int) -> 'RealMatrix': ...
    @typing.overload
    @staticmethod
    def createRealVector(doubleArray: typing.List[float]) -> 'RealVector': ...
    @typing.overload
    @staticmethod
    def createRealVector(int: int) -> 'RealVector': ...
    _createRowFieldMatrix__T = typing.TypeVar('_createRowFieldMatrix__T', bound=org.hipparchus.FieldElement)  # <T>
    @staticmethod
    def createRowFieldMatrix(tArray: typing.List[_createRowFieldMatrix__T]) -> 'FieldMatrix'[_createRowFieldMatrix__T]: ...
    @staticmethod
    def createRowRealMatrix(doubleArray: typing.List[float]) -> 'RealMatrix': ...
    @staticmethod
    def deserializeRealMatrix(object: typing.Any, string: str, objectInputStream: java.io.ObjectInputStream) -> None: ...
    @staticmethod
    def deserializeRealVector(object: typing.Any, string: str, objectInputStream: java.io.ObjectInputStream) -> None: ...
    @staticmethod
    def fractionMatrixToRealMatrix(fieldMatrix: 'FieldMatrix'[org.hipparchus.fraction.Fraction]) -> 'Array2DRowRealMatrix': ...
    @typing.overload
    @staticmethod
    def inverse(realMatrix: 'RealMatrix') -> 'RealMatrix': ...
    @typing.overload
    @staticmethod
    def inverse(realMatrix: 'RealMatrix', double: float) -> 'RealMatrix': ...
    @staticmethod
    def isSymmetric(realMatrix: 'RealMatrix', double: float) -> bool: ...
    @staticmethod
    def matrixExponential(realMatrix: 'RealMatrix') -> 'RealMatrix': ...
    @staticmethod
    def serializeRealMatrix(realMatrix: 'RealMatrix', objectOutputStream: java.io.ObjectOutputStream) -> None: ...
    @staticmethod
    def serializeRealVector(realVector: 'RealVector', objectOutputStream: java.io.ObjectOutputStream) -> None: ...
    @staticmethod
    def solveLowerTriangularSystem(realMatrix: 'RealMatrix', realVector: 'RealVector') -> None: ...
    @staticmethod
    def solveUpperTriangularSystem(realMatrix: 'RealMatrix', realVector: 'RealVector') -> None: ...

class QRDecomposition:
    @typing.overload
    def __init__(self, realMatrix: 'RealMatrix'): ...
    @typing.overload
    def __init__(self, realMatrix: 'RealMatrix', double: float): ...
    def getH(self) -> 'RealMatrix': ...
    def getQ(self) -> 'RealMatrix': ...
    def getQT(self) -> 'RealMatrix': ...
    def getR(self) -> 'RealMatrix': ...
    def getSolver(self) -> DecompositionSolver: ...

class RealLinearOperator:
    def getColumnDimension(self) -> int: ...
    def getRowDimension(self) -> int: ...
    def isTransposable(self) -> bool: ...
    def operate(self, realVector: 'RealVector') -> 'RealVector': ...
    def operateTranspose(self, realVector: 'RealVector') -> 'RealVector': ...

class RealMatrixChangingVisitor:
    def end(self) -> float: ...
    def start(self, int: int, int2: int, int3: int, int4: int, int5: int, int6: int) -> None: ...
    def visit(self, int: int, int2: int, double: float) -> float: ...

class RealMatrixFormat:
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: str, string2: str, string3: str, string4: str, string5: str, string6: str): ...
    @typing.overload
    def __init__(self, string: str, string2: str, string3: str, string4: str, string5: str, string6: str, numberFormat: java.text.NumberFormat): ...
    @typing.overload
    def __init__(self, numberFormat: java.text.NumberFormat): ...
    @typing.overload
    def format(self, realMatrix: 'RealMatrix') -> str: ...
    @typing.overload
    def format(self, realMatrix: 'RealMatrix', stringBuffer: java.lang.StringBuffer, fieldPosition: java.text.FieldPosition) -> java.lang.StringBuffer: ...
    @staticmethod
    def getAvailableLocales() -> typing.List[java.util.Locale]: ...
    def getColumnSeparator(self) -> str: ...
    def getFormat(self) -> java.text.NumberFormat: ...
    def getPrefix(self) -> str: ...
    @typing.overload
    @staticmethod
    def getRealMatrixFormat() -> 'RealMatrixFormat': ...
    @typing.overload
    @staticmethod
    def getRealMatrixFormat(locale: java.util.Locale) -> 'RealMatrixFormat': ...
    def getRowPrefix(self) -> str: ...
    def getRowSeparator(self) -> str: ...
    def getRowSuffix(self) -> str: ...
    def getSuffix(self) -> str: ...
    @typing.overload
    def parse(self, string: str) -> 'RealMatrix': ...
    @typing.overload
    def parse(self, string: str, parsePosition: java.text.ParsePosition) -> 'RealMatrix': ...

class RealMatrixPreservingVisitor:
    def end(self) -> float: ...
    def start(self, int: int, int2: int, int3: int, int4: int, int5: int, int6: int) -> None: ...
    def visit(self, int: int, int2: int, double: float) -> None: ...

class RealVector:
    def __init__(self): ...
    def add(self, realVector: 'RealVector') -> 'RealVector': ...
    def addToEntry(self, int: int, double: float) -> None: ...
    @typing.overload
    def append(self, double: float) -> 'RealVector': ...
    @typing.overload
    def append(self, realVector: 'RealVector') -> 'RealVector': ...
    def combine(self, double: float, double2: float, realVector: 'RealVector') -> 'RealVector': ...
    def combineToSelf(self, double: float, double2: float, realVector: 'RealVector') -> 'RealVector': ...
    def copy(self) -> 'RealVector': ...
    def cosine(self, realVector: 'RealVector') -> float: ...
    def dotProduct(self, realVector: 'RealVector') -> float: ...
    def ebeDivide(self, realVector: 'RealVector') -> 'RealVector': ...
    def ebeMultiply(self, realVector: 'RealVector') -> 'RealVector': ...
    def equals(self, object: typing.Any) -> bool: ...
    def getDimension(self) -> int: ...
    def getDistance(self, realVector: 'RealVector') -> float: ...
    def getEntry(self, int: int) -> float: ...
    def getL1Distance(self, realVector: 'RealVector') -> float: ...
    def getL1Norm(self) -> float: ...
    def getLInfDistance(self, realVector: 'RealVector') -> float: ...
    def getLInfNorm(self) -> float: ...
    def getMaxIndex(self) -> int: ...
    def getMaxValue(self) -> float: ...
    def getMinIndex(self) -> int: ...
    def getMinValue(self) -> float: ...
    def getNorm(self) -> float: ...
    def getSubVector(self, int: int, int2: int) -> 'RealVector': ...
    def hashCode(self) -> int: ...
    def isInfinite(self) -> bool: ...
    def isNaN(self) -> bool: ...
    def iterator(self) -> java.util.Iterator['RealVector.Entry']: ...
    def map(self, univariateFunction: org.hipparchus.analysis.UnivariateFunction) -> 'RealVector': ...
    def mapAdd(self, double: float) -> 'RealVector': ...
    def mapAddToSelf(self, double: float) -> 'RealVector': ...
    def mapDivide(self, double: float) -> 'RealVector': ...
    def mapDivideToSelf(self, double: float) -> 'RealVector': ...
    def mapMultiply(self, double: float) -> 'RealVector': ...
    def mapMultiplyToSelf(self, double: float) -> 'RealVector': ...
    def mapSubtract(self, double: float) -> 'RealVector': ...
    def mapSubtractToSelf(self, double: float) -> 'RealVector': ...
    def mapToSelf(self, univariateFunction: org.hipparchus.analysis.UnivariateFunction) -> 'RealVector': ...
    def outerProduct(self, realVector: 'RealVector') -> 'RealMatrix': ...
    def projection(self, realVector: 'RealVector') -> 'RealVector': ...
    def set(self, double: float) -> None: ...
    def setEntry(self, int: int, double: float) -> None: ...
    def setSubVector(self, int: int, realVector: 'RealVector') -> None: ...
    def sparseIterator(self) -> java.util.Iterator['RealVector.Entry']: ...
    def subtract(self, realVector: 'RealVector') -> 'RealVector': ...
    def toArray(self) -> typing.List[float]: ...
    def unitVector(self) -> 'RealVector': ...
    def unitize(self) -> None: ...
    @staticmethod
    def unmodifiableRealVector(realVector: 'RealVector') -> 'RealVector': ...
    @typing.overload
    def walkInDefaultOrder(self, realVectorChangingVisitor: 'RealVectorChangingVisitor') -> float: ...
    @typing.overload
    def walkInDefaultOrder(self, realVectorChangingVisitor: 'RealVectorChangingVisitor', int: int, int2: int) -> float: ...
    @typing.overload
    def walkInDefaultOrder(self, realVectorPreservingVisitor: 'RealVectorPreservingVisitor') -> float: ...
    @typing.overload
    def walkInDefaultOrder(self, realVectorPreservingVisitor: 'RealVectorPreservingVisitor', int: int, int2: int) -> float: ...
    @typing.overload
    def walkInOptimizedOrder(self, realVectorChangingVisitor: 'RealVectorChangingVisitor') -> float: ...
    @typing.overload
    def walkInOptimizedOrder(self, realVectorChangingVisitor: 'RealVectorChangingVisitor', int: int, int2: int) -> float: ...
    @typing.overload
    def walkInOptimizedOrder(self, realVectorPreservingVisitor: 'RealVectorPreservingVisitor') -> float: ...
    @typing.overload
    def walkInOptimizedOrder(self, realVectorPreservingVisitor: 'RealVectorPreservingVisitor', int: int, int2: int) -> float: ...
    class Entry:
        def __init__(self, realVector: 'RealVector'): ...
        def getIndex(self) -> int: ...
        def getValue(self) -> float: ...
        def setIndex(self, int: int) -> None: ...
        def setValue(self, double: float) -> None: ...

class RealVectorChangingVisitor:
    def end(self) -> float: ...
    def start(self, int: int, int2: int, int3: int) -> None: ...
    def visit(self, int: int, double: float) -> float: ...

class RealVectorFormat:
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: str, string2: str, string3: str): ...
    @typing.overload
    def __init__(self, string: str, string2: str, string3: str, numberFormat: java.text.NumberFormat): ...
    @typing.overload
    def __init__(self, numberFormat: java.text.NumberFormat): ...
    @typing.overload
    def format(self, realVector: RealVector) -> str: ...
    @typing.overload
    def format(self, realVector: RealVector, stringBuffer: java.lang.StringBuffer, fieldPosition: java.text.FieldPosition) -> java.lang.StringBuffer: ...
    @staticmethod
    def getAvailableLocales() -> typing.List[java.util.Locale]: ...
    def getFormat(self) -> java.text.NumberFormat: ...
    def getPrefix(self) -> str: ...
    @typing.overload
    @staticmethod
    def getRealVectorFormat() -> 'RealVectorFormat': ...
    @typing.overload
    @staticmethod
    def getRealVectorFormat(locale: java.util.Locale) -> 'RealVectorFormat': ...
    def getSeparator(self) -> str: ...
    def getSuffix(self) -> str: ...
    @typing.overload
    def parse(self, string: str) -> 'ArrayRealVector': ...
    @typing.overload
    def parse(self, string: str, parsePosition: java.text.ParsePosition) -> 'ArrayRealVector': ...

class RealVectorPreservingVisitor:
    def end(self) -> float: ...
    def start(self, int: int, int2: int, int3: int) -> None: ...
    def visit(self, int: int, double: float) -> None: ...

class RectangularCholeskyDecomposition:
    @typing.overload
    def __init__(self, realMatrix: 'RealMatrix'): ...
    @typing.overload
    def __init__(self, realMatrix: 'RealMatrix', double: float): ...
    def getRank(self) -> int: ...
    def getRootMatrix(self) -> 'RealMatrix': ...

class RiccatiEquationSolver:
    def getK(self) -> 'RealMatrix': ...
    def getP(self) -> 'RealMatrix': ...

class SingularValueDecomposition:
    def __init__(self, realMatrix: 'RealMatrix'): ...
    def getConditionNumber(self) -> float: ...
    def getCovariance(self, double: float) -> 'RealMatrix': ...
    def getInverseConditionNumber(self) -> float: ...
    def getNorm(self) -> float: ...
    def getRank(self) -> int: ...
    def getS(self) -> 'RealMatrix': ...
    def getSingularValues(self) -> typing.List[float]: ...
    def getSolver(self) -> DecompositionSolver: ...
    def getU(self) -> 'RealMatrix': ...
    def getUT(self) -> 'RealMatrix': ...
    def getV(self) -> 'RealMatrix': ...
    def getVT(self) -> 'RealMatrix': ...

_ArrayFieldVector__T = typing.TypeVar('_ArrayFieldVector__T', bound=org.hipparchus.FieldElement)  # <T>
class ArrayFieldVector(FieldVector[_ArrayFieldVector__T], java.io.Serializable, typing.Generic[_ArrayFieldVector__T]):
    @typing.overload
    def __init__(self, int: int, t: _ArrayFieldVector__T): ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_ArrayFieldVector__T]): ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_ArrayFieldVector__T], int: int): ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_ArrayFieldVector__T], tArray: typing.List[_ArrayFieldVector__T]): ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_ArrayFieldVector__T], tArray: typing.List[_ArrayFieldVector__T], boolean: bool): ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_ArrayFieldVector__T], tArray: typing.List[_ArrayFieldVector__T], int: int, int2: int): ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_ArrayFieldVector__T], tArray: typing.List[_ArrayFieldVector__T], tArray2: typing.List[_ArrayFieldVector__T]): ...
    @typing.overload
    def __init__(self, tArray: typing.List[_ArrayFieldVector__T]): ...
    @typing.overload
    def __init__(self, tArray: typing.List[_ArrayFieldVector__T], boolean: bool): ...
    @typing.overload
    def __init__(self, tArray: typing.List[_ArrayFieldVector__T], int: int, int2: int): ...
    @typing.overload
    def __init__(self, tArray: typing.List[_ArrayFieldVector__T], tArray2: typing.List[_ArrayFieldVector__T]): ...
    @typing.overload
    def __init__(self, tArray: typing.List[_ArrayFieldVector__T], fieldVector: FieldVector[_ArrayFieldVector__T]): ...
    @typing.overload
    def __init__(self, arrayFieldVector: 'ArrayFieldVector'[_ArrayFieldVector__T]): ...
    @typing.overload
    def __init__(self, arrayFieldVector: 'ArrayFieldVector'[_ArrayFieldVector__T], boolean: bool): ...
    @typing.overload
    def __init__(self, fieldVector: FieldVector[_ArrayFieldVector__T]): ...
    @typing.overload
    def __init__(self, fieldVector: FieldVector[_ArrayFieldVector__T], tArray: typing.List[_ArrayFieldVector__T]): ...
    @typing.overload
    def __init__(self, fieldVector: FieldVector[_ArrayFieldVector__T], fieldVector2: FieldVector[_ArrayFieldVector__T]): ...
    @typing.overload
    def add(self, arrayFieldVector: 'ArrayFieldVector'[_ArrayFieldVector__T]) -> 'ArrayFieldVector'[_ArrayFieldVector__T]: ...
    @typing.overload
    def add(self, fieldVector: FieldVector[_ArrayFieldVector__T]) -> FieldVector[_ArrayFieldVector__T]: ...
    @typing.overload
    def append(self, arrayFieldVector: 'ArrayFieldVector'[_ArrayFieldVector__T]) -> 'ArrayFieldVector'[_ArrayFieldVector__T]: ...
    @typing.overload
    def append(self, t: _ArrayFieldVector__T) -> FieldVector[_ArrayFieldVector__T]: ...
    @typing.overload
    def append(self, fieldVector: FieldVector[_ArrayFieldVector__T]) -> FieldVector[_ArrayFieldVector__T]: ...
    def copy(self) -> FieldVector[_ArrayFieldVector__T]: ...
    @typing.overload
    def dotProduct(self, arrayFieldVector: 'ArrayFieldVector'[_ArrayFieldVector__T]) -> _ArrayFieldVector__T: ...
    @typing.overload
    def dotProduct(self, fieldVector: FieldVector[_ArrayFieldVector__T]) -> _ArrayFieldVector__T: ...
    @typing.overload
    def ebeDivide(self, arrayFieldVector: 'ArrayFieldVector'[_ArrayFieldVector__T]) -> 'ArrayFieldVector'[_ArrayFieldVector__T]: ...
    @typing.overload
    def ebeDivide(self, fieldVector: FieldVector[_ArrayFieldVector__T]) -> FieldVector[_ArrayFieldVector__T]: ...
    @typing.overload
    def ebeMultiply(self, arrayFieldVector: 'ArrayFieldVector'[_ArrayFieldVector__T]) -> 'ArrayFieldVector'[_ArrayFieldVector__T]: ...
    @typing.overload
    def ebeMultiply(self, fieldVector: FieldVector[_ArrayFieldVector__T]) -> FieldVector[_ArrayFieldVector__T]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getDataRef(self) -> typing.List[_ArrayFieldVector__T]: ...
    def getDimension(self) -> int: ...
    def getEntry(self, int: int) -> _ArrayFieldVector__T: ...
    def getField(self) -> org.hipparchus.Field[_ArrayFieldVector__T]: ...
    def getSubVector(self, int: int, int2: int) -> FieldVector[_ArrayFieldVector__T]: ...
    def hashCode(self) -> int: ...
    def mapAdd(self, t: _ArrayFieldVector__T) -> FieldVector[_ArrayFieldVector__T]: ...
    def mapAddToSelf(self, t: _ArrayFieldVector__T) -> FieldVector[_ArrayFieldVector__T]: ...
    def mapDivide(self, t: _ArrayFieldVector__T) -> FieldVector[_ArrayFieldVector__T]: ...
    def mapDivideToSelf(self, t: _ArrayFieldVector__T) -> FieldVector[_ArrayFieldVector__T]: ...
    def mapInv(self) -> FieldVector[_ArrayFieldVector__T]: ...
    def mapInvToSelf(self) -> FieldVector[_ArrayFieldVector__T]: ...
    def mapMultiply(self, t: _ArrayFieldVector__T) -> FieldVector[_ArrayFieldVector__T]: ...
    def mapMultiplyToSelf(self, t: _ArrayFieldVector__T) -> FieldVector[_ArrayFieldVector__T]: ...
    def mapSubtract(self, t: _ArrayFieldVector__T) -> FieldVector[_ArrayFieldVector__T]: ...
    def mapSubtractToSelf(self, t: _ArrayFieldVector__T) -> FieldVector[_ArrayFieldVector__T]: ...
    @typing.overload
    def outerProduct(self, arrayFieldVector: 'ArrayFieldVector'[_ArrayFieldVector__T]) -> 'FieldMatrix'[_ArrayFieldVector__T]: ...
    @typing.overload
    def outerProduct(self, fieldVector: FieldVector[_ArrayFieldVector__T]) -> 'FieldMatrix'[_ArrayFieldVector__T]: ...
    @typing.overload
    def projection(self, arrayFieldVector: 'ArrayFieldVector'[_ArrayFieldVector__T]) -> 'ArrayFieldVector'[_ArrayFieldVector__T]: ...
    @typing.overload
    def projection(self, fieldVector: FieldVector[_ArrayFieldVector__T]) -> FieldVector[_ArrayFieldVector__T]: ...
    @typing.overload
    def set(self, int: int, arrayFieldVector: 'ArrayFieldVector'[_ArrayFieldVector__T]) -> None: ...
    @typing.overload
    def set(self, t: _ArrayFieldVector__T) -> None: ...
    def setEntry(self, int: int, t: _ArrayFieldVector__T) -> None: ...
    def setSubVector(self, int: int, fieldVector: FieldVector[_ArrayFieldVector__T]) -> None: ...
    @typing.overload
    def subtract(self, arrayFieldVector: 'ArrayFieldVector'[_ArrayFieldVector__T]) -> 'ArrayFieldVector'[_ArrayFieldVector__T]: ...
    @typing.overload
    def subtract(self, fieldVector: FieldVector[_ArrayFieldVector__T]) -> FieldVector[_ArrayFieldVector__T]: ...
    def toArray(self) -> typing.List[_ArrayFieldVector__T]: ...
    def toString(self) -> str: ...
    @typing.overload
    def walkInDefaultOrder(self, fieldVectorChangingVisitor: FieldVectorChangingVisitor[_ArrayFieldVector__T]) -> _ArrayFieldVector__T: ...
    @typing.overload
    def walkInDefaultOrder(self, fieldVectorChangingVisitor: FieldVectorChangingVisitor[_ArrayFieldVector__T], int: int, int2: int) -> _ArrayFieldVector__T: ...
    @typing.overload
    def walkInDefaultOrder(self, fieldVectorPreservingVisitor: FieldVectorPreservingVisitor[_ArrayFieldVector__T]) -> _ArrayFieldVector__T: ...
    @typing.overload
    def walkInDefaultOrder(self, fieldVectorPreservingVisitor: FieldVectorPreservingVisitor[_ArrayFieldVector__T], int: int, int2: int) -> _ArrayFieldVector__T: ...
    @typing.overload
    def walkInOptimizedOrder(self, fieldVectorChangingVisitor: FieldVectorChangingVisitor[_ArrayFieldVector__T]) -> _ArrayFieldVector__T: ...
    @typing.overload
    def walkInOptimizedOrder(self, fieldVectorChangingVisitor: FieldVectorChangingVisitor[_ArrayFieldVector__T], int: int, int2: int) -> _ArrayFieldVector__T: ...
    @typing.overload
    def walkInOptimizedOrder(self, fieldVectorPreservingVisitor: FieldVectorPreservingVisitor[_ArrayFieldVector__T]) -> _ArrayFieldVector__T: ...
    @typing.overload
    def walkInOptimizedOrder(self, fieldVectorPreservingVisitor: FieldVectorPreservingVisitor[_ArrayFieldVector__T], int: int, int2: int) -> _ArrayFieldVector__T: ...

class ArrayRealVector(RealVector, java.io.Serializable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, doubleArray: typing.List[float]): ...
    @typing.overload
    def __init__(self, doubleArray: typing.List[float], boolean: bool): ...
    @typing.overload
    def __init__(self, doubleArray: typing.List[float], doubleArray2: typing.List[float]): ...
    @typing.overload
    def __init__(self, doubleArray: typing.List[float], int: int, int2: int): ...
    @typing.overload
    def __init__(self, doubleArray: typing.List[float], arrayRealVector: 'ArrayRealVector'): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, double: float): ...
    @typing.overload
    def __init__(self, doubleArray: typing.List[float]): ...
    @typing.overload
    def __init__(self, doubleArray: typing.List[float], int: int, int2: int): ...
    @typing.overload
    def __init__(self, arrayRealVector: 'ArrayRealVector'): ...
    @typing.overload
    def __init__(self, arrayRealVector: 'ArrayRealVector', boolean: bool): ...
    @typing.overload
    def __init__(self, arrayRealVector: 'ArrayRealVector', doubleArray: typing.List[float]): ...
    @typing.overload
    def __init__(self, arrayRealVector: 'ArrayRealVector', arrayRealVector2: 'ArrayRealVector'): ...
    @typing.overload
    def __init__(self, arrayRealVector: 'ArrayRealVector', realVector: RealVector): ...
    @typing.overload
    def __init__(self, realVector: RealVector): ...
    @typing.overload
    def __init__(self, realVector: RealVector, arrayRealVector: 'ArrayRealVector'): ...
    def add(self, realVector: RealVector) -> 'ArrayRealVector': ...
    def addToEntry(self, int: int, double: float) -> None: ...
    @typing.overload
    def append(self, arrayRealVector: 'ArrayRealVector') -> 'ArrayRealVector': ...
    @typing.overload
    def append(self, double: float) -> RealVector: ...
    @typing.overload
    def append(self, realVector: RealVector) -> RealVector: ...
    def combine(self, double: float, double2: float, realVector: RealVector) -> 'ArrayRealVector': ...
    def combineToSelf(self, double: float, double2: float, realVector: RealVector) -> 'ArrayRealVector': ...
    def copy(self) -> 'ArrayRealVector': ...
    def dotProduct(self, realVector: RealVector) -> float: ...
    def ebeDivide(self, realVector: RealVector) -> 'ArrayRealVector': ...
    def ebeMultiply(self, realVector: RealVector) -> 'ArrayRealVector': ...
    def equals(self, object: typing.Any) -> bool: ...
    def getDataRef(self) -> typing.List[float]: ...
    def getDimension(self) -> int: ...
    def getDistance(self, realVector: RealVector) -> float: ...
    def getEntry(self, int: int) -> float: ...
    def getL1Distance(self, realVector: RealVector) -> float: ...
    def getL1Norm(self) -> float: ...
    def getLInfDistance(self, realVector: RealVector) -> float: ...
    def getLInfNorm(self) -> float: ...
    def getNorm(self) -> float: ...
    def getSubVector(self, int: int, int2: int) -> RealVector: ...
    def hashCode(self) -> int: ...
    def isInfinite(self) -> bool: ...
    def isNaN(self) -> bool: ...
    def map(self, univariateFunction: org.hipparchus.analysis.UnivariateFunction) -> 'ArrayRealVector': ...
    def mapAddToSelf(self, double: float) -> RealVector: ...
    def mapDivideToSelf(self, double: float) -> RealVector: ...
    def mapMultiplyToSelf(self, double: float) -> RealVector: ...
    def mapSubtractToSelf(self, double: float) -> RealVector: ...
    def mapToSelf(self, univariateFunction: org.hipparchus.analysis.UnivariateFunction) -> 'ArrayRealVector': ...
    def outerProduct(self, realVector: RealVector) -> 'RealMatrix': ...
    def set(self, double: float) -> None: ...
    def setEntry(self, int: int, double: float) -> None: ...
    @typing.overload
    def setSubVector(self, int: int, doubleArray: typing.List[float]) -> None: ...
    @typing.overload
    def setSubVector(self, int: int, realVector: RealVector) -> None: ...
    def subtract(self, realVector: RealVector) -> 'ArrayRealVector': ...
    def toArray(self) -> typing.List[float]: ...
    def toString(self) -> str: ...
    @typing.overload
    def walkInDefaultOrder(self, realVectorChangingVisitor: RealVectorChangingVisitor) -> float: ...
    @typing.overload
    def walkInDefaultOrder(self, realVectorChangingVisitor: RealVectorChangingVisitor, int: int, int2: int) -> float: ...
    @typing.overload
    def walkInDefaultOrder(self, realVectorPreservingVisitor: RealVectorPreservingVisitor) -> float: ...
    @typing.overload
    def walkInDefaultOrder(self, realVectorPreservingVisitor: RealVectorPreservingVisitor, int: int, int2: int) -> float: ...
    @typing.overload
    def walkInOptimizedOrder(self, realVectorChangingVisitor: RealVectorChangingVisitor) -> float: ...
    @typing.overload
    def walkInOptimizedOrder(self, realVectorChangingVisitor: RealVectorChangingVisitor, int: int, int2: int) -> float: ...
    @typing.overload
    def walkInOptimizedOrder(self, realVectorPreservingVisitor: RealVectorPreservingVisitor) -> float: ...
    @typing.overload
    def walkInOptimizedOrder(self, realVectorPreservingVisitor: RealVectorPreservingVisitor, int: int, int2: int) -> float: ...

class CholeskyDecomposer(MatrixDecomposer):
    def __init__(self, double: float, double2: float): ...
    def decompose(self, realMatrix: 'RealMatrix') -> DecompositionSolver: ...

_DefaultFieldMatrixChangingVisitor__T = typing.TypeVar('_DefaultFieldMatrixChangingVisitor__T', bound=org.hipparchus.FieldElement)  # <T>
class DefaultFieldMatrixChangingVisitor(FieldMatrixChangingVisitor[_DefaultFieldMatrixChangingVisitor__T], typing.Generic[_DefaultFieldMatrixChangingVisitor__T]):
    def __init__(self, t: _DefaultFieldMatrixChangingVisitor__T): ...
    def end(self) -> _DefaultFieldMatrixChangingVisitor__T: ...
    def start(self, int: int, int2: int, int3: int, int4: int, int5: int, int6: int) -> None: ...
    def visit(self, int: int, int2: int, t: _DefaultFieldMatrixChangingVisitor__T) -> _DefaultFieldMatrixChangingVisitor__T: ...

_DefaultFieldMatrixPreservingVisitor__T = typing.TypeVar('_DefaultFieldMatrixPreservingVisitor__T', bound=org.hipparchus.FieldElement)  # <T>
class DefaultFieldMatrixPreservingVisitor(FieldMatrixPreservingVisitor[_DefaultFieldMatrixPreservingVisitor__T], typing.Generic[_DefaultFieldMatrixPreservingVisitor__T]):
    def __init__(self, t: _DefaultFieldMatrixPreservingVisitor__T): ...
    def end(self) -> _DefaultFieldMatrixPreservingVisitor__T: ...
    def start(self, int: int, int2: int, int3: int, int4: int, int5: int, int6: int) -> None: ...
    def visit(self, int: int, int2: int, t: _DefaultFieldMatrixPreservingVisitor__T) -> None: ...

class DefaultIterativeLinearSolverEvent(IterativeLinearSolverEvent):
    @typing.overload
    def __init__(self, object: typing.Any, int: int, realVector: RealVector, realVector2: RealVector, double: float): ...
    @typing.overload
    def __init__(self, object: typing.Any, int: int, realVector: RealVector, realVector2: RealVector, realVector3: RealVector, double: float): ...
    def getNormOfResidual(self) -> float: ...
    def getResidual(self) -> RealVector: ...
    def getRightHandSideVector(self) -> RealVector: ...
    def getSolution(self) -> RealVector: ...
    def providesResidual(self) -> bool: ...

class DefaultRealMatrixChangingVisitor(RealMatrixChangingVisitor):
    def __init__(self): ...
    def end(self) -> float: ...
    def start(self, int: int, int2: int, int3: int, int4: int, int5: int, int6: int) -> None: ...
    def visit(self, int: int, int2: int, double: float) -> float: ...

class DefaultRealMatrixPreservingVisitor(RealMatrixPreservingVisitor):
    def __init__(self): ...
    def end(self) -> float: ...
    def start(self, int: int, int2: int, int3: int, int4: int, int5: int, int6: int) -> None: ...
    def visit(self, int: int, int2: int, double: float) -> None: ...

_FieldMatrix__T = typing.TypeVar('_FieldMatrix__T', bound=org.hipparchus.FieldElement)  # <T>
class FieldMatrix(AnyMatrix, typing.Generic[_FieldMatrix__T]):
    def add(self, fieldMatrix: 'FieldMatrix'[_FieldMatrix__T]) -> 'FieldMatrix'[_FieldMatrix__T]: ...
    def addToEntry(self, int: int, int2: int, t: _FieldMatrix__T) -> None: ...
    def copy(self) -> 'FieldMatrix'[_FieldMatrix__T]: ...
    @typing.overload
    def copySubMatrix(self, int: int, int2: int, int3: int, int4: int, tArray: typing.List[typing.List[_FieldMatrix__T]]) -> None: ...
    @typing.overload
    def copySubMatrix(self, intArray: typing.List[int], intArray2: typing.List[int], tArray: typing.List[typing.List[_FieldMatrix__T]]) -> None: ...
    def createMatrix(self, int: int, int2: int) -> 'FieldMatrix'[_FieldMatrix__T]: ...
    def getColumn(self, int: int) -> typing.List[_FieldMatrix__T]: ...
    def getColumnMatrix(self, int: int) -> 'FieldMatrix'[_FieldMatrix__T]: ...
    def getColumnVector(self, int: int) -> FieldVector[_FieldMatrix__T]: ...
    def getData(self) -> typing.List[typing.List[_FieldMatrix__T]]: ...
    def getEntry(self, int: int, int2: int) -> _FieldMatrix__T: ...
    def getField(self) -> org.hipparchus.Field[_FieldMatrix__T]: ...
    def getRow(self, int: int) -> typing.List[_FieldMatrix__T]: ...
    def getRowMatrix(self, int: int) -> 'FieldMatrix'[_FieldMatrix__T]: ...
    def getRowVector(self, int: int) -> FieldVector[_FieldMatrix__T]: ...
    @typing.overload
    def getSubMatrix(self, int: int, int2: int, int3: int, int4: int) -> 'FieldMatrix'[_FieldMatrix__T]: ...
    @typing.overload
    def getSubMatrix(self, intArray: typing.List[int], intArray2: typing.List[int]) -> 'FieldMatrix'[_FieldMatrix__T]: ...
    def getTrace(self) -> _FieldMatrix__T: ...
    def map(self, function: typing.Union[java.util.function.Function[_FieldMatrix__T, _FieldMatrix__T], typing.Callable[[_FieldMatrix__T], _FieldMatrix__T]]) -> 'FieldMatrix'[_FieldMatrix__T]: ...
    def mapToSelf(self, function: typing.Union[java.util.function.Function[_FieldMatrix__T, _FieldMatrix__T], typing.Callable[[_FieldMatrix__T], _FieldMatrix__T]]) -> 'FieldMatrix'[_FieldMatrix__T]: ...
    def multiply(self, fieldMatrix: 'FieldMatrix'[_FieldMatrix__T]) -> 'FieldMatrix'[_FieldMatrix__T]: ...
    def multiplyEntry(self, int: int, int2: int, t: _FieldMatrix__T) -> None: ...
    def multiplyTransposed(self, fieldMatrix: 'FieldMatrix'[_FieldMatrix__T]) -> 'FieldMatrix'[_FieldMatrix__T]: ...
    @typing.overload
    def operate(self, tArray: typing.List[_FieldMatrix__T]) -> typing.List[_FieldMatrix__T]: ...
    @typing.overload
    def operate(self, fieldVector: FieldVector[_FieldMatrix__T]) -> FieldVector[_FieldMatrix__T]: ...
    def power(self, int: int) -> 'FieldMatrix'[_FieldMatrix__T]: ...
    @typing.overload
    def preMultiply(self, tArray: typing.List[_FieldMatrix__T]) -> typing.List[_FieldMatrix__T]: ...
    @typing.overload
    def preMultiply(self, fieldMatrix: 'FieldMatrix'[_FieldMatrix__T]) -> 'FieldMatrix'[_FieldMatrix__T]: ...
    @typing.overload
    def preMultiply(self, fieldVector: FieldVector[_FieldMatrix__T]) -> FieldVector[_FieldMatrix__T]: ...
    def scalarAdd(self, t: _FieldMatrix__T) -> 'FieldMatrix'[_FieldMatrix__T]: ...
    def scalarMultiply(self, t: _FieldMatrix__T) -> 'FieldMatrix'[_FieldMatrix__T]: ...
    def setColumn(self, int: int, tArray: typing.List[_FieldMatrix__T]) -> None: ...
    def setColumnMatrix(self, int: int, fieldMatrix: 'FieldMatrix'[_FieldMatrix__T]) -> None: ...
    def setColumnVector(self, int: int, fieldVector: FieldVector[_FieldMatrix__T]) -> None: ...
    def setEntry(self, int: int, int2: int, t: _FieldMatrix__T) -> None: ...
    def setRow(self, int: int, tArray: typing.List[_FieldMatrix__T]) -> None: ...
    def setRowMatrix(self, int: int, fieldMatrix: 'FieldMatrix'[_FieldMatrix__T]) -> None: ...
    def setRowVector(self, int: int, fieldVector: FieldVector[_FieldMatrix__T]) -> None: ...
    def setSubMatrix(self, tArray: typing.List[typing.List[_FieldMatrix__T]], int: int, int2: int) -> None: ...
    def subtract(self, fieldMatrix: 'FieldMatrix'[_FieldMatrix__T]) -> 'FieldMatrix'[_FieldMatrix__T]: ...
    def transpose(self) -> 'FieldMatrix'[_FieldMatrix__T]: ...
    def transposeMultiply(self, fieldMatrix: 'FieldMatrix'[_FieldMatrix__T]) -> 'FieldMatrix'[_FieldMatrix__T]: ...
    @typing.overload
    def walkInColumnOrder(self, fieldMatrixChangingVisitor: FieldMatrixChangingVisitor[_FieldMatrix__T]) -> _FieldMatrix__T: ...
    @typing.overload
    def walkInColumnOrder(self, fieldMatrixChangingVisitor: FieldMatrixChangingVisitor[_FieldMatrix__T], int: int, int2: int, int3: int, int4: int) -> _FieldMatrix__T: ...
    @typing.overload
    def walkInColumnOrder(self, fieldMatrixPreservingVisitor: FieldMatrixPreservingVisitor[_FieldMatrix__T]) -> _FieldMatrix__T: ...
    @typing.overload
    def walkInColumnOrder(self, fieldMatrixPreservingVisitor: FieldMatrixPreservingVisitor[_FieldMatrix__T], int: int, int2: int, int3: int, int4: int) -> _FieldMatrix__T: ...
    @typing.overload
    def walkInOptimizedOrder(self, fieldMatrixChangingVisitor: FieldMatrixChangingVisitor[_FieldMatrix__T]) -> _FieldMatrix__T: ...
    @typing.overload
    def walkInOptimizedOrder(self, fieldMatrixChangingVisitor: FieldMatrixChangingVisitor[_FieldMatrix__T], int: int, int2: int, int3: int, int4: int) -> _FieldMatrix__T: ...
    @typing.overload
    def walkInOptimizedOrder(self, fieldMatrixPreservingVisitor: FieldMatrixPreservingVisitor[_FieldMatrix__T]) -> _FieldMatrix__T: ...
    @typing.overload
    def walkInOptimizedOrder(self, fieldMatrixPreservingVisitor: FieldMatrixPreservingVisitor[_FieldMatrix__T], int: int, int2: int, int3: int, int4: int) -> _FieldMatrix__T: ...
    @typing.overload
    def walkInRowOrder(self, fieldMatrixChangingVisitor: FieldMatrixChangingVisitor[_FieldMatrix__T]) -> _FieldMatrix__T: ...
    @typing.overload
    def walkInRowOrder(self, fieldMatrixChangingVisitor: FieldMatrixChangingVisitor[_FieldMatrix__T], int: int, int2: int, int3: int, int4: int) -> _FieldMatrix__T: ...
    @typing.overload
    def walkInRowOrder(self, fieldMatrixPreservingVisitor: FieldMatrixPreservingVisitor[_FieldMatrix__T]) -> _FieldMatrix__T: ...
    @typing.overload
    def walkInRowOrder(self, fieldMatrixPreservingVisitor: FieldMatrixPreservingVisitor[_FieldMatrix__T], int: int, int2: int, int3: int, int4: int) -> _FieldMatrix__T: ...

class JacobiPreconditioner(RealLinearOperator):
    def __init__(self, doubleArray: typing.List[float], boolean: bool): ...
    @staticmethod
    def create(realLinearOperator: RealLinearOperator) -> 'JacobiPreconditioner': ...
    def getColumnDimension(self) -> int: ...
    def getRowDimension(self) -> int: ...
    def operate(self, realVector: RealVector) -> RealVector: ...
    def sqrt(self) -> RealLinearOperator: ...

class LUDecomposer(MatrixDecomposer):
    def __init__(self, double: float): ...
    def decompose(self, realMatrix: 'RealMatrix') -> DecompositionSolver: ...

class OrderedComplexEigenDecomposition(ComplexEigenDecomposition):
    @typing.overload
    def __init__(self, realMatrix: 'RealMatrix'): ...
    @typing.overload
    def __init__(self, realMatrix: 'RealMatrix', double: float, double2: float, double3: float): ...
    def getVT(self) -> FieldMatrix[org.hipparchus.complex.Complex]: ...

class OrderedEigenDecomposition(EigenDecomposition):
    def __init__(self, realMatrix: 'RealMatrix'): ...
    def getVT(self) -> 'RealMatrix': ...

class PreconditionedIterativeLinearSolver(IterativeLinearSolver):
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, iterationManager: org.hipparchus.util.IterationManager): ...
    @typing.overload
    def solve(self, realLinearOperator: RealLinearOperator, realLinearOperator2: RealLinearOperator, realVector: RealVector) -> RealVector: ...
    @typing.overload
    def solve(self, realLinearOperator: RealLinearOperator, realLinearOperator2: RealLinearOperator, realVector: RealVector, realVector2: RealVector) -> RealVector: ...
    @typing.overload
    def solve(self, realLinearOperator: RealLinearOperator, realVector: RealVector) -> RealVector: ...
    @typing.overload
    def solve(self, realLinearOperator: RealLinearOperator, realVector: RealVector, realVector2: RealVector) -> RealVector: ...
    @typing.overload
    def solveInPlace(self, realLinearOperator: RealLinearOperator, realLinearOperator2: RealLinearOperator, realVector: RealVector, realVector2: RealVector) -> RealVector: ...
    @typing.overload
    def solveInPlace(self, realLinearOperator: RealLinearOperator, realVector: RealVector, realVector2: RealVector) -> RealVector: ...

class QRDecomposer(MatrixDecomposer):
    def __init__(self, double: float): ...
    def decompose(self, realMatrix: 'RealMatrix') -> DecompositionSolver: ...

class RRQRDecomposition(QRDecomposition):
    @typing.overload
    def __init__(self, realMatrix: 'RealMatrix'): ...
    @typing.overload
    def __init__(self, realMatrix: 'RealMatrix', double: float): ...
    def getP(self) -> 'RealMatrix': ...
    def getRank(self, double: float) -> int: ...
    def getSolver(self) -> DecompositionSolver: ...

class RealMatrix(AnyMatrix):
    def add(self, realMatrix: 'RealMatrix') -> 'RealMatrix': ...
    def addToEntry(self, int: int, int2: int, double: float) -> None: ...
    def copy(self) -> 'RealMatrix': ...
    @typing.overload
    def copySubMatrix(self, int: int, int2: int, int3: int, int4: int, doubleArray: typing.List[typing.List[float]]) -> None: ...
    @typing.overload
    def copySubMatrix(self, intArray: typing.List[int], intArray2: typing.List[int], doubleArray: typing.List[typing.List[float]]) -> None: ...
    def createMatrix(self, int: int, int2: int) -> 'RealMatrix': ...
    def getColumn(self, int: int) -> typing.List[float]: ...
    def getColumnMatrix(self, int: int) -> 'RealMatrix': ...
    def getColumnVector(self, int: int) -> RealVector: ...
    def getData(self) -> typing.List[typing.List[float]]: ...
    def getEntry(self, int: int, int2: int) -> float: ...
    def getFrobeniusNorm(self) -> float: ...
    def getNorm1(self) -> float: ...
    def getNormInfty(self) -> float: ...
    def getRow(self, int: int) -> typing.List[float]: ...
    def getRowMatrix(self, int: int) -> 'RealMatrix': ...
    def getRowVector(self, int: int) -> RealVector: ...
    @typing.overload
    def getSubMatrix(self, int: int, int2: int, int3: int, int4: int) -> 'RealMatrix': ...
    @typing.overload
    def getSubMatrix(self, intArray: typing.List[int], intArray2: typing.List[int]) -> 'RealMatrix': ...
    def getTrace(self) -> float: ...
    def map(self, univariateFunction: org.hipparchus.analysis.UnivariateFunction) -> 'RealMatrix': ...
    def mapToSelf(self, univariateFunction: org.hipparchus.analysis.UnivariateFunction) -> 'RealMatrix': ...
    def multiply(self, realMatrix: 'RealMatrix') -> 'RealMatrix': ...
    def multiplyEntry(self, int: int, int2: int, double: float) -> None: ...
    def multiplyTransposed(self, realMatrix: 'RealMatrix') -> 'RealMatrix': ...
    @typing.overload
    def operate(self, doubleArray: typing.List[float]) -> typing.List[float]: ...
    @typing.overload
    def operate(self, realVector: RealVector) -> RealVector: ...
    def power(self, int: int) -> 'RealMatrix': ...
    @typing.overload
    def preMultiply(self, doubleArray: typing.List[float]) -> typing.List[float]: ...
    @typing.overload
    def preMultiply(self, realMatrix: 'RealMatrix') -> 'RealMatrix': ...
    @typing.overload
    def preMultiply(self, realVector: RealVector) -> RealVector: ...
    def scalarAdd(self, double: float) -> 'RealMatrix': ...
    def scalarMultiply(self, double: float) -> 'RealMatrix': ...
    def setColumn(self, int: int, doubleArray: typing.List[float]) -> None: ...
    def setColumnMatrix(self, int: int, realMatrix: 'RealMatrix') -> None: ...
    def setColumnVector(self, int: int, realVector: RealVector) -> None: ...
    def setEntry(self, int: int, int2: int, double: float) -> None: ...
    def setRow(self, int: int, doubleArray: typing.List[float]) -> None: ...
    def setRowMatrix(self, int: int, realMatrix: 'RealMatrix') -> None: ...
    def setRowVector(self, int: int, realVector: RealVector) -> None: ...
    def setSubMatrix(self, doubleArray: typing.List[typing.List[float]], int: int, int2: int) -> None: ...
    def subtract(self, realMatrix: 'RealMatrix') -> 'RealMatrix': ...
    def transpose(self) -> 'RealMatrix': ...
    def transposeMultiply(self, realMatrix: 'RealMatrix') -> 'RealMatrix': ...
    @typing.overload
    def walkInColumnOrder(self, realMatrixChangingVisitor: RealMatrixChangingVisitor) -> float: ...
    @typing.overload
    def walkInColumnOrder(self, realMatrixChangingVisitor: RealMatrixChangingVisitor, int: int, int2: int, int3: int, int4: int) -> float: ...
    @typing.overload
    def walkInColumnOrder(self, realMatrixPreservingVisitor: RealMatrixPreservingVisitor) -> float: ...
    @typing.overload
    def walkInColumnOrder(self, realMatrixPreservingVisitor: RealMatrixPreservingVisitor, int: int, int2: int, int3: int, int4: int) -> float: ...
    @typing.overload
    def walkInOptimizedOrder(self, realMatrixChangingVisitor: RealMatrixChangingVisitor) -> float: ...
    @typing.overload
    def walkInOptimizedOrder(self, realMatrixChangingVisitor: RealMatrixChangingVisitor, int: int, int2: int, int3: int, int4: int) -> float: ...
    @typing.overload
    def walkInOptimizedOrder(self, realMatrixPreservingVisitor: RealMatrixPreservingVisitor) -> float: ...
    @typing.overload
    def walkInOptimizedOrder(self, realMatrixPreservingVisitor: RealMatrixPreservingVisitor, int: int, int2: int, int3: int, int4: int) -> float: ...
    @typing.overload
    def walkInRowOrder(self, realMatrixChangingVisitor: RealMatrixChangingVisitor) -> float: ...
    @typing.overload
    def walkInRowOrder(self, realMatrixChangingVisitor: RealMatrixChangingVisitor, int: int, int2: int, int3: int, int4: int) -> float: ...
    @typing.overload
    def walkInRowOrder(self, realMatrixPreservingVisitor: RealMatrixPreservingVisitor) -> float: ...
    @typing.overload
    def walkInRowOrder(self, realMatrixPreservingVisitor: RealMatrixPreservingVisitor, int: int, int2: int, int3: int, int4: int) -> float: ...

class RiccatiEquationSolverImpl(RiccatiEquationSolver):
    def __init__(self, realMatrix: RealMatrix, realMatrix2: RealMatrix, realMatrix3: RealMatrix, realMatrix4: RealMatrix): ...
    def getK(self) -> RealMatrix: ...
    def getP(self) -> RealMatrix: ...

class SingularValueDecomposer(MatrixDecomposer):
    def __init__(self): ...
    def decompose(self, realMatrix: RealMatrix) -> DecompositionSolver: ...

_SparseFieldVector__T = typing.TypeVar('_SparseFieldVector__T', bound=org.hipparchus.FieldElement)  # <T>
class SparseFieldVector(FieldVector[_SparseFieldVector__T], java.io.Serializable, typing.Generic[_SparseFieldVector__T]):
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_SparseFieldVector__T]): ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_SparseFieldVector__T], int: int): ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_SparseFieldVector__T], int: int, int2: int): ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_SparseFieldVector__T], tArray: typing.List[_SparseFieldVector__T]): ...
    @typing.overload
    def __init__(self, sparseFieldVector: 'SparseFieldVector'[_SparseFieldVector__T]): ...
    @typing.overload
    def add(self, fieldVector: FieldVector[_SparseFieldVector__T]) -> FieldVector[_SparseFieldVector__T]: ...
    @typing.overload
    def add(self, sparseFieldVector: 'SparseFieldVector'[_SparseFieldVector__T]) -> FieldVector[_SparseFieldVector__T]: ...
    @typing.overload
    def append(self, t: _SparseFieldVector__T) -> FieldVector[_SparseFieldVector__T]: ...
    @typing.overload
    def append(self, fieldVector: FieldVector[_SparseFieldVector__T]) -> FieldVector[_SparseFieldVector__T]: ...
    @typing.overload
    def append(self, sparseFieldVector: 'SparseFieldVector'[_SparseFieldVector__T]) -> FieldVector[_SparseFieldVector__T]: ...
    def copy(self) -> FieldVector[_SparseFieldVector__T]: ...
    def dotProduct(self, fieldVector: FieldVector[_SparseFieldVector__T]) -> _SparseFieldVector__T: ...
    def ebeDivide(self, fieldVector: FieldVector[_SparseFieldVector__T]) -> FieldVector[_SparseFieldVector__T]: ...
    def ebeMultiply(self, fieldVector: FieldVector[_SparseFieldVector__T]) -> FieldVector[_SparseFieldVector__T]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getDimension(self) -> int: ...
    def getEntry(self, int: int) -> _SparseFieldVector__T: ...
    def getField(self) -> org.hipparchus.Field[_SparseFieldVector__T]: ...
    def getSubVector(self, int: int, int2: int) -> FieldVector[_SparseFieldVector__T]: ...
    def hashCode(self) -> int: ...
    def mapAdd(self, t: _SparseFieldVector__T) -> FieldVector[_SparseFieldVector__T]: ...
    def mapAddToSelf(self, t: _SparseFieldVector__T) -> FieldVector[_SparseFieldVector__T]: ...
    def mapDivide(self, t: _SparseFieldVector__T) -> FieldVector[_SparseFieldVector__T]: ...
    def mapDivideToSelf(self, t: _SparseFieldVector__T) -> FieldVector[_SparseFieldVector__T]: ...
    def mapInv(self) -> FieldVector[_SparseFieldVector__T]: ...
    def mapInvToSelf(self) -> FieldVector[_SparseFieldVector__T]: ...
    def mapMultiply(self, t: _SparseFieldVector__T) -> FieldVector[_SparseFieldVector__T]: ...
    def mapMultiplyToSelf(self, t: _SparseFieldVector__T) -> FieldVector[_SparseFieldVector__T]: ...
    def mapSubtract(self, t: _SparseFieldVector__T) -> FieldVector[_SparseFieldVector__T]: ...
    def mapSubtractToSelf(self, t: _SparseFieldVector__T) -> FieldVector[_SparseFieldVector__T]: ...
    @typing.overload
    def outerProduct(self, fieldVector: FieldVector[_SparseFieldVector__T]) -> FieldMatrix[_SparseFieldVector__T]: ...
    @typing.overload
    def outerProduct(self, sparseFieldVector: 'SparseFieldVector'[_SparseFieldVector__T]) -> FieldMatrix[_SparseFieldVector__T]: ...
    def projection(self, fieldVector: FieldVector[_SparseFieldVector__T]) -> FieldVector[_SparseFieldVector__T]: ...
    def set(self, t: _SparseFieldVector__T) -> None: ...
    def setEntry(self, int: int, t: _SparseFieldVector__T) -> None: ...
    def setSubVector(self, int: int, fieldVector: FieldVector[_SparseFieldVector__T]) -> None: ...
    @typing.overload
    def subtract(self, fieldVector: FieldVector[_SparseFieldVector__T]) -> FieldVector[_SparseFieldVector__T]: ...
    @typing.overload
    def subtract(self, sparseFieldVector: 'SparseFieldVector'[_SparseFieldVector__T]) -> 'SparseFieldVector'[_SparseFieldVector__T]: ...
    def toArray(self) -> typing.List[_SparseFieldVector__T]: ...
    @typing.overload
    def walkInDefaultOrder(self, fieldVectorChangingVisitor: FieldVectorChangingVisitor[_SparseFieldVector__T]) -> _SparseFieldVector__T: ...
    @typing.overload
    def walkInDefaultOrder(self, fieldVectorChangingVisitor: FieldVectorChangingVisitor[_SparseFieldVector__T], int: int, int2: int) -> _SparseFieldVector__T: ...
    @typing.overload
    def walkInDefaultOrder(self, fieldVectorPreservingVisitor: FieldVectorPreservingVisitor[_SparseFieldVector__T]) -> _SparseFieldVector__T: ...
    @typing.overload
    def walkInDefaultOrder(self, fieldVectorPreservingVisitor: FieldVectorPreservingVisitor[_SparseFieldVector__T], int: int, int2: int) -> _SparseFieldVector__T: ...
    @typing.overload
    def walkInOptimizedOrder(self, fieldVectorChangingVisitor: FieldVectorChangingVisitor[_SparseFieldVector__T]) -> _SparseFieldVector__T: ...
    @typing.overload
    def walkInOptimizedOrder(self, fieldVectorChangingVisitor: FieldVectorChangingVisitor[_SparseFieldVector__T], int: int, int2: int) -> _SparseFieldVector__T: ...
    @typing.overload
    def walkInOptimizedOrder(self, fieldVectorPreservingVisitor: FieldVectorPreservingVisitor[_SparseFieldVector__T]) -> _SparseFieldVector__T: ...
    @typing.overload
    def walkInOptimizedOrder(self, fieldVectorPreservingVisitor: FieldVectorPreservingVisitor[_SparseFieldVector__T], int: int, int2: int) -> _SparseFieldVector__T: ...

class SparseRealVector(RealVector):
    def __init__(self): ...

_AbstractFieldMatrix__T = typing.TypeVar('_AbstractFieldMatrix__T', bound=org.hipparchus.FieldElement)  # <T>
class AbstractFieldMatrix(FieldMatrix[_AbstractFieldMatrix__T], typing.Generic[_AbstractFieldMatrix__T]):
    def add(self, fieldMatrix: FieldMatrix[_AbstractFieldMatrix__T]) -> FieldMatrix[_AbstractFieldMatrix__T]: ...
    def addToEntry(self, int: int, int2: int, t: _AbstractFieldMatrix__T) -> None: ...
    def copy(self) -> FieldMatrix[_AbstractFieldMatrix__T]: ...
    @typing.overload
    def copySubMatrix(self, int: int, int2: int, int3: int, int4: int, tArray: typing.List[typing.List[_AbstractFieldMatrix__T]]) -> None: ...
    @typing.overload
    def copySubMatrix(self, intArray: typing.List[int], intArray2: typing.List[int], tArray: typing.List[typing.List[_AbstractFieldMatrix__T]]) -> None: ...
    def createMatrix(self, int: int, int2: int) -> FieldMatrix[_AbstractFieldMatrix__T]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getColumn(self, int: int) -> typing.List[_AbstractFieldMatrix__T]: ...
    def getColumnDimension(self) -> int: ...
    def getColumnMatrix(self, int: int) -> FieldMatrix[_AbstractFieldMatrix__T]: ...
    def getColumnVector(self, int: int) -> FieldVector[_AbstractFieldMatrix__T]: ...
    def getData(self) -> typing.List[typing.List[_AbstractFieldMatrix__T]]: ...
    def getEntry(self, int: int, int2: int) -> _AbstractFieldMatrix__T: ...
    def getField(self) -> org.hipparchus.Field[_AbstractFieldMatrix__T]: ...
    def getRow(self, int: int) -> typing.List[_AbstractFieldMatrix__T]: ...
    def getRowDimension(self) -> int: ...
    def getRowMatrix(self, int: int) -> FieldMatrix[_AbstractFieldMatrix__T]: ...
    def getRowVector(self, int: int) -> FieldVector[_AbstractFieldMatrix__T]: ...
    @typing.overload
    def getSubMatrix(self, int: int, int2: int, int3: int, int4: int) -> FieldMatrix[_AbstractFieldMatrix__T]: ...
    @typing.overload
    def getSubMatrix(self, intArray: typing.List[int], intArray2: typing.List[int]) -> FieldMatrix[_AbstractFieldMatrix__T]: ...
    def getTrace(self) -> _AbstractFieldMatrix__T: ...
    def hashCode(self) -> int: ...
    def isSquare(self) -> bool: ...
    def multiply(self, fieldMatrix: FieldMatrix[_AbstractFieldMatrix__T]) -> FieldMatrix[_AbstractFieldMatrix__T]: ...
    def multiplyEntry(self, int: int, int2: int, t: _AbstractFieldMatrix__T) -> None: ...
    @typing.overload
    def operate(self, tArray: typing.List[_AbstractFieldMatrix__T]) -> typing.List[_AbstractFieldMatrix__T]: ...
    @typing.overload
    def operate(self, fieldVector: FieldVector[_AbstractFieldMatrix__T]) -> FieldVector[_AbstractFieldMatrix__T]: ...
    def power(self, int: int) -> FieldMatrix[_AbstractFieldMatrix__T]: ...
    @typing.overload
    def preMultiply(self, tArray: typing.List[_AbstractFieldMatrix__T]) -> typing.List[_AbstractFieldMatrix__T]: ...
    @typing.overload
    def preMultiply(self, fieldMatrix: FieldMatrix[_AbstractFieldMatrix__T]) -> FieldMatrix[_AbstractFieldMatrix__T]: ...
    @typing.overload
    def preMultiply(self, fieldVector: FieldVector[_AbstractFieldMatrix__T]) -> FieldVector[_AbstractFieldMatrix__T]: ...
    def scalarAdd(self, t: _AbstractFieldMatrix__T) -> FieldMatrix[_AbstractFieldMatrix__T]: ...
    def scalarMultiply(self, t: _AbstractFieldMatrix__T) -> FieldMatrix[_AbstractFieldMatrix__T]: ...
    def setColumn(self, int: int, tArray: typing.List[_AbstractFieldMatrix__T]) -> None: ...
    def setColumnMatrix(self, int: int, fieldMatrix: FieldMatrix[_AbstractFieldMatrix__T]) -> None: ...
    def setColumnVector(self, int: int, fieldVector: FieldVector[_AbstractFieldMatrix__T]) -> None: ...
    def setEntry(self, int: int, int2: int, t: _AbstractFieldMatrix__T) -> None: ...
    def setRow(self, int: int, tArray: typing.List[_AbstractFieldMatrix__T]) -> None: ...
    def setRowMatrix(self, int: int, fieldMatrix: FieldMatrix[_AbstractFieldMatrix__T]) -> None: ...
    def setRowVector(self, int: int, fieldVector: FieldVector[_AbstractFieldMatrix__T]) -> None: ...
    def setSubMatrix(self, tArray: typing.List[typing.List[_AbstractFieldMatrix__T]], int: int, int2: int) -> None: ...
    def subtract(self, fieldMatrix: FieldMatrix[_AbstractFieldMatrix__T]) -> FieldMatrix[_AbstractFieldMatrix__T]: ...
    def toString(self) -> str: ...
    def transpose(self) -> FieldMatrix[_AbstractFieldMatrix__T]: ...
    @typing.overload
    def walkInColumnOrder(self, fieldMatrixChangingVisitor: FieldMatrixChangingVisitor[_AbstractFieldMatrix__T]) -> _AbstractFieldMatrix__T: ...
    @typing.overload
    def walkInColumnOrder(self, fieldMatrixChangingVisitor: FieldMatrixChangingVisitor[_AbstractFieldMatrix__T], int: int, int2: int, int3: int, int4: int) -> _AbstractFieldMatrix__T: ...
    @typing.overload
    def walkInColumnOrder(self, fieldMatrixPreservingVisitor: FieldMatrixPreservingVisitor[_AbstractFieldMatrix__T]) -> _AbstractFieldMatrix__T: ...
    @typing.overload
    def walkInColumnOrder(self, fieldMatrixPreservingVisitor: FieldMatrixPreservingVisitor[_AbstractFieldMatrix__T], int: int, int2: int, int3: int, int4: int) -> _AbstractFieldMatrix__T: ...
    @typing.overload
    def walkInOptimizedOrder(self, fieldMatrixChangingVisitor: FieldMatrixChangingVisitor[_AbstractFieldMatrix__T]) -> _AbstractFieldMatrix__T: ...
    @typing.overload
    def walkInOptimizedOrder(self, fieldMatrixChangingVisitor: FieldMatrixChangingVisitor[_AbstractFieldMatrix__T], int: int, int2: int, int3: int, int4: int) -> _AbstractFieldMatrix__T: ...
    @typing.overload
    def walkInOptimizedOrder(self, fieldMatrixPreservingVisitor: FieldMatrixPreservingVisitor[_AbstractFieldMatrix__T]) -> _AbstractFieldMatrix__T: ...
    @typing.overload
    def walkInOptimizedOrder(self, fieldMatrixPreservingVisitor: FieldMatrixPreservingVisitor[_AbstractFieldMatrix__T], int: int, int2: int, int3: int, int4: int) -> _AbstractFieldMatrix__T: ...
    @typing.overload
    def walkInRowOrder(self, fieldMatrixChangingVisitor: FieldMatrixChangingVisitor[_AbstractFieldMatrix__T]) -> _AbstractFieldMatrix__T: ...
    @typing.overload
    def walkInRowOrder(self, fieldMatrixChangingVisitor: FieldMatrixChangingVisitor[_AbstractFieldMatrix__T], int: int, int2: int, int3: int, int4: int) -> _AbstractFieldMatrix__T: ...
    @typing.overload
    def walkInRowOrder(self, fieldMatrixPreservingVisitor: FieldMatrixPreservingVisitor[_AbstractFieldMatrix__T]) -> _AbstractFieldMatrix__T: ...
    @typing.overload
    def walkInRowOrder(self, fieldMatrixPreservingVisitor: FieldMatrixPreservingVisitor[_AbstractFieldMatrix__T], int: int, int2: int, int3: int, int4: int) -> _AbstractFieldMatrix__T: ...

class AbstractRealMatrix(RealMatrix, RealLinearOperator):
    def add(self, realMatrix: RealMatrix) -> RealMatrix: ...
    def addToEntry(self, int: int, int2: int, double: float) -> None: ...
    def copy(self) -> RealMatrix: ...
    @typing.overload
    def copySubMatrix(self, int: int, int2: int, int3: int, int4: int, doubleArray: typing.List[typing.List[float]]) -> None: ...
    @typing.overload
    def copySubMatrix(self, intArray: typing.List[int], intArray2: typing.List[int], doubleArray: typing.List[typing.List[float]]) -> None: ...
    def createMatrix(self, int: int, int2: int) -> RealMatrix: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getColumn(self, int: int) -> typing.List[float]: ...
    def getColumnDimension(self) -> int: ...
    def getColumnMatrix(self, int: int) -> RealMatrix: ...
    def getColumnVector(self, int: int) -> RealVector: ...
    def getData(self) -> typing.List[typing.List[float]]: ...
    def getEntry(self, int: int, int2: int) -> float: ...
    def getFrobeniusNorm(self) -> float: ...
    def getRow(self, int: int) -> typing.List[float]: ...
    def getRowDimension(self) -> int: ...
    def getRowMatrix(self, int: int) -> RealMatrix: ...
    def getRowVector(self, int: int) -> RealVector: ...
    @typing.overload
    def getSubMatrix(self, int: int, int2: int, int3: int, int4: int) -> RealMatrix: ...
    @typing.overload
    def getSubMatrix(self, intArray: typing.List[int], intArray2: typing.List[int]) -> RealMatrix: ...
    def getTrace(self) -> float: ...
    def hashCode(self) -> int: ...
    def isSquare(self) -> bool: ...
    def multiply(self, realMatrix: RealMatrix) -> RealMatrix: ...
    def multiplyEntry(self, int: int, int2: int, double: float) -> None: ...
    @typing.overload
    def operate(self, doubleArray: typing.List[float]) -> typing.List[float]: ...
    @typing.overload
    def operate(self, realVector: RealVector) -> RealVector: ...
    def power(self, int: int) -> RealMatrix: ...
    @typing.overload
    def preMultiply(self, doubleArray: typing.List[float]) -> typing.List[float]: ...
    @typing.overload
    def preMultiply(self, realMatrix: RealMatrix) -> RealMatrix: ...
    @typing.overload
    def preMultiply(self, realVector: RealVector) -> RealVector: ...
    def scalarAdd(self, double: float) -> RealMatrix: ...
    def scalarMultiply(self, double: float) -> RealMatrix: ...
    def setColumn(self, int: int, doubleArray: typing.List[float]) -> None: ...
    def setColumnMatrix(self, int: int, realMatrix: RealMatrix) -> None: ...
    def setColumnVector(self, int: int, realVector: RealVector) -> None: ...
    def setEntry(self, int: int, int2: int, double: float) -> None: ...
    def setRow(self, int: int, doubleArray: typing.List[float]) -> None: ...
    def setRowMatrix(self, int: int, realMatrix: RealMatrix) -> None: ...
    def setRowVector(self, int: int, realVector: RealVector) -> None: ...
    def setSubMatrix(self, doubleArray: typing.List[typing.List[float]], int: int, int2: int) -> None: ...
    def subtract(self, realMatrix: RealMatrix) -> RealMatrix: ...
    def toString(self) -> str: ...
    def transpose(self) -> RealMatrix: ...
    @typing.overload
    def walkInColumnOrder(self, realMatrixChangingVisitor: RealMatrixChangingVisitor) -> float: ...
    @typing.overload
    def walkInColumnOrder(self, realMatrixChangingVisitor: RealMatrixChangingVisitor, int: int, int2: int, int3: int, int4: int) -> float: ...
    @typing.overload
    def walkInColumnOrder(self, realMatrixPreservingVisitor: RealMatrixPreservingVisitor) -> float: ...
    @typing.overload
    def walkInColumnOrder(self, realMatrixPreservingVisitor: RealMatrixPreservingVisitor, int: int, int2: int, int3: int, int4: int) -> float: ...
    @typing.overload
    def walkInOptimizedOrder(self, realMatrixChangingVisitor: RealMatrixChangingVisitor) -> float: ...
    @typing.overload
    def walkInOptimizedOrder(self, realMatrixChangingVisitor: RealMatrixChangingVisitor, int: int, int2: int, int3: int, int4: int) -> float: ...
    @typing.overload
    def walkInOptimizedOrder(self, realMatrixPreservingVisitor: RealMatrixPreservingVisitor) -> float: ...
    @typing.overload
    def walkInOptimizedOrder(self, realMatrixPreservingVisitor: RealMatrixPreservingVisitor, int: int, int2: int, int3: int, int4: int) -> float: ...
    @typing.overload
    def walkInRowOrder(self, realMatrixChangingVisitor: RealMatrixChangingVisitor) -> float: ...
    @typing.overload
    def walkInRowOrder(self, realMatrixChangingVisitor: RealMatrixChangingVisitor, int: int, int2: int, int3: int, int4: int) -> float: ...
    @typing.overload
    def walkInRowOrder(self, realMatrixPreservingVisitor: RealMatrixPreservingVisitor) -> float: ...
    @typing.overload
    def walkInRowOrder(self, realMatrixPreservingVisitor: RealMatrixPreservingVisitor, int: int, int2: int, int3: int, int4: int) -> float: ...

class ConjugateGradient(PreconditionedIterativeLinearSolver):
    OPERATOR: typing.ClassVar[str] = ...
    VECTOR: typing.ClassVar[str] = ...
    @typing.overload
    def __init__(self, int: int, double: float, boolean: bool): ...
    @typing.overload
    def __init__(self, iterationManager: org.hipparchus.util.IterationManager, double: float, boolean: bool): ...
    def shouldCheck(self) -> bool: ...
    @typing.overload
    def solveInPlace(self, realLinearOperator: RealLinearOperator, realLinearOperator2: RealLinearOperator, realVector: RealVector, realVector2: RealVector) -> RealVector: ...
    @typing.overload
    def solveInPlace(self, realLinearOperator: RealLinearOperator, realVector: RealVector, realVector2: RealVector) -> RealVector: ...

class OpenMapRealVector(SparseRealVector, java.io.Serializable):
    DEFAULT_ZERO_TOLERANCE: typing.ClassVar[float] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, doubleArray: typing.List[float]): ...
    @typing.overload
    def __init__(self, doubleArray: typing.List[float], double2: float): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, double: float): ...
    @typing.overload
    def __init__(self, int: int, int2: int): ...
    @typing.overload
    def __init__(self, int: int, int2: int, double: float): ...
    @typing.overload
    def __init__(self, doubleArray: typing.List[float]): ...
    @typing.overload
    def __init__(self, doubleArray: typing.List[float], double2: float): ...
    @typing.overload
    def __init__(self, openMapRealVector: 'OpenMapRealVector'): ...
    @typing.overload
    def __init__(self, realVector: RealVector): ...
    @typing.overload
    def add(self, openMapRealVector: 'OpenMapRealVector') -> 'OpenMapRealVector': ...
    @typing.overload
    def add(self, realVector: RealVector) -> RealVector: ...
    @typing.overload
    def append(self, double: float) -> 'OpenMapRealVector': ...
    @typing.overload
    def append(self, openMapRealVector: 'OpenMapRealVector') -> 'OpenMapRealVector': ...
    @typing.overload
    def append(self, realVector: RealVector) -> 'OpenMapRealVector': ...
    def copy(self) -> 'OpenMapRealVector': ...
    def ebeDivide(self, realVector: RealVector) -> 'OpenMapRealVector': ...
    def ebeMultiply(self, realVector: RealVector) -> 'OpenMapRealVector': ...
    def equals(self, object: typing.Any) -> bool: ...
    def getDimension(self) -> int: ...
    @typing.overload
    def getDistance(self, openMapRealVector: 'OpenMapRealVector') -> float: ...
    @typing.overload
    def getDistance(self, realVector: RealVector) -> float: ...
    def getEntry(self, int: int) -> float: ...
    @typing.overload
    def getL1Distance(self, openMapRealVector: 'OpenMapRealVector') -> float: ...
    @typing.overload
    def getL1Distance(self, realVector: RealVector) -> float: ...
    def getLInfDistance(self, realVector: RealVector) -> float: ...
    def getSparsity(self) -> float: ...
    def getSubVector(self, int: int, int2: int) -> 'OpenMapRealVector': ...
    def hashCode(self) -> int: ...
    def isInfinite(self) -> bool: ...
    def isNaN(self) -> bool: ...
    def mapAdd(self, double: float) -> 'OpenMapRealVector': ...
    def mapAddToSelf(self, double: float) -> 'OpenMapRealVector': ...
    def set(self, double: float) -> None: ...
    def setEntry(self, int: int, double: float) -> None: ...
    def setSubVector(self, int: int, realVector: RealVector) -> None: ...
    def sparseIterator(self) -> java.util.Iterator[RealVector.Entry]: ...
    @typing.overload
    def subtract(self, openMapRealVector: 'OpenMapRealVector') -> 'OpenMapRealVector': ...
    @typing.overload
    def subtract(self, realVector: RealVector) -> RealVector: ...
    def toArray(self) -> typing.List[float]: ...
    def unitVector(self) -> 'OpenMapRealVector': ...
    def unitize(self) -> None: ...

class SparseRealMatrix(RealMatrix): ...

class SymmLQ(PreconditionedIterativeLinearSolver):
    @typing.overload
    def __init__(self, int: int, double: float, boolean: bool): ...
    @typing.overload
    def __init__(self, iterationManager: org.hipparchus.util.IterationManager, double: float, boolean: bool): ...
    def shouldCheck(self) -> bool: ...
    @typing.overload
    def solve(self, realLinearOperator: RealLinearOperator, realLinearOperator2: RealLinearOperator, realVector: RealVector) -> RealVector: ...
    @typing.overload
    def solve(self, realLinearOperator: RealLinearOperator, realLinearOperator2: RealLinearOperator, realVector: RealVector, boolean: bool, double: float) -> RealVector: ...
    @typing.overload
    def solve(self, realLinearOperator: RealLinearOperator, realLinearOperator2: RealLinearOperator, realVector: RealVector, realVector2: RealVector) -> RealVector: ...
    @typing.overload
    def solve(self, realLinearOperator: RealLinearOperator, realVector: RealVector) -> RealVector: ...
    @typing.overload
    def solve(self, realLinearOperator: RealLinearOperator, realVector: RealVector, boolean: bool, double: float) -> RealVector: ...
    @typing.overload
    def solve(self, realLinearOperator: RealLinearOperator, realVector: RealVector, realVector2: RealVector) -> RealVector: ...
    @typing.overload
    def solveInPlace(self, realLinearOperator: RealLinearOperator, realLinearOperator2: RealLinearOperator, realVector: RealVector, realVector2: RealVector) -> RealVector: ...
    @typing.overload
    def solveInPlace(self, realLinearOperator: RealLinearOperator, realLinearOperator2: RealLinearOperator, realVector: RealVector, realVector2: RealVector, boolean: bool, double: float) -> RealVector: ...
    @typing.overload
    def solveInPlace(self, realLinearOperator: RealLinearOperator, realVector: RealVector, realVector2: RealVector) -> RealVector: ...

_Array2DRowFieldMatrix__T = typing.TypeVar('_Array2DRowFieldMatrix__T', bound=org.hipparchus.FieldElement)  # <T>
class Array2DRowFieldMatrix(AbstractFieldMatrix[_Array2DRowFieldMatrix__T], java.io.Serializable, typing.Generic[_Array2DRowFieldMatrix__T]):
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_Array2DRowFieldMatrix__T]): ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_Array2DRowFieldMatrix__T], int: int, int2: int): ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_Array2DRowFieldMatrix__T], tArray: typing.List[_Array2DRowFieldMatrix__T]): ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_Array2DRowFieldMatrix__T], tArray: typing.List[typing.List[_Array2DRowFieldMatrix__T]]): ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_Array2DRowFieldMatrix__T], tArray: typing.List[typing.List[_Array2DRowFieldMatrix__T]], boolean: bool): ...
    @typing.overload
    def __init__(self, tArray: typing.List[_Array2DRowFieldMatrix__T]): ...
    @typing.overload
    def __init__(self, tArray: typing.List[typing.List[_Array2DRowFieldMatrix__T]]): ...
    @typing.overload
    def __init__(self, tArray: typing.List[typing.List[_Array2DRowFieldMatrix__T]], boolean: bool): ...
    @typing.overload
    def add(self, array2DRowFieldMatrix: 'Array2DRowFieldMatrix'[_Array2DRowFieldMatrix__T]) -> 'Array2DRowFieldMatrix'[_Array2DRowFieldMatrix__T]: ...
    @typing.overload
    def add(self, fieldMatrix: FieldMatrix[_Array2DRowFieldMatrix__T]) -> FieldMatrix[_Array2DRowFieldMatrix__T]: ...
    def addToEntry(self, int: int, int2: int, t: _Array2DRowFieldMatrix__T) -> None: ...
    def copy(self) -> FieldMatrix[_Array2DRowFieldMatrix__T]: ...
    def createMatrix(self, int: int, int2: int) -> FieldMatrix[_Array2DRowFieldMatrix__T]: ...
    def getColumnDimension(self) -> int: ...
    def getData(self) -> typing.List[typing.List[_Array2DRowFieldMatrix__T]]: ...
    def getDataRef(self) -> typing.List[typing.List[_Array2DRowFieldMatrix__T]]: ...
    def getEntry(self, int: int, int2: int) -> _Array2DRowFieldMatrix__T: ...
    def getRow(self, int: int) -> typing.List[_Array2DRowFieldMatrix__T]: ...
    def getRowDimension(self) -> int: ...
    @typing.overload
    def getSubMatrix(self, intArray: typing.List[int], intArray2: typing.List[int]) -> FieldMatrix[_Array2DRowFieldMatrix__T]: ...
    @typing.overload
    def getSubMatrix(self, int: int, int2: int, int3: int, int4: int) -> FieldMatrix[_Array2DRowFieldMatrix__T]: ...
    @typing.overload
    def multiply(self, array2DRowFieldMatrix: 'Array2DRowFieldMatrix'[_Array2DRowFieldMatrix__T]) -> 'Array2DRowFieldMatrix'[_Array2DRowFieldMatrix__T]: ...
    @typing.overload
    def multiply(self, fieldMatrix: FieldMatrix[_Array2DRowFieldMatrix__T]) -> FieldMatrix[_Array2DRowFieldMatrix__T]: ...
    def multiplyEntry(self, int: int, int2: int, t: _Array2DRowFieldMatrix__T) -> None: ...
    @typing.overload
    def multiplyTransposed(self, array2DRowFieldMatrix: 'Array2DRowFieldMatrix'[_Array2DRowFieldMatrix__T]) -> FieldMatrix[_Array2DRowFieldMatrix__T]: ...
    @typing.overload
    def multiplyTransposed(self, fieldMatrix: FieldMatrix[_Array2DRowFieldMatrix__T]) -> FieldMatrix[_Array2DRowFieldMatrix__T]: ...
    @typing.overload
    def operate(self, tArray: typing.List[_Array2DRowFieldMatrix__T]) -> typing.List[_Array2DRowFieldMatrix__T]: ...
    @typing.overload
    def operate(self, fieldVector: FieldVector[_Array2DRowFieldMatrix__T]) -> FieldVector[_Array2DRowFieldMatrix__T]: ...
    @typing.overload
    def preMultiply(self, tArray: typing.List[_Array2DRowFieldMatrix__T]) -> typing.List[_Array2DRowFieldMatrix__T]: ...
    @typing.overload
    def preMultiply(self, fieldMatrix: FieldMatrix[_Array2DRowFieldMatrix__T]) -> FieldMatrix[_Array2DRowFieldMatrix__T]: ...
    @typing.overload
    def preMultiply(self, fieldVector: FieldVector[_Array2DRowFieldMatrix__T]) -> FieldVector[_Array2DRowFieldMatrix__T]: ...
    def setEntry(self, int: int, int2: int, t: _Array2DRowFieldMatrix__T) -> None: ...
    def setRow(self, int: int, tArray: typing.List[_Array2DRowFieldMatrix__T]) -> None: ...
    def setSubMatrix(self, tArray: typing.List[typing.List[_Array2DRowFieldMatrix__T]], int: int, int2: int) -> None: ...
    @typing.overload
    def subtract(self, array2DRowFieldMatrix: 'Array2DRowFieldMatrix'[_Array2DRowFieldMatrix__T]) -> 'Array2DRowFieldMatrix'[_Array2DRowFieldMatrix__T]: ...
    @typing.overload
    def subtract(self, fieldMatrix: FieldMatrix[_Array2DRowFieldMatrix__T]) -> FieldMatrix[_Array2DRowFieldMatrix__T]: ...
    @typing.overload
    def transposeMultiply(self, array2DRowFieldMatrix: 'Array2DRowFieldMatrix'[_Array2DRowFieldMatrix__T]) -> FieldMatrix[_Array2DRowFieldMatrix__T]: ...
    @typing.overload
    def transposeMultiply(self, fieldMatrix: FieldMatrix[_Array2DRowFieldMatrix__T]) -> FieldMatrix[_Array2DRowFieldMatrix__T]: ...
    @typing.overload
    def walkInColumnOrder(self, fieldMatrixChangingVisitor: FieldMatrixChangingVisitor[_Array2DRowFieldMatrix__T]) -> _Array2DRowFieldMatrix__T: ...
    @typing.overload
    def walkInColumnOrder(self, fieldMatrixChangingVisitor: FieldMatrixChangingVisitor[_Array2DRowFieldMatrix__T], int: int, int2: int, int3: int, int4: int) -> _Array2DRowFieldMatrix__T: ...
    @typing.overload
    def walkInColumnOrder(self, fieldMatrixPreservingVisitor: FieldMatrixPreservingVisitor[_Array2DRowFieldMatrix__T]) -> _Array2DRowFieldMatrix__T: ...
    @typing.overload
    def walkInColumnOrder(self, fieldMatrixPreservingVisitor: FieldMatrixPreservingVisitor[_Array2DRowFieldMatrix__T], int: int, int2: int, int3: int, int4: int) -> _Array2DRowFieldMatrix__T: ...
    @typing.overload
    def walkInRowOrder(self, fieldMatrixChangingVisitor: FieldMatrixChangingVisitor[_Array2DRowFieldMatrix__T]) -> _Array2DRowFieldMatrix__T: ...
    @typing.overload
    def walkInRowOrder(self, fieldMatrixChangingVisitor: FieldMatrixChangingVisitor[_Array2DRowFieldMatrix__T], int: int, int2: int, int3: int, int4: int) -> _Array2DRowFieldMatrix__T: ...
    @typing.overload
    def walkInRowOrder(self, fieldMatrixPreservingVisitor: FieldMatrixPreservingVisitor[_Array2DRowFieldMatrix__T]) -> _Array2DRowFieldMatrix__T: ...
    @typing.overload
    def walkInRowOrder(self, fieldMatrixPreservingVisitor: FieldMatrixPreservingVisitor[_Array2DRowFieldMatrix__T], int: int, int2: int, int3: int, int4: int) -> _Array2DRowFieldMatrix__T: ...

class Array2DRowRealMatrix(AbstractRealMatrix, java.io.Serializable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, doubleArray: typing.List[float]): ...
    @typing.overload
    def __init__(self, doubleArray: typing.List[typing.List[float]]): ...
    @typing.overload
    def __init__(self, doubleArray: typing.List[typing.List[float]], boolean: bool): ...
    @typing.overload
    def __init__(self, int: int, int2: int): ...
    @typing.overload
    def add(self, array2DRowRealMatrix: 'Array2DRowRealMatrix') -> 'Array2DRowRealMatrix': ...
    @typing.overload
    def add(self, realMatrix: RealMatrix) -> RealMatrix: ...
    def addToEntry(self, int: int, int2: int, double: float) -> None: ...
    def copy(self) -> RealMatrix: ...
    def createMatrix(self, int: int, int2: int) -> RealMatrix: ...
    def getColumnDimension(self) -> int: ...
    def getData(self) -> typing.List[typing.List[float]]: ...
    def getDataRef(self) -> typing.List[typing.List[float]]: ...
    def getEntry(self, int: int, int2: int) -> float: ...
    def getRow(self, int: int) -> typing.List[float]: ...
    def getRowDimension(self) -> int: ...
    @typing.overload
    def getSubMatrix(self, intArray: typing.List[int], intArray2: typing.List[int]) -> RealMatrix: ...
    @typing.overload
    def getSubMatrix(self, int: int, int2: int, int3: int, int4: int) -> RealMatrix: ...
    def kroneckerProduct(self, realMatrix: RealMatrix) -> RealMatrix: ...
    @typing.overload
    def multiply(self, array2DRowRealMatrix: 'Array2DRowRealMatrix') -> 'Array2DRowRealMatrix': ...
    @typing.overload
    def multiply(self, realMatrix: RealMatrix) -> RealMatrix: ...
    def multiplyEntry(self, int: int, int2: int, double: float) -> None: ...
    @typing.overload
    def multiplyTransposed(self, array2DRowRealMatrix: 'Array2DRowRealMatrix') -> RealMatrix: ...
    @typing.overload
    def multiplyTransposed(self, realMatrix: RealMatrix) -> RealMatrix: ...
    @typing.overload
    def operate(self, doubleArray: typing.List[float]) -> typing.List[float]: ...
    @typing.overload
    def operate(self, realVector: RealVector) -> RealVector: ...
    @typing.overload
    def preMultiply(self, doubleArray: typing.List[float]) -> typing.List[float]: ...
    @typing.overload
    def preMultiply(self, realMatrix: RealMatrix) -> RealMatrix: ...
    @typing.overload
    def preMultiply(self, realVector: RealVector) -> RealVector: ...
    def setEntry(self, int: int, int2: int, double: float) -> None: ...
    def setRow(self, int: int, doubleArray: typing.List[float]) -> None: ...
    def setSubMatrix(self, doubleArray: typing.List[typing.List[float]], int: int, int2: int) -> None: ...
    def stack(self) -> RealMatrix: ...
    @typing.overload
    def subtract(self, array2DRowRealMatrix: 'Array2DRowRealMatrix') -> 'Array2DRowRealMatrix': ...
    @typing.overload
    def subtract(self, realMatrix: RealMatrix) -> RealMatrix: ...
    @typing.overload
    def transposeMultiply(self, array2DRowRealMatrix: 'Array2DRowRealMatrix') -> RealMatrix: ...
    @typing.overload
    def transposeMultiply(self, realMatrix: RealMatrix) -> RealMatrix: ...
    def unstackSquare(self) -> RealMatrix: ...
    @typing.overload
    def walkInColumnOrder(self, realMatrixChangingVisitor: RealMatrixChangingVisitor) -> float: ...
    @typing.overload
    def walkInColumnOrder(self, realMatrixChangingVisitor: RealMatrixChangingVisitor, int: int, int2: int, int3: int, int4: int) -> float: ...
    @typing.overload
    def walkInColumnOrder(self, realMatrixPreservingVisitor: RealMatrixPreservingVisitor) -> float: ...
    @typing.overload
    def walkInColumnOrder(self, realMatrixPreservingVisitor: RealMatrixPreservingVisitor, int: int, int2: int, int3: int, int4: int) -> float: ...
    @typing.overload
    def walkInRowOrder(self, realMatrixChangingVisitor: RealMatrixChangingVisitor) -> float: ...
    @typing.overload
    def walkInRowOrder(self, realMatrixChangingVisitor: RealMatrixChangingVisitor, int: int, int2: int, int3: int, int4: int) -> float: ...
    @typing.overload
    def walkInRowOrder(self, realMatrixPreservingVisitor: RealMatrixPreservingVisitor) -> float: ...
    @typing.overload
    def walkInRowOrder(self, realMatrixPreservingVisitor: RealMatrixPreservingVisitor, int: int, int2: int, int3: int, int4: int) -> float: ...

_BlockFieldMatrix__T = typing.TypeVar('_BlockFieldMatrix__T', bound=org.hipparchus.FieldElement)  # <T>
class BlockFieldMatrix(AbstractFieldMatrix[_BlockFieldMatrix__T], java.io.Serializable, typing.Generic[_BlockFieldMatrix__T]):
    BLOCK_SIZE: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self, int: int, int2: int, tArray: typing.List[typing.List[_BlockFieldMatrix__T]], boolean: bool): ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_BlockFieldMatrix__T], int: int, int2: int): ...
    @typing.overload
    def __init__(self, tArray: typing.List[typing.List[_BlockFieldMatrix__T]]): ...
    @typing.overload
    def add(self, blockFieldMatrix: 'BlockFieldMatrix'[_BlockFieldMatrix__T]) -> 'BlockFieldMatrix'[_BlockFieldMatrix__T]: ...
    @typing.overload
    def add(self, fieldMatrix: FieldMatrix[_BlockFieldMatrix__T]) -> FieldMatrix[_BlockFieldMatrix__T]: ...
    def addToEntry(self, int: int, int2: int, t: _BlockFieldMatrix__T) -> None: ...
    def copy(self) -> FieldMatrix[_BlockFieldMatrix__T]: ...
    _createBlocksLayout__T = typing.TypeVar('_createBlocksLayout__T', bound=org.hipparchus.FieldElement)  # <T>
    @staticmethod
    def createBlocksLayout(field: org.hipparchus.Field[_createBlocksLayout__T], int: int, int2: int) -> typing.List[typing.List[_createBlocksLayout__T]]: ...
    def createMatrix(self, int: int, int2: int) -> FieldMatrix[_BlockFieldMatrix__T]: ...
    def getColumn(self, int: int) -> typing.List[_BlockFieldMatrix__T]: ...
    def getColumnDimension(self) -> int: ...
    def getColumnMatrix(self, int: int) -> FieldMatrix[_BlockFieldMatrix__T]: ...
    def getColumnVector(self, int: int) -> FieldVector[_BlockFieldMatrix__T]: ...
    def getData(self) -> typing.List[typing.List[_BlockFieldMatrix__T]]: ...
    def getEntry(self, int: int, int2: int) -> _BlockFieldMatrix__T: ...
    def getRow(self, int: int) -> typing.List[_BlockFieldMatrix__T]: ...
    def getRowDimension(self) -> int: ...
    def getRowMatrix(self, int: int) -> FieldMatrix[_BlockFieldMatrix__T]: ...
    def getRowVector(self, int: int) -> FieldVector[_BlockFieldMatrix__T]: ...
    @typing.overload
    def getSubMatrix(self, intArray: typing.List[int], intArray2: typing.List[int]) -> FieldMatrix[_BlockFieldMatrix__T]: ...
    @typing.overload
    def getSubMatrix(self, int: int, int2: int, int3: int, int4: int) -> FieldMatrix[_BlockFieldMatrix__T]: ...
    @typing.overload
    def multiply(self, blockFieldMatrix: 'BlockFieldMatrix'[_BlockFieldMatrix__T]) -> 'BlockFieldMatrix'[_BlockFieldMatrix__T]: ...
    @typing.overload
    def multiply(self, fieldMatrix: FieldMatrix[_BlockFieldMatrix__T]) -> FieldMatrix[_BlockFieldMatrix__T]: ...
    def multiplyEntry(self, int: int, int2: int, t: _BlockFieldMatrix__T) -> None: ...
    @typing.overload
    def multiplyTransposed(self, blockFieldMatrix: 'BlockFieldMatrix'[_BlockFieldMatrix__T]) -> 'BlockFieldMatrix'[_BlockFieldMatrix__T]: ...
    @typing.overload
    def multiplyTransposed(self, fieldMatrix: FieldMatrix[_BlockFieldMatrix__T]) -> 'BlockFieldMatrix'[_BlockFieldMatrix__T]: ...
    @typing.overload
    def operate(self, tArray: typing.List[_BlockFieldMatrix__T]) -> typing.List[_BlockFieldMatrix__T]: ...
    @typing.overload
    def operate(self, fieldVector: FieldVector[_BlockFieldMatrix__T]) -> FieldVector[_BlockFieldMatrix__T]: ...
    @typing.overload
    def preMultiply(self, tArray: typing.List[_BlockFieldMatrix__T]) -> typing.List[_BlockFieldMatrix__T]: ...
    @typing.overload
    def preMultiply(self, fieldMatrix: FieldMatrix[_BlockFieldMatrix__T]) -> FieldMatrix[_BlockFieldMatrix__T]: ...
    @typing.overload
    def preMultiply(self, fieldVector: FieldVector[_BlockFieldMatrix__T]) -> FieldVector[_BlockFieldMatrix__T]: ...
    def scalarAdd(self, t: _BlockFieldMatrix__T) -> FieldMatrix[_BlockFieldMatrix__T]: ...
    def scalarMultiply(self, t: _BlockFieldMatrix__T) -> FieldMatrix[_BlockFieldMatrix__T]: ...
    def setColumn(self, int: int, tArray: typing.List[_BlockFieldMatrix__T]) -> None: ...
    def setColumnMatrix(self, int: int, fieldMatrix: FieldMatrix[_BlockFieldMatrix__T]) -> None: ...
    def setColumnVector(self, int: int, fieldVector: FieldVector[_BlockFieldMatrix__T]) -> None: ...
    def setEntry(self, int: int, int2: int, t: _BlockFieldMatrix__T) -> None: ...
    def setRow(self, int: int, tArray: typing.List[_BlockFieldMatrix__T]) -> None: ...
    @typing.overload
    def setRowMatrix(self, int: int, blockFieldMatrix: 'BlockFieldMatrix'[_BlockFieldMatrix__T]) -> None: ...
    @typing.overload
    def setRowMatrix(self, int: int, fieldMatrix: FieldMatrix[_BlockFieldMatrix__T]) -> None: ...
    def setRowVector(self, int: int, fieldVector: FieldVector[_BlockFieldMatrix__T]) -> None: ...
    def setSubMatrix(self, tArray: typing.List[typing.List[_BlockFieldMatrix__T]], int: int, int2: int) -> None: ...
    @typing.overload
    def subtract(self, blockFieldMatrix: 'BlockFieldMatrix'[_BlockFieldMatrix__T]) -> 'BlockFieldMatrix'[_BlockFieldMatrix__T]: ...
    @typing.overload
    def subtract(self, fieldMatrix: FieldMatrix[_BlockFieldMatrix__T]) -> FieldMatrix[_BlockFieldMatrix__T]: ...
    _toBlocksLayout__T = typing.TypeVar('_toBlocksLayout__T', bound=org.hipparchus.FieldElement)  # <T>
    @staticmethod
    def toBlocksLayout(tArray: typing.List[typing.List[_toBlocksLayout__T]]) -> typing.List[typing.List[_toBlocksLayout__T]]: ...
    def transpose(self) -> FieldMatrix[_BlockFieldMatrix__T]: ...
    @typing.overload
    def transposeMultiply(self, blockFieldMatrix: 'BlockFieldMatrix'[_BlockFieldMatrix__T]) -> 'BlockFieldMatrix'[_BlockFieldMatrix__T]: ...
    @typing.overload
    def transposeMultiply(self, fieldMatrix: FieldMatrix[_BlockFieldMatrix__T]) -> 'BlockFieldMatrix'[_BlockFieldMatrix__T]: ...
    @typing.overload
    def walkInOptimizedOrder(self, fieldMatrixChangingVisitor: FieldMatrixChangingVisitor[_BlockFieldMatrix__T]) -> _BlockFieldMatrix__T: ...
    @typing.overload
    def walkInOptimizedOrder(self, fieldMatrixChangingVisitor: FieldMatrixChangingVisitor[_BlockFieldMatrix__T], int: int, int2: int, int3: int, int4: int) -> _BlockFieldMatrix__T: ...
    @typing.overload
    def walkInOptimizedOrder(self, fieldMatrixPreservingVisitor: FieldMatrixPreservingVisitor[_BlockFieldMatrix__T]) -> _BlockFieldMatrix__T: ...
    @typing.overload
    def walkInOptimizedOrder(self, fieldMatrixPreservingVisitor: FieldMatrixPreservingVisitor[_BlockFieldMatrix__T], int: int, int2: int, int3: int, int4: int) -> _BlockFieldMatrix__T: ...
    @typing.overload
    def walkInRowOrder(self, fieldMatrixChangingVisitor: FieldMatrixChangingVisitor[_BlockFieldMatrix__T]) -> _BlockFieldMatrix__T: ...
    @typing.overload
    def walkInRowOrder(self, fieldMatrixChangingVisitor: FieldMatrixChangingVisitor[_BlockFieldMatrix__T], int: int, int2: int, int3: int, int4: int) -> _BlockFieldMatrix__T: ...
    @typing.overload
    def walkInRowOrder(self, fieldMatrixPreservingVisitor: FieldMatrixPreservingVisitor[_BlockFieldMatrix__T]) -> _BlockFieldMatrix__T: ...
    @typing.overload
    def walkInRowOrder(self, fieldMatrixPreservingVisitor: FieldMatrixPreservingVisitor[_BlockFieldMatrix__T], int: int, int2: int, int3: int, int4: int) -> _BlockFieldMatrix__T: ...

class BlockRealMatrix(AbstractRealMatrix, java.io.Serializable):
    BLOCK_SIZE: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self, doubleArray: typing.List[typing.List[float]]): ...
    @typing.overload
    def __init__(self, int: int, int2: int): ...
    @typing.overload
    def __init__(self, int: int, int2: int, doubleArray: typing.List[typing.List[float]], boolean: bool): ...
    @typing.overload
    def add(self, blockRealMatrix: 'BlockRealMatrix') -> 'BlockRealMatrix': ...
    @typing.overload
    def add(self, realMatrix: RealMatrix) -> 'BlockRealMatrix': ...
    def addToEntry(self, int: int, int2: int, double: float) -> None: ...
    def copy(self) -> 'BlockRealMatrix': ...
    @staticmethod
    def createBlocksLayout(int: int, int2: int) -> typing.List[typing.List[float]]: ...
    def createMatrix(self, int: int, int2: int) -> 'BlockRealMatrix': ...
    def getColumn(self, int: int) -> typing.List[float]: ...
    def getColumnDimension(self) -> int: ...
    def getColumnMatrix(self, int: int) -> 'BlockRealMatrix': ...
    def getColumnVector(self, int: int) -> RealVector: ...
    def getData(self) -> typing.List[typing.List[float]]: ...
    def getEntry(self, int: int, int2: int) -> float: ...
    def getFrobeniusNorm(self) -> float: ...
    def getNorm1(self) -> float: ...
    def getNormInfty(self) -> float: ...
    def getRow(self, int: int) -> typing.List[float]: ...
    def getRowDimension(self) -> int: ...
    def getRowMatrix(self, int: int) -> 'BlockRealMatrix': ...
    def getRowVector(self, int: int) -> RealVector: ...
    @typing.overload
    def getSubMatrix(self, int: int, int2: int, int3: int, int4: int) -> 'BlockRealMatrix': ...
    @typing.overload
    def getSubMatrix(self, intArray: typing.List[int], intArray2: typing.List[int]) -> RealMatrix: ...
    @typing.overload
    def multiply(self, blockRealMatrix: 'BlockRealMatrix') -> 'BlockRealMatrix': ...
    @typing.overload
    def multiply(self, realMatrix: RealMatrix) -> 'BlockRealMatrix': ...
    def multiplyEntry(self, int: int, int2: int, double: float) -> None: ...
    @typing.overload
    def multiplyTransposed(self, blockRealMatrix: 'BlockRealMatrix') -> 'BlockRealMatrix': ...
    @typing.overload
    def multiplyTransposed(self, realMatrix: RealMatrix) -> 'BlockRealMatrix': ...
    @typing.overload
    def operate(self, doubleArray: typing.List[float]) -> typing.List[float]: ...
    @typing.overload
    def operate(self, realVector: RealVector) -> RealVector: ...
    @typing.overload
    def preMultiply(self, doubleArray: typing.List[float]) -> typing.List[float]: ...
    @typing.overload
    def preMultiply(self, realMatrix: RealMatrix) -> RealMatrix: ...
    @typing.overload
    def preMultiply(self, realVector: RealVector) -> RealVector: ...
    def scalarAdd(self, double: float) -> 'BlockRealMatrix': ...
    def scalarMultiply(self, double: float) -> RealMatrix: ...
    def setColumn(self, int: int, doubleArray: typing.List[float]) -> None: ...
    def setColumnMatrix(self, int: int, realMatrix: RealMatrix) -> None: ...
    def setColumnVector(self, int: int, realVector: RealVector) -> None: ...
    def setEntry(self, int: int, int2: int, double: float) -> None: ...
    def setRow(self, int: int, doubleArray: typing.List[float]) -> None: ...
    @typing.overload
    def setRowMatrix(self, int: int, blockRealMatrix: 'BlockRealMatrix') -> None: ...
    @typing.overload
    def setRowMatrix(self, int: int, realMatrix: RealMatrix) -> None: ...
    def setRowVector(self, int: int, realVector: RealVector) -> None: ...
    def setSubMatrix(self, doubleArray: typing.List[typing.List[float]], int: int, int2: int) -> None: ...
    @typing.overload
    def subtract(self, blockRealMatrix: 'BlockRealMatrix') -> 'BlockRealMatrix': ...
    @typing.overload
    def subtract(self, realMatrix: RealMatrix) -> 'BlockRealMatrix': ...
    @staticmethod
    def toBlocksLayout(doubleArray: typing.List[typing.List[float]]) -> typing.List[typing.List[float]]: ...
    def transpose(self) -> 'BlockRealMatrix': ...
    @typing.overload
    def transposeMultiply(self, blockRealMatrix: 'BlockRealMatrix') -> 'BlockRealMatrix': ...
    @typing.overload
    def transposeMultiply(self, realMatrix: RealMatrix) -> 'BlockRealMatrix': ...
    @typing.overload
    def walkInOptimizedOrder(self, realMatrixChangingVisitor: RealMatrixChangingVisitor) -> float: ...
    @typing.overload
    def walkInOptimizedOrder(self, realMatrixChangingVisitor: RealMatrixChangingVisitor, int: int, int2: int, int3: int, int4: int) -> float: ...
    @typing.overload
    def walkInOptimizedOrder(self, realMatrixPreservingVisitor: RealMatrixPreservingVisitor) -> float: ...
    @typing.overload
    def walkInOptimizedOrder(self, realMatrixPreservingVisitor: RealMatrixPreservingVisitor, int: int, int2: int, int3: int, int4: int) -> float: ...
    @typing.overload
    def walkInRowOrder(self, realMatrixChangingVisitor: RealMatrixChangingVisitor) -> float: ...
    @typing.overload
    def walkInRowOrder(self, realMatrixChangingVisitor: RealMatrixChangingVisitor, int: int, int2: int, int3: int, int4: int) -> float: ...
    @typing.overload
    def walkInRowOrder(self, realMatrixPreservingVisitor: RealMatrixPreservingVisitor) -> float: ...
    @typing.overload
    def walkInRowOrder(self, realMatrixPreservingVisitor: RealMatrixPreservingVisitor, int: int, int2: int, int3: int, int4: int) -> float: ...

class DiagonalMatrix(AbstractRealMatrix, java.io.Serializable):
    @typing.overload
    def __init__(self, doubleArray: typing.List[float]): ...
    @typing.overload
    def __init__(self, doubleArray: typing.List[float], boolean: bool): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def add(self, diagonalMatrix: 'DiagonalMatrix') -> 'DiagonalMatrix': ...
    @typing.overload
    def add(self, realMatrix: RealMatrix) -> RealMatrix: ...
    def addToEntry(self, int: int, int2: int, double: float) -> None: ...
    def copy(self) -> RealMatrix: ...
    def createMatrix(self, int: int, int2: int) -> RealMatrix: ...
    def getColumnDimension(self) -> int: ...
    def getData(self) -> typing.List[typing.List[float]]: ...
    def getDataRef(self) -> typing.List[float]: ...
    def getEntry(self, int: int, int2: int) -> float: ...
    def getRowDimension(self) -> int: ...
    @typing.overload
    def inverse(self) -> 'DiagonalMatrix': ...
    @typing.overload
    def inverse(self, double: float) -> 'DiagonalMatrix': ...
    def isSingular(self, double: float) -> bool: ...
    @typing.overload
    def multiply(self, diagonalMatrix: 'DiagonalMatrix') -> 'DiagonalMatrix': ...
    @typing.overload
    def multiply(self, realMatrix: RealMatrix) -> RealMatrix: ...
    def multiplyEntry(self, int: int, int2: int, double: float) -> None: ...
    @typing.overload
    def multiplyTransposed(self, diagonalMatrix: 'DiagonalMatrix') -> 'DiagonalMatrix': ...
    @typing.overload
    def multiplyTransposed(self, realMatrix: RealMatrix) -> RealMatrix: ...
    @typing.overload
    def operate(self, doubleArray: typing.List[float]) -> typing.List[float]: ...
    @typing.overload
    def operate(self, realVector: RealVector) -> RealVector: ...
    @typing.overload
    def preMultiply(self, doubleArray: typing.List[float]) -> typing.List[float]: ...
    @typing.overload
    def preMultiply(self, realMatrix: RealMatrix) -> RealMatrix: ...
    @typing.overload
    def preMultiply(self, realVector: RealVector) -> RealVector: ...
    def setEntry(self, int: int, int2: int, double: float) -> None: ...
    @typing.overload
    def subtract(self, diagonalMatrix: 'DiagonalMatrix') -> 'DiagonalMatrix': ...
    @typing.overload
    def subtract(self, realMatrix: RealMatrix) -> RealMatrix: ...
    @typing.overload
    def transposeMultiply(self, diagonalMatrix: 'DiagonalMatrix') -> 'DiagonalMatrix': ...
    @typing.overload
    def transposeMultiply(self, realMatrix: RealMatrix) -> RealMatrix: ...

class OpenMapRealMatrix(AbstractRealMatrix, SparseRealMatrix, java.io.Serializable):
    @typing.overload
    def __init__(self, int: int, int2: int): ...
    @typing.overload
    def __init__(self, openMapRealMatrix: 'OpenMapRealMatrix'): ...
    @typing.overload
    def add(self, openMapRealMatrix: 'OpenMapRealMatrix') -> 'OpenMapRealMatrix': ...
    @typing.overload
    def add(self, realMatrix: RealMatrix) -> RealMatrix: ...
    def addToEntry(self, int: int, int2: int, double: float) -> None: ...
    def copy(self) -> 'OpenMapRealMatrix': ...
    def createMatrix(self, int: int, int2: int) -> 'OpenMapRealMatrix': ...
    def getColumnDimension(self) -> int: ...
    def getEntry(self, int: int, int2: int) -> float: ...
    def getRowDimension(self) -> int: ...
    @typing.overload
    def multiply(self, openMapRealMatrix: 'OpenMapRealMatrix') -> 'OpenMapRealMatrix': ...
    @typing.overload
    def multiply(self, realMatrix: RealMatrix) -> RealMatrix: ...
    def multiplyEntry(self, int: int, int2: int, double: float) -> None: ...
    def multiplyTransposed(self, realMatrix: RealMatrix) -> RealMatrix: ...
    def setEntry(self, int: int, int2: int, double: float) -> None: ...
    @typing.overload
    def subtract(self, openMapRealMatrix: 'OpenMapRealMatrix') -> 'OpenMapRealMatrix': ...
    @typing.overload
    def subtract(self, realMatrix: RealMatrix) -> 'OpenMapRealMatrix': ...
    def transposeMultiply(self, realMatrix: RealMatrix) -> RealMatrix: ...

_SparseFieldMatrix__T = typing.TypeVar('_SparseFieldMatrix__T', bound=org.hipparchus.FieldElement)  # <T>
class SparseFieldMatrix(AbstractFieldMatrix[_SparseFieldMatrix__T], typing.Generic[_SparseFieldMatrix__T]):
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_SparseFieldMatrix__T]): ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_SparseFieldMatrix__T], int: int, int2: int): ...
    @typing.overload
    def __init__(self, fieldMatrix: FieldMatrix[_SparseFieldMatrix__T]): ...
    @typing.overload
    def __init__(self, sparseFieldMatrix: 'SparseFieldMatrix'[_SparseFieldMatrix__T]): ...
    def addToEntry(self, int: int, int2: int, t: _SparseFieldMatrix__T) -> None: ...
    def copy(self) -> FieldMatrix[_SparseFieldMatrix__T]: ...
    def createMatrix(self, int: int, int2: int) -> FieldMatrix[_SparseFieldMatrix__T]: ...
    def getColumnDimension(self) -> int: ...
    def getEntry(self, int: int, int2: int) -> _SparseFieldMatrix__T: ...
    def getRowDimension(self) -> int: ...
    def multiplyEntry(self, int: int, int2: int, t: _SparseFieldMatrix__T) -> None: ...
    def multiplyTransposed(self, fieldMatrix: FieldMatrix[_SparseFieldMatrix__T]) -> FieldMatrix[_SparseFieldMatrix__T]: ...
    def setEntry(self, int: int, int2: int, t: _SparseFieldMatrix__T) -> None: ...
    def transposeMultiply(self, fieldMatrix: FieldMatrix[_SparseFieldMatrix__T]) -> FieldMatrix[_SparseFieldMatrix__T]: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.hipparchus.linear")``.

    AbstractFieldMatrix: typing.Type[AbstractFieldMatrix]
    AbstractRealMatrix: typing.Type[AbstractRealMatrix]
    AnyMatrix: typing.Type[AnyMatrix]
    Array2DRowFieldMatrix: typing.Type[Array2DRowFieldMatrix]
    Array2DRowRealMatrix: typing.Type[Array2DRowRealMatrix]
    ArrayFieldVector: typing.Type[ArrayFieldVector]
    ArrayRealVector: typing.Type[ArrayRealVector]
    BlockFieldMatrix: typing.Type[BlockFieldMatrix]
    BlockRealMatrix: typing.Type[BlockRealMatrix]
    CholeskyDecomposer: typing.Type[CholeskyDecomposer]
    CholeskyDecomposition: typing.Type[CholeskyDecomposition]
    ComplexEigenDecomposition: typing.Type[ComplexEigenDecomposition]
    ConjugateGradient: typing.Type[ConjugateGradient]
    DecompositionSolver: typing.Type[DecompositionSolver]
    DefaultFieldMatrixChangingVisitor: typing.Type[DefaultFieldMatrixChangingVisitor]
    DefaultFieldMatrixPreservingVisitor: typing.Type[DefaultFieldMatrixPreservingVisitor]
    DefaultIterativeLinearSolverEvent: typing.Type[DefaultIterativeLinearSolverEvent]
    DefaultRealMatrixChangingVisitor: typing.Type[DefaultRealMatrixChangingVisitor]
    DefaultRealMatrixPreservingVisitor: typing.Type[DefaultRealMatrixPreservingVisitor]
    DiagonalMatrix: typing.Type[DiagonalMatrix]
    EigenDecomposition: typing.Type[EigenDecomposition]
    FieldDecompositionSolver: typing.Type[FieldDecompositionSolver]
    FieldLUDecomposition: typing.Type[FieldLUDecomposition]
    FieldMatrix: typing.Type[FieldMatrix]
    FieldMatrixChangingVisitor: typing.Type[FieldMatrixChangingVisitor]
    FieldMatrixPreservingVisitor: typing.Type[FieldMatrixPreservingVisitor]
    FieldQRDecomposition: typing.Type[FieldQRDecomposition]
    FieldVector: typing.Type[FieldVector]
    FieldVectorChangingVisitor: typing.Type[FieldVectorChangingVisitor]
    FieldVectorPreservingVisitor: typing.Type[FieldVectorPreservingVisitor]
    IterativeLinearSolver: typing.Type[IterativeLinearSolver]
    IterativeLinearSolverEvent: typing.Type[IterativeLinearSolverEvent]
    JacobiPreconditioner: typing.Type[JacobiPreconditioner]
    LUDecomposer: typing.Type[LUDecomposer]
    LUDecomposition: typing.Type[LUDecomposition]
    MatrixDecomposer: typing.Type[MatrixDecomposer]
    MatrixUtils: typing.Type[MatrixUtils]
    OpenMapRealMatrix: typing.Type[OpenMapRealMatrix]
    OpenMapRealVector: typing.Type[OpenMapRealVector]
    OrderedComplexEigenDecomposition: typing.Type[OrderedComplexEigenDecomposition]
    OrderedEigenDecomposition: typing.Type[OrderedEigenDecomposition]
    PreconditionedIterativeLinearSolver: typing.Type[PreconditionedIterativeLinearSolver]
    QRDecomposer: typing.Type[QRDecomposer]
    QRDecomposition: typing.Type[QRDecomposition]
    RRQRDecomposition: typing.Type[RRQRDecomposition]
    RealLinearOperator: typing.Type[RealLinearOperator]
    RealMatrix: typing.Type[RealMatrix]
    RealMatrixChangingVisitor: typing.Type[RealMatrixChangingVisitor]
    RealMatrixFormat: typing.Type[RealMatrixFormat]
    RealMatrixPreservingVisitor: typing.Type[RealMatrixPreservingVisitor]
    RealVector: typing.Type[RealVector]
    RealVectorChangingVisitor: typing.Type[RealVectorChangingVisitor]
    RealVectorFormat: typing.Type[RealVectorFormat]
    RealVectorPreservingVisitor: typing.Type[RealVectorPreservingVisitor]
    RectangularCholeskyDecomposition: typing.Type[RectangularCholeskyDecomposition]
    RiccatiEquationSolver: typing.Type[RiccatiEquationSolver]
    RiccatiEquationSolverImpl: typing.Type[RiccatiEquationSolverImpl]
    SingularValueDecomposer: typing.Type[SingularValueDecomposer]
    SingularValueDecomposition: typing.Type[SingularValueDecomposition]
    SparseFieldMatrix: typing.Type[SparseFieldMatrix]
    SparseFieldVector: typing.Type[SparseFieldVector]
    SparseRealMatrix: typing.Type[SparseRealMatrix]
    SparseRealVector: typing.Type[SparseRealVector]
    SymmLQ: typing.Type[SymmLQ]
