import java.io
import java.lang
import java.text
import java.util
import org.hipparchus
import org.hipparchus.analysis
import org.hipparchus.analysis.integration
import org.hipparchus.util
import typing



class Complex(org.hipparchus.CalculusFieldElement['Complex'], java.io.Serializable):
    I: typing.ClassVar['Complex'] = ...
    MINUS_I: typing.ClassVar['Complex'] = ...
    NaN: typing.ClassVar['Complex'] = ...
    INF: typing.ClassVar['Complex'] = ...
    ONE: typing.ClassVar['Complex'] = ...
    MINUS_ONE: typing.ClassVar['Complex'] = ...
    ZERO: typing.ClassVar['Complex'] = ...
    PI: typing.ClassVar['Complex'] = ...
    @typing.overload
    def __init__(self, double: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float): ...
    def abs(self) -> 'Complex': ...
    def acos(self) -> 'Complex': ...
    def acosh(self) -> 'Complex': ...
    @typing.overload
    def add(self, double: float) -> 'Complex': ...
    @typing.overload
    def add(self, complex: 'Complex') -> 'Complex': ...
    def asin(self) -> 'Complex': ...
    def asinh(self) -> 'Complex': ...
    def atan(self) -> 'Complex': ...
    def atan2(self, complex: 'Complex') -> 'Complex': ...
    def atanh(self) -> 'Complex': ...
    def cbrt(self) -> 'Complex': ...
    def ceil(self) -> 'Complex': ...
    def conjugate(self) -> 'Complex': ...
    @typing.overload
    def copySign(self, double: float) -> 'Complex': ...
    @typing.overload
    def copySign(self, complex: 'Complex') -> 'Complex': ...
    def cos(self) -> 'Complex': ...
    def cosh(self) -> 'Complex': ...
    @typing.overload
    def divide(self, double: float) -> 'Complex': ...
    @typing.overload
    def divide(self, complex: 'Complex') -> 'Complex': ...
    @typing.overload
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(complex: 'Complex', complex2: 'Complex') -> bool: ...
    @typing.overload
    @staticmethod
    def equals(complex: 'Complex', complex2: 'Complex', double: float) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(complex: 'Complex', complex2: 'Complex', int: int) -> bool: ...
    @staticmethod
    def equalsWithRelativeTolerance(complex: 'Complex', complex2: 'Complex', double: float) -> bool: ...
    def exp(self) -> 'Complex': ...
    def expm1(self) -> 'Complex': ...
    def floor(self) -> 'Complex': ...
    def getArgument(self) -> float: ...
    def getField(self) -> 'ComplexField': ...
    def getImaginary(self) -> float: ...
    def getImaginaryPart(self) -> float: ...
    def getPi(self) -> 'Complex': ...
    def getReal(self) -> float: ...
    def getRealPart(self) -> float: ...
    def hashCode(self) -> int: ...
    def hypot(self, complex: 'Complex') -> 'Complex': ...
    def isInfinite(self) -> bool: ...
    def isMathematicalInteger(self) -> bool: ...
    def isNaN(self) -> bool: ...
    def isReal(self) -> bool: ...
    def isZero(self) -> bool: ...
    @typing.overload
    def linearCombination(self, double: float, complex: 'Complex', double2: float, complex2: 'Complex') -> 'Complex': ...
    @typing.overload
    def linearCombination(self, double: float, complex: 'Complex', double2: float, complex2: 'Complex', double3: float, complex3: 'Complex') -> 'Complex': ...
    @typing.overload
    def linearCombination(self, double: float, complex: 'Complex', double2: float, complex2: 'Complex', double3: float, complex3: 'Complex', double4: float, complex4: 'Complex') -> 'Complex': ...
    @typing.overload
    def linearCombination(self, doubleArray: typing.List[float], complexArray: typing.List['Complex']) -> 'Complex': ...
    @typing.overload
    def linearCombination(self, complex: 'Complex', complex2: 'Complex', complex3: 'Complex', complex4: 'Complex') -> 'Complex': ...
    @typing.overload
    def linearCombination(self, complex: 'Complex', complex2: 'Complex', complex3: 'Complex', complex4: 'Complex', complex5: 'Complex', complex6: 'Complex') -> 'Complex': ...
    @typing.overload
    def linearCombination(self, complex: 'Complex', complex2: 'Complex', complex3: 'Complex', complex4: 'Complex', complex5: 'Complex', complex6: 'Complex', complex7: 'Complex', complex8: 'Complex') -> 'Complex': ...
    @typing.overload
    def linearCombination(self, complexArray: typing.List['Complex'], complexArray2: typing.List['Complex']) -> 'Complex': ...
    def log(self) -> 'Complex': ...
    def log10(self) -> 'Complex': ...
    def log1p(self) -> 'Complex': ...
    @typing.overload
    def multiply(self, double: float) -> 'Complex': ...
    @typing.overload
    def multiply(self, int: int) -> 'Complex': ...
    @typing.overload
    def multiply(self, complex: 'Complex') -> 'Complex': ...
    def multiplyMinusI(self) -> 'Complex': ...
    def multiplyPlusI(self) -> 'Complex': ...
    def negate(self) -> 'Complex': ...
    def newInstance(self, double: float) -> 'Complex': ...
    def nthRoot(self, int: int) -> java.util.List['Complex']: ...
    @typing.overload
    def pow(self, double: float) -> 'Complex': ...
    @typing.overload
    def pow(self, int: int) -> 'Complex': ...
    @typing.overload
    def pow(self, complex: 'Complex') -> 'Complex': ...
    def reciprocal(self) -> 'Complex': ...
    @typing.overload
    def remainder(self, double: float) -> 'Complex': ...
    @typing.overload
    def remainder(self, complex: 'Complex') -> 'Complex': ...
    def rint(self) -> 'Complex': ...
    def rootN(self, int: int) -> 'Complex': ...
    def scalb(self, int: int) -> 'Complex': ...
    def sign(self) -> 'Complex': ...
    def sin(self) -> 'Complex': ...
    def sinCos(self) -> org.hipparchus.util.FieldSinCos['Complex']: ...
    def sinh(self) -> 'Complex': ...
    def sinhCosh(self) -> org.hipparchus.util.FieldSinhCosh['Complex']: ...
    def sqrt(self) -> 'Complex': ...
    def sqrt1z(self) -> 'Complex': ...
    @typing.overload
    def subtract(self, double: float) -> 'Complex': ...
    @typing.overload
    def subtract(self, complex: 'Complex') -> 'Complex': ...
    def tan(self) -> 'Complex': ...
    def tanh(self) -> 'Complex': ...
    def toDegrees(self) -> 'Complex': ...
    def toRadians(self) -> 'Complex': ...
    def toString(self) -> str: ...
    def ulp(self) -> 'Complex': ...
    @typing.overload
    @staticmethod
    def valueOf(double: float) -> 'Complex': ...
    @typing.overload
    @staticmethod
    def valueOf(double: float, double2: float) -> 'Complex': ...

class ComplexComparator(java.util.Comparator[Complex], java.io.Serializable):
    def __init__(self): ...
    def compare(self, complex: Complex, complex2: Complex) -> int: ...

class ComplexField(org.hipparchus.Field[Complex], java.io.Serializable):
    def equals(self, object: typing.Any) -> bool: ...
    @staticmethod
    def getInstance() -> 'ComplexField': ...
    def getOne(self) -> Complex: ...
    def getRuntimeClass(self) -> typing.Type[Complex]: ...
    def getZero(self) -> Complex: ...
    def hashCode(self) -> int: ...

class ComplexFormat:
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, numberFormat: java.text.NumberFormat): ...
    @typing.overload
    def __init__(self, string: str, numberFormat: java.text.NumberFormat, numberFormat2: java.text.NumberFormat): ...
    @typing.overload
    def __init__(self, numberFormat: java.text.NumberFormat): ...
    @typing.overload
    def __init__(self, numberFormat: java.text.NumberFormat, numberFormat2: java.text.NumberFormat): ...
    @typing.overload
    def format(self, double: float) -> str: ...
    @typing.overload
    def format(self, complex: Complex) -> str: ...
    @typing.overload
    def format(self, object: typing.Any, stringBuffer: java.lang.StringBuffer, fieldPosition: java.text.FieldPosition) -> java.lang.StringBuffer: ...
    @typing.overload
    def format(self, complex: Complex, stringBuffer: java.lang.StringBuffer, fieldPosition: java.text.FieldPosition) -> java.lang.StringBuffer: ...
    @staticmethod
    def getAvailableLocales() -> typing.List[java.util.Locale]: ...
    @typing.overload
    @staticmethod
    def getComplexFormat() -> 'ComplexFormat': ...
    @typing.overload
    @staticmethod
    def getComplexFormat(string: str, locale: java.util.Locale) -> 'ComplexFormat': ...
    @typing.overload
    @staticmethod
    def getComplexFormat(locale: java.util.Locale) -> 'ComplexFormat': ...
    def getImaginaryCharacter(self) -> str: ...
    def getImaginaryFormat(self) -> java.text.NumberFormat: ...
    def getRealFormat(self) -> java.text.NumberFormat: ...
    @typing.overload
    def parse(self, string: str) -> Complex: ...
    @typing.overload
    def parse(self, string: str, parsePosition: java.text.ParsePosition) -> Complex: ...

class ComplexUnivariateIntegrator:
    def __init__(self, univariateIntegrator: org.hipparchus.analysis.integration.UnivariateIntegrator): ...
    @typing.overload
    def integrate(self, int: int, calculusFieldUnivariateFunction: org.hipparchus.analysis.CalculusFieldUnivariateFunction[Complex], complex: Complex, complex2: Complex) -> Complex: ...
    @typing.overload
    def integrate(self, int: int, calculusFieldUnivariateFunction: org.hipparchus.analysis.CalculusFieldUnivariateFunction[Complex], complex: Complex, complexArray: typing.List[Complex]) -> Complex: ...

class ComplexUtils:
    @staticmethod
    def convertToComplex(doubleArray: typing.List[float]) -> typing.List[Complex]: ...
    _polar2Complex_1__T = typing.TypeVar('_polar2Complex_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def polar2Complex(double: float, double2: float) -> Complex: ...
    @typing.overload
    @staticmethod
    def polar2Complex(t: _polar2Complex_1__T, t2: _polar2Complex_1__T) -> 'FieldComplex'[_polar2Complex_1__T]: ...

_FieldComplex__T = typing.TypeVar('_FieldComplex__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
class FieldComplex(org.hipparchus.CalculusFieldElement['FieldComplex'[_FieldComplex__T]], typing.Generic[_FieldComplex__T]):
    @typing.overload
    def __init__(self, t: _FieldComplex__T): ...
    @typing.overload
    def __init__(self, t: _FieldComplex__T, t2: _FieldComplex__T): ...
    def abs(self) -> 'FieldComplex'[_FieldComplex__T]: ...
    def acos(self) -> 'FieldComplex'[_FieldComplex__T]: ...
    def acosh(self) -> 'FieldComplex'[_FieldComplex__T]: ...
    @typing.overload
    def add(self, double: float) -> 'FieldComplex'[_FieldComplex__T]: ...
    @typing.overload
    def add(self, t: _FieldComplex__T) -> 'FieldComplex'[_FieldComplex__T]: ...
    @typing.overload
    def add(self, fieldComplex: 'FieldComplex'[_FieldComplex__T]) -> 'FieldComplex'[_FieldComplex__T]: ...
    def asin(self) -> 'FieldComplex'[_FieldComplex__T]: ...
    def asinh(self) -> 'FieldComplex'[_FieldComplex__T]: ...
    def atan(self) -> 'FieldComplex'[_FieldComplex__T]: ...
    def atan2(self, fieldComplex: 'FieldComplex'[_FieldComplex__T]) -> 'FieldComplex'[_FieldComplex__T]: ...
    def atanh(self) -> 'FieldComplex'[_FieldComplex__T]: ...
    def cbrt(self) -> 'FieldComplex'[_FieldComplex__T]: ...
    def ceil(self) -> 'FieldComplex'[_FieldComplex__T]: ...
    def conjugate(self) -> 'FieldComplex'[_FieldComplex__T]: ...
    @typing.overload
    def copySign(self, double: float) -> 'FieldComplex'[_FieldComplex__T]: ...
    @typing.overload
    def copySign(self, fieldComplex: 'FieldComplex'[_FieldComplex__T]) -> 'FieldComplex'[_FieldComplex__T]: ...
    def cos(self) -> 'FieldComplex'[_FieldComplex__T]: ...
    def cosh(self) -> 'FieldComplex'[_FieldComplex__T]: ...
    @typing.overload
    def divide(self, double: float) -> 'FieldComplex'[_FieldComplex__T]: ...
    @typing.overload
    def divide(self, t: _FieldComplex__T) -> 'FieldComplex'[_FieldComplex__T]: ...
    @typing.overload
    def divide(self, fieldComplex: 'FieldComplex'[_FieldComplex__T]) -> 'FieldComplex'[_FieldComplex__T]: ...
    _equals_1__T = typing.TypeVar('_equals_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _equals_2__T = typing.TypeVar('_equals_2__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _equals_3__T = typing.TypeVar('_equals_3__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(fieldComplex: 'FieldComplex'[_equals_1__T], fieldComplex2: 'FieldComplex'[_equals_1__T]) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(fieldComplex: 'FieldComplex'[_equals_2__T], fieldComplex2: 'FieldComplex'[_equals_2__T], double: float) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(fieldComplex: 'FieldComplex'[_equals_3__T], fieldComplex2: 'FieldComplex'[_equals_3__T], int: int) -> bool: ...
    _equalsWithRelativeTolerance__T = typing.TypeVar('_equalsWithRelativeTolerance__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @staticmethod
    def equalsWithRelativeTolerance(fieldComplex: 'FieldComplex'[_equalsWithRelativeTolerance__T], fieldComplex2: 'FieldComplex'[_equalsWithRelativeTolerance__T], double: float) -> bool: ...
    def exp(self) -> 'FieldComplex'[_FieldComplex__T]: ...
    def expm1(self) -> 'FieldComplex'[_FieldComplex__T]: ...
    def floor(self) -> 'FieldComplex'[_FieldComplex__T]: ...
    def getArgument(self) -> _FieldComplex__T: ...
    def getField(self) -> 'FieldComplexField'[_FieldComplex__T]: ...
    _getI__T = typing.TypeVar('_getI__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @staticmethod
    def getI(field: org.hipparchus.Field[_getI__T]) -> 'FieldComplex'[_getI__T]: ...
    def getImaginary(self) -> _FieldComplex__T: ...
    def getImaginaryPart(self) -> _FieldComplex__T: ...
    _getInf__T = typing.TypeVar('_getInf__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @staticmethod
    def getInf(field: org.hipparchus.Field[_getInf__T]) -> 'FieldComplex'[_getInf__T]: ...
    _getMinusI__T = typing.TypeVar('_getMinusI__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @staticmethod
    def getMinusI(field: org.hipparchus.Field[_getMinusI__T]) -> 'FieldComplex'[_getMinusI__T]: ...
    _getMinusOne__T = typing.TypeVar('_getMinusOne__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @staticmethod
    def getMinusOne(field: org.hipparchus.Field[_getMinusOne__T]) -> 'FieldComplex'[_getMinusOne__T]: ...
    _getNaN__T = typing.TypeVar('_getNaN__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @staticmethod
    def getNaN(field: org.hipparchus.Field[_getNaN__T]) -> 'FieldComplex'[_getNaN__T]: ...
    _getOne__T = typing.TypeVar('_getOne__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @staticmethod
    def getOne(field: org.hipparchus.Field[_getOne__T]) -> 'FieldComplex'[_getOne__T]: ...
    def getPartsField(self) -> org.hipparchus.Field[_FieldComplex__T]: ...
    _getPi_1__T = typing.TypeVar('_getPi_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def getPi(self) -> 'FieldComplex'[_FieldComplex__T]: ...
    @typing.overload
    @staticmethod
    def getPi(field: org.hipparchus.Field[_getPi_1__T]) -> 'FieldComplex'[_getPi_1__T]: ...
    def getReal(self) -> float: ...
    def getRealPart(self) -> _FieldComplex__T: ...
    _getZero__T = typing.TypeVar('_getZero__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @staticmethod
    def getZero(field: org.hipparchus.Field[_getZero__T]) -> 'FieldComplex'[_getZero__T]: ...
    def hashCode(self) -> int: ...
    def hypot(self, fieldComplex: 'FieldComplex'[_FieldComplex__T]) -> 'FieldComplex'[_FieldComplex__T]: ...
    def isInfinite(self) -> bool: ...
    def isMathematicalInteger(self) -> bool: ...
    def isNaN(self) -> bool: ...
    def isReal(self) -> bool: ...
    def isZero(self) -> bool: ...
    @typing.overload
    def linearCombination(self, double: float, fieldComplex: 'FieldComplex'[_FieldComplex__T], double2: float, fieldComplex2: 'FieldComplex'[_FieldComplex__T]) -> 'FieldComplex'[_FieldComplex__T]: ...
    @typing.overload
    def linearCombination(self, double: float, fieldComplex: 'FieldComplex'[_FieldComplex__T], double2: float, fieldComplex2: 'FieldComplex'[_FieldComplex__T], double3: float, fieldComplex3: 'FieldComplex'[_FieldComplex__T]) -> 'FieldComplex'[_FieldComplex__T]: ...
    @typing.overload
    def linearCombination(self, double: float, fieldComplex: 'FieldComplex'[_FieldComplex__T], double2: float, fieldComplex2: 'FieldComplex'[_FieldComplex__T], double3: float, fieldComplex3: 'FieldComplex'[_FieldComplex__T], double4: float, fieldComplex4: 'FieldComplex'[_FieldComplex__T]) -> 'FieldComplex'[_FieldComplex__T]: ...
    @typing.overload
    def linearCombination(self, doubleArray: typing.List[float], fieldComplexArray: typing.List['FieldComplex'[_FieldComplex__T]]) -> 'FieldComplex'[_FieldComplex__T]: ...
    @typing.overload
    def linearCombination(self, fieldComplex: 'FieldComplex'[_FieldComplex__T], fieldComplex2: 'FieldComplex'[_FieldComplex__T], fieldComplex3: 'FieldComplex'[_FieldComplex__T], fieldComplex4: 'FieldComplex'[_FieldComplex__T]) -> 'FieldComplex'[_FieldComplex__T]: ...
    @typing.overload
    def linearCombination(self, fieldComplex: 'FieldComplex'[_FieldComplex__T], fieldComplex2: 'FieldComplex'[_FieldComplex__T], fieldComplex3: 'FieldComplex'[_FieldComplex__T], fieldComplex4: 'FieldComplex'[_FieldComplex__T], fieldComplex5: 'FieldComplex'[_FieldComplex__T], fieldComplex6: 'FieldComplex'[_FieldComplex__T]) -> 'FieldComplex'[_FieldComplex__T]: ...
    @typing.overload
    def linearCombination(self, fieldComplex: 'FieldComplex'[_FieldComplex__T], fieldComplex2: 'FieldComplex'[_FieldComplex__T], fieldComplex3: 'FieldComplex'[_FieldComplex__T], fieldComplex4: 'FieldComplex'[_FieldComplex__T], fieldComplex5: 'FieldComplex'[_FieldComplex__T], fieldComplex6: 'FieldComplex'[_FieldComplex__T], fieldComplex7: 'FieldComplex'[_FieldComplex__T], fieldComplex8: 'FieldComplex'[_FieldComplex__T]) -> 'FieldComplex'[_FieldComplex__T]: ...
    @typing.overload
    def linearCombination(self, fieldComplexArray: typing.List['FieldComplex'[_FieldComplex__T]], fieldComplexArray2: typing.List['FieldComplex'[_FieldComplex__T]]) -> 'FieldComplex'[_FieldComplex__T]: ...
    def log(self) -> 'FieldComplex'[_FieldComplex__T]: ...
    def log10(self) -> 'FieldComplex'[_FieldComplex__T]: ...
    def log1p(self) -> 'FieldComplex'[_FieldComplex__T]: ...
    @typing.overload
    def multiply(self, double: float) -> 'FieldComplex'[_FieldComplex__T]: ...
    @typing.overload
    def multiply(self, int: int) -> 'FieldComplex'[_FieldComplex__T]: ...
    @typing.overload
    def multiply(self, t: _FieldComplex__T) -> 'FieldComplex'[_FieldComplex__T]: ...
    @typing.overload
    def multiply(self, fieldComplex: 'FieldComplex'[_FieldComplex__T]) -> 'FieldComplex'[_FieldComplex__T]: ...
    def multiplyMinusI(self) -> 'FieldComplex'[_FieldComplex__T]: ...
    def multiplyPlusI(self) -> 'FieldComplex'[_FieldComplex__T]: ...
    def negate(self) -> 'FieldComplex'[_FieldComplex__T]: ...
    def newInstance(self, double: float) -> 'FieldComplex'[_FieldComplex__T]: ...
    def nthRoot(self, int: int) -> java.util.List['FieldComplex'[_FieldComplex__T]]: ...
    @typing.overload
    def pow(self, double: float) -> 'FieldComplex'[_FieldComplex__T]: ...
    @typing.overload
    def pow(self, int: int) -> 'FieldComplex'[_FieldComplex__T]: ...
    @typing.overload
    def pow(self, t: _FieldComplex__T) -> 'FieldComplex'[_FieldComplex__T]: ...
    @typing.overload
    def pow(self, fieldComplex: 'FieldComplex'[_FieldComplex__T]) -> 'FieldComplex'[_FieldComplex__T]: ...
    def reciprocal(self) -> 'FieldComplex'[_FieldComplex__T]: ...
    @typing.overload
    def remainder(self, double: float) -> 'FieldComplex'[_FieldComplex__T]: ...
    @typing.overload
    def remainder(self, fieldComplex: 'FieldComplex'[_FieldComplex__T]) -> 'FieldComplex'[_FieldComplex__T]: ...
    def rint(self) -> 'FieldComplex'[_FieldComplex__T]: ...
    def rootN(self, int: int) -> 'FieldComplex'[_FieldComplex__T]: ...
    def scalb(self, int: int) -> 'FieldComplex'[_FieldComplex__T]: ...
    def sign(self) -> 'FieldComplex'[_FieldComplex__T]: ...
    def sin(self) -> 'FieldComplex'[_FieldComplex__T]: ...
    def sinCos(self) -> org.hipparchus.util.FieldSinCos['FieldComplex'[_FieldComplex__T]]: ...
    def sinh(self) -> 'FieldComplex'[_FieldComplex__T]: ...
    def sinhCosh(self) -> org.hipparchus.util.FieldSinhCosh['FieldComplex'[_FieldComplex__T]]: ...
    def sqrt(self) -> 'FieldComplex'[_FieldComplex__T]: ...
    def sqrt1z(self) -> 'FieldComplex'[_FieldComplex__T]: ...
    @typing.overload
    def subtract(self, double: float) -> 'FieldComplex'[_FieldComplex__T]: ...
    @typing.overload
    def subtract(self, t: _FieldComplex__T) -> 'FieldComplex'[_FieldComplex__T]: ...
    @typing.overload
    def subtract(self, fieldComplex: 'FieldComplex'[_FieldComplex__T]) -> 'FieldComplex'[_FieldComplex__T]: ...
    def tan(self) -> 'FieldComplex'[_FieldComplex__T]: ...
    def tanh(self) -> 'FieldComplex'[_FieldComplex__T]: ...
    def toDegrees(self) -> 'FieldComplex'[_FieldComplex__T]: ...
    def toRadians(self) -> 'FieldComplex'[_FieldComplex__T]: ...
    def toString(self) -> str: ...
    def ulp(self) -> 'FieldComplex'[_FieldComplex__T]: ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _valueOf_1__T = typing.TypeVar('_valueOf_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(t: _valueOf_0__T) -> 'FieldComplex'[_valueOf_0__T]: ...
    @typing.overload
    @staticmethod
    def valueOf(t: _valueOf_1__T, t2: _valueOf_1__T) -> 'FieldComplex'[_valueOf_1__T]: ...

_FieldComplexField__T = typing.TypeVar('_FieldComplexField__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
class FieldComplexField(org.hipparchus.Field[FieldComplex[_FieldComplexField__T]], typing.Generic[_FieldComplexField__T]):
    def equals(self, object: typing.Any) -> bool: ...
    _getField__T = typing.TypeVar('_getField__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @staticmethod
    def getField(field: org.hipparchus.Field[_getField__T]) -> 'FieldComplexField'[_getField__T]: ...
    def getOne(self) -> FieldComplex[_FieldComplexField__T]: ...
    def getRuntimeClass(self) -> typing.Type[FieldComplex[_FieldComplexField__T]]: ...
    def getZero(self) -> FieldComplex[_FieldComplexField__T]: ...
    def hashCode(self) -> int: ...

_FieldComplexUnivariateIntegrator__T = typing.TypeVar('_FieldComplexUnivariateIntegrator__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
class FieldComplexUnivariateIntegrator(typing.Generic[_FieldComplexUnivariateIntegrator__T]):
    def __init__(self, fieldUnivariateIntegrator: org.hipparchus.analysis.integration.FieldUnivariateIntegrator[_FieldComplexUnivariateIntegrator__T]): ...
    @typing.overload
    def integrate(self, int: int, calculusFieldUnivariateFunction: org.hipparchus.analysis.CalculusFieldUnivariateFunction[FieldComplex[_FieldComplexUnivariateIntegrator__T]], fieldComplex: FieldComplex[_FieldComplexUnivariateIntegrator__T], fieldComplex2: FieldComplex[_FieldComplexUnivariateIntegrator__T]) -> FieldComplex[_FieldComplexUnivariateIntegrator__T]: ...
    @typing.overload
    def integrate(self, int: int, calculusFieldUnivariateFunction: org.hipparchus.analysis.CalculusFieldUnivariateFunction[FieldComplex[_FieldComplexUnivariateIntegrator__T]], fieldComplex: FieldComplex[_FieldComplexUnivariateIntegrator__T], fieldComplexArray: typing.List[FieldComplex[_FieldComplexUnivariateIntegrator__T]]) -> FieldComplex[_FieldComplexUnivariateIntegrator__T]: ...

class Quaternion(java.io.Serializable):
    IDENTITY: typing.ClassVar['Quaternion'] = ...
    ZERO: typing.ClassVar['Quaternion'] = ...
    I: typing.ClassVar['Quaternion'] = ...
    J: typing.ClassVar['Quaternion'] = ...
    K: typing.ClassVar['Quaternion'] = ...
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float, double4: float): ...
    @typing.overload
    def __init__(self, double: float, doubleArray: typing.List[float]): ...
    @typing.overload
    def __init__(self, doubleArray: typing.List[float]): ...
    @typing.overload
    def add(self, quaternion: 'Quaternion') -> 'Quaternion': ...
    @typing.overload
    @staticmethod
    def add(quaternion: 'Quaternion', quaternion2: 'Quaternion') -> 'Quaternion': ...
    @typing.overload
    def dotProduct(self, quaternion: 'Quaternion') -> float: ...
    @typing.overload
    @staticmethod
    def dotProduct(quaternion: 'Quaternion', quaternion2: 'Quaternion') -> float: ...
    @typing.overload
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    def equals(self, quaternion: 'Quaternion', double: float) -> bool: ...
    def getConjugate(self) -> 'Quaternion': ...
    def getInverse(self) -> 'Quaternion': ...
    def getNorm(self) -> float: ...
    def getPositivePolarForm(self) -> 'Quaternion': ...
    def getQ0(self) -> float: ...
    def getQ1(self) -> float: ...
    def getQ2(self) -> float: ...
    def getQ3(self) -> float: ...
    def getScalarPart(self) -> float: ...
    def getVectorPart(self) -> typing.List[float]: ...
    def hashCode(self) -> int: ...
    def isPureQuaternion(self, double: float) -> bool: ...
    def isUnitQuaternion(self, double: float) -> bool: ...
    @typing.overload
    def multiply(self, double: float) -> 'Quaternion': ...
    @typing.overload
    def multiply(self, quaternion: 'Quaternion') -> 'Quaternion': ...
    @typing.overload
    @staticmethod
    def multiply(quaternion: 'Quaternion', quaternion2: 'Quaternion') -> 'Quaternion': ...
    def normalize(self) -> 'Quaternion': ...
    @typing.overload
    def subtract(self, quaternion: 'Quaternion') -> 'Quaternion': ...
    @typing.overload
    @staticmethod
    def subtract(quaternion: 'Quaternion', quaternion2: 'Quaternion') -> 'Quaternion': ...
    def toString(self) -> str: ...

class RootsOfUnity(java.io.Serializable):
    def __init__(self): ...
    def computeRoots(self, int: int) -> None: ...
    def getImaginary(self, int: int) -> float: ...
    def getNumberOfRoots(self) -> int: ...
    def getReal(self, int: int) -> float: ...
    def isCounterClockWise(self) -> bool: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.hipparchus.complex")``.

    Complex: typing.Type[Complex]
    ComplexComparator: typing.Type[ComplexComparator]
    ComplexField: typing.Type[ComplexField]
    ComplexFormat: typing.Type[ComplexFormat]
    ComplexUnivariateIntegrator: typing.Type[ComplexUnivariateIntegrator]
    ComplexUtils: typing.Type[ComplexUtils]
    FieldComplex: typing.Type[FieldComplex]
    FieldComplexField: typing.Type[FieldComplexField]
    FieldComplexUnivariateIntegrator: typing.Type[FieldComplexUnivariateIntegrator]
    Quaternion: typing.Type[Quaternion]
    RootsOfUnity: typing.Type[RootsOfUnity]
