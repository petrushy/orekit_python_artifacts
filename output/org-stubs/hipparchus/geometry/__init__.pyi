import java.io
import java.lang
import java.text
import java.util
import org.hipparchus.exception
import org.hipparchus.geometry.enclosing
import org.hipparchus.geometry.euclidean
import org.hipparchus.geometry.hull
import org.hipparchus.geometry.partitioning
import org.hipparchus.geometry.spherical
import typing



class LocalizedGeometryFormats(java.lang.Enum['LocalizedGeometryFormats'], org.hipparchus.exception.Localizable):
    CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR: typing.ClassVar['LocalizedGeometryFormats'] = ...
    CARDAN_ANGLES_SINGULARITY: typing.ClassVar['LocalizedGeometryFormats'] = ...
    CLOSE_VERTICES: typing.ClassVar['LocalizedGeometryFormats'] = ...
    CLOSEST_ORTHOGONAL_MATRIX_HAS_NEGATIVE_DETERMINANT: typing.ClassVar['LocalizedGeometryFormats'] = ...
    CROSSING_BOUNDARY_LOOPS: typing.ClassVar['LocalizedGeometryFormats'] = ...
    EDGE_CONNECTED_TO_ONE_FACET: typing.ClassVar['LocalizedGeometryFormats'] = ...
    EULER_ANGLES_SINGULARITY: typing.ClassVar['LocalizedGeometryFormats'] = ...
    FACET_ORIENTATION_MISMATCH: typing.ClassVar['LocalizedGeometryFormats'] = ...
    INCONSISTENT_STATE_AT_2_PI_WRAPPING: typing.ClassVar['LocalizedGeometryFormats'] = ...
    NON_INVERTIBLE_TRANSFORM: typing.ClassVar['LocalizedGeometryFormats'] = ...
    NOT_CONVEX: typing.ClassVar['LocalizedGeometryFormats'] = ...
    NOT_CONVEX_HYPERPLANES: typing.ClassVar['LocalizedGeometryFormats'] = ...
    NOT_SUPPORTED_IN_DIMENSION_N: typing.ClassVar['LocalizedGeometryFormats'] = ...
    OUTLINE_BOUNDARY_LOOP_OPEN: typing.ClassVar['LocalizedGeometryFormats'] = ...
    FACET_WITH_SEVERAL_BOUNDARY_LOOPS: typing.ClassVar['LocalizedGeometryFormats'] = ...
    OUT_OF_PLANE: typing.ClassVar['LocalizedGeometryFormats'] = ...
    ROTATION_MATRIX_DIMENSIONS: typing.ClassVar['LocalizedGeometryFormats'] = ...
    UNABLE_TO_ORTHOGONOLIZE_MATRIX: typing.ClassVar['LocalizedGeometryFormats'] = ...
    ZERO_NORM_FOR_ROTATION_AXIS: typing.ClassVar['LocalizedGeometryFormats'] = ...
    ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR: typing.ClassVar['LocalizedGeometryFormats'] = ...
    TOO_SMALL_TOLERANCE: typing.ClassVar['LocalizedGeometryFormats'] = ...
    INVALID_ROTATION_ORDER_NAME: typing.ClassVar['LocalizedGeometryFormats'] = ...
    def getLocalizedString(self, locale: java.util.Locale) -> str: ...
    def getSourceString(self) -> str: ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'LocalizedGeometryFormats': ...
    @staticmethod
    def values() -> typing.List['LocalizedGeometryFormats']: ...

_Point__S = typing.TypeVar('_Point__S', bound='Space')  # <S>
class Point(java.io.Serializable, typing.Generic[_Point__S]):
    def distance(self, point: 'Point'[_Point__S]) -> float: ...
    def getSpace(self) -> 'Space': ...
    def isNaN(self) -> bool: ...

class Space(java.io.Serializable):
    def getDimension(self) -> int: ...
    def getSubSpace(self) -> 'Space': ...

_VectorFormat__S = typing.TypeVar('_VectorFormat__S', bound=Space)  # <S>
class VectorFormat(typing.Generic[_VectorFormat__S]):
    DEFAULT_PREFIX: typing.ClassVar[str] = ...
    DEFAULT_SUFFIX: typing.ClassVar[str] = ...
    DEFAULT_SEPARATOR: typing.ClassVar[str] = ...
    @typing.overload
    def format(self, vector: 'Vector'[_VectorFormat__S], stringBuffer: java.lang.StringBuffer, fieldPosition: java.text.FieldPosition) -> java.lang.StringBuffer: ...
    @typing.overload
    def format(self, vector: 'Vector'[_VectorFormat__S]) -> str: ...
    @staticmethod
    def getAvailableLocales() -> typing.List[java.util.Locale]: ...
    def getFormat(self) -> java.text.NumberFormat: ...
    def getPrefix(self) -> str: ...
    def getSeparator(self) -> str: ...
    def getSuffix(self) -> str: ...
    @typing.overload
    def parse(self, string: str) -> 'Vector'[_VectorFormat__S]: ...
    @typing.overload
    def parse(self, string: str, parsePosition: java.text.ParsePosition) -> 'Vector'[_VectorFormat__S]: ...

_Vector__S = typing.TypeVar('_Vector__S', bound=Space)  # <S>
class Vector(Point[_Vector__S], typing.Generic[_Vector__S]):
    @typing.overload
    def add(self, double: float, vector: 'Vector'[_Vector__S]) -> 'Vector'[_Vector__S]: ...
    @typing.overload
    def add(self, vector: 'Vector'[_Vector__S]) -> 'Vector'[_Vector__S]: ...
    def distance1(self, vector: 'Vector'[_Vector__S]) -> float: ...
    def distanceInf(self, vector: 'Vector'[_Vector__S]) -> float: ...
    def distanceSq(self, vector: 'Vector'[_Vector__S]) -> float: ...
    def dotProduct(self, vector: 'Vector'[_Vector__S]) -> float: ...
    def getNorm(self) -> float: ...
    def getNorm1(self) -> float: ...
    def getNormInf(self) -> float: ...
    def getNormSq(self) -> float: ...
    def getZero(self) -> 'Vector'[_Vector__S]: ...
    def isInfinite(self) -> bool: ...
    def negate(self) -> 'Vector'[_Vector__S]: ...
    def normalize(self) -> 'Vector'[_Vector__S]: ...
    def scalarMultiply(self, double: float) -> 'Vector'[_Vector__S]: ...
    @typing.overload
    def subtract(self, double: float, vector: 'Vector'[_Vector__S]) -> 'Vector'[_Vector__S]: ...
    @typing.overload
    def subtract(self, vector: 'Vector'[_Vector__S]) -> 'Vector'[_Vector__S]: ...
    def toString(self, numberFormat: java.text.NumberFormat) -> str: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.hipparchus.geometry")``.

    LocalizedGeometryFormats: typing.Type[LocalizedGeometryFormats]
    Point: typing.Type[Point]
    Space: typing.Type[Space]
    Vector: typing.Type[Vector]
    VectorFormat: typing.Type[VectorFormat]
    enclosing: org.hipparchus.geometry.enclosing.__module_protocol__
    euclidean: org.hipparchus.geometry.euclidean.__module_protocol__
    hull: org.hipparchus.geometry.hull.__module_protocol__
    partitioning: org.hipparchus.geometry.partitioning.__module_protocol__
    spherical: org.hipparchus.geometry.spherical.__module_protocol__
