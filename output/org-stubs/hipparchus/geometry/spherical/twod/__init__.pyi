import java.io
import java.util
import org.hipparchus.geometry
import org.hipparchus.geometry.enclosing
import org.hipparchus.geometry.euclidean.threed
import org.hipparchus.geometry.partitioning
import org.hipparchus.geometry.spherical.oned
import typing



class Circle(org.hipparchus.geometry.partitioning.Hyperplane['Sphere2D'], org.hipparchus.geometry.partitioning.Embedding['Sphere2D', org.hipparchus.geometry.spherical.oned.Sphere1D]):
    @typing.overload
    def __init__(self, vector3D: org.hipparchus.geometry.euclidean.threed.Vector3D, double: float): ...
    @typing.overload
    def __init__(self, circle: 'Circle'): ...
    @typing.overload
    def __init__(self, s2Point: 'S2Point', s2Point2: 'S2Point', double: float): ...
    def copySelf(self) -> 'Circle': ...
    def emptyHyperplane(self) -> 'SubCircle': ...
    def getArc(self, s2Point: 'S2Point', s2Point2: 'S2Point') -> org.hipparchus.geometry.spherical.oned.Arc: ...
    def getInsideArc(self, circle: 'Circle') -> org.hipparchus.geometry.spherical.oned.Arc: ...
    @typing.overload
    def getOffset(self, point: org.hipparchus.geometry.Point['Sphere2D']) -> float: ...
    @typing.overload
    def getOffset(self, vector3D: org.hipparchus.geometry.euclidean.threed.Vector3D) -> float: ...
    def getPhase(self, vector3D: org.hipparchus.geometry.euclidean.threed.Vector3D) -> float: ...
    def getPointAt(self, double: float) -> org.hipparchus.geometry.euclidean.threed.Vector3D: ...
    def getPole(self) -> org.hipparchus.geometry.euclidean.threed.Vector3D: ...
    def getReverse(self) -> 'Circle': ...
    def getTolerance(self) -> float: ...
    @staticmethod
    def getTransform(rotation: org.hipparchus.geometry.euclidean.threed.Rotation) -> org.hipparchus.geometry.partitioning.Transform['Sphere2D', org.hipparchus.geometry.spherical.oned.Sphere1D]: ...
    def getXAxis(self) -> org.hipparchus.geometry.euclidean.threed.Vector3D: ...
    def getYAxis(self) -> org.hipparchus.geometry.euclidean.threed.Vector3D: ...
    def project(self, point: org.hipparchus.geometry.Point['Sphere2D']) -> org.hipparchus.geometry.Point['Sphere2D']: ...
    def reset(self, vector3D: org.hipparchus.geometry.euclidean.threed.Vector3D) -> None: ...
    def revertSelf(self) -> None: ...
    def sameOrientationAs(self, hyperplane: org.hipparchus.geometry.partitioning.Hyperplane['Sphere2D']) -> bool: ...
    def toSpace(self, point: org.hipparchus.geometry.Point[org.hipparchus.geometry.spherical.oned.Sphere1D]) -> 'S2Point': ...
    def toSubSpace(self, point: org.hipparchus.geometry.Point['Sphere2D']) -> org.hipparchus.geometry.spherical.oned.S1Point: ...
    def wholeHyperplane(self) -> 'SubCircle': ...
    def wholeSpace(self) -> 'SphericalPolygonsSet': ...

class Edge:
    def getCircle(self) -> Circle: ...
    def getEnd(self) -> 'Vertex': ...
    def getLength(self) -> float: ...
    def getPointAt(self, double: float) -> org.hipparchus.geometry.euclidean.threed.Vector3D: ...
    def getStart(self) -> 'Vertex': ...

class S2Point(org.hipparchus.geometry.Point['Sphere2D']):
    PLUS_I: typing.ClassVar['S2Point'] = ...
    PLUS_J: typing.ClassVar['S2Point'] = ...
    PLUS_K: typing.ClassVar['S2Point'] = ...
    MINUS_I: typing.ClassVar['S2Point'] = ...
    MINUS_J: typing.ClassVar['S2Point'] = ...
    MINUS_K: typing.ClassVar['S2Point'] = ...
    NaN: typing.ClassVar['S2Point'] = ...
    @typing.overload
    def __init__(self, double: float, double2: float): ...
    @typing.overload
    def __init__(self, vector3D: org.hipparchus.geometry.euclidean.threed.Vector3D): ...
    @typing.overload
    def distance(self, point: org.hipparchus.geometry.Point['Sphere2D']) -> float: ...
    @typing.overload
    @staticmethod
    def distance(s2Point: 'S2Point', s2Point2: 'S2Point') -> float: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getPhi(self) -> float: ...
    def getSpace(self) -> org.hipparchus.geometry.Space: ...
    def getTheta(self) -> float: ...
    def getVector(self) -> org.hipparchus.geometry.euclidean.threed.Vector3D: ...
    def hashCode(self) -> int: ...
    def isNaN(self) -> bool: ...
    def negate(self) -> 'S2Point': ...
    def toString(self) -> str: ...

class Sphere2D(java.io.Serializable, org.hipparchus.geometry.Space):
    SMALLEST_TOLERANCE: typing.ClassVar[float] = ...
    @staticmethod
    def checkTolerance(double: float) -> None: ...
    def getDimension(self) -> int: ...
    @staticmethod
    def getInstance() -> 'Sphere2D': ...
    def getSubSpace(self) -> org.hipparchus.geometry.spherical.oned.Sphere1D: ...

class SphericalPolygonsSet(org.hipparchus.geometry.partitioning.AbstractRegion[Sphere2D, org.hipparchus.geometry.spherical.oned.Sphere1D]):
    @typing.overload
    def __init__(self, double: float): ...
    @typing.overload
    def __init__(self, double: float, s2PointArray: typing.List[S2Point]): ...
    @typing.overload
    def __init__(self, collection: typing.Union[java.util.Collection[org.hipparchus.geometry.partitioning.SubHyperplane[Sphere2D]], typing.Sequence[org.hipparchus.geometry.partitioning.SubHyperplane[Sphere2D]], typing.Set[org.hipparchus.geometry.partitioning.SubHyperplane[Sphere2D]]], double: float): ...
    @typing.overload
    def __init__(self, vector3D: org.hipparchus.geometry.euclidean.threed.Vector3D, double: float): ...
    @typing.overload
    def __init__(self, vector3D: org.hipparchus.geometry.euclidean.threed.Vector3D, vector3D2: org.hipparchus.geometry.euclidean.threed.Vector3D, double: float, int: int, double2: float): ...
    @typing.overload
    def __init__(self, bSPTree: org.hipparchus.geometry.partitioning.BSPTree[Sphere2D], double: float): ...
    def buildNew(self, bSPTree: org.hipparchus.geometry.partitioning.BSPTree[Sphere2D]) -> 'SphericalPolygonsSet': ...
    def getBoundaryLoops(self) -> java.util.List['Vertex']: ...
    def getEnclosingCap(self) -> org.hipparchus.geometry.enclosing.EnclosingBall[Sphere2D, S2Point]: ...

class SubCircle(org.hipparchus.geometry.partitioning.AbstractSubHyperplane[Sphere2D, org.hipparchus.geometry.spherical.oned.Sphere1D]):
    def __init__(self, hyperplane: org.hipparchus.geometry.partitioning.Hyperplane[Sphere2D], region: org.hipparchus.geometry.partitioning.Region[org.hipparchus.geometry.spherical.oned.Sphere1D]): ...
    def split(self, hyperplane: org.hipparchus.geometry.partitioning.Hyperplane[Sphere2D]) -> org.hipparchus.geometry.partitioning.SubHyperplane.SplitSubHyperplane[Sphere2D]: ...

class Vertex:
    def getIncoming(self) -> Edge: ...
    def getLocation(self) -> S2Point: ...
    def getOutgoing(self) -> Edge: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.hipparchus.geometry.spherical.twod")``.

    Circle: typing.Type[Circle]
    Edge: typing.Type[Edge]
    S2Point: typing.Type[S2Point]
    Sphere2D: typing.Type[Sphere2D]
    SphericalPolygonsSet: typing.Type[SphericalPolygonsSet]
    SubCircle: typing.Type[SubCircle]
    Vertex: typing.Type[Vertex]
