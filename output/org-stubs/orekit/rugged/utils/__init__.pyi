import java.io
import java.util
import org.hipparchus
import org.hipparchus.analysis.differentiation
import org.hipparchus.geometry.euclidean.threed
import org.orekit.bodies
import org.orekit.frames
import org.orekit.time
import org.orekit.utils
import typing



_DerivativeGenerator__T = typing.TypeVar('_DerivativeGenerator__T', bound=org.hipparchus.analysis.differentiation.Derivative)  # <T>
class DerivativeGenerator(typing.Generic[_DerivativeGenerator__T]):
    def constant(self, double: float) -> _DerivativeGenerator__T: ...
    def getField(self) -> org.hipparchus.Field[_DerivativeGenerator__T]: ...
    def getSelected(self) -> java.util.List[org.orekit.utils.ParameterDriver]: ...
    def variable(self, parameterDriver: org.orekit.utils.ParameterDriver) -> _DerivativeGenerator__T: ...

class ExtendedEllipsoid(org.orekit.bodies.OneAxisEllipsoid):
    def __init__(self, double: float, double2: float, frame: org.orekit.frames.Frame): ...
    @typing.overload
    def convertLos(self, vector3D: org.hipparchus.geometry.euclidean.threed.Vector3D, vector3D2: org.hipparchus.geometry.euclidean.threed.Vector3D) -> org.hipparchus.geometry.euclidean.threed.Vector3D: ...
    @typing.overload
    def convertLos(self, geodeticPoint: org.orekit.bodies.GeodeticPoint, vector3D: org.hipparchus.geometry.euclidean.threed.Vector3D) -> org.hipparchus.geometry.euclidean.threed.Vector3D: ...
    def pointAtAltitude(self, vector3D: org.hipparchus.geometry.euclidean.threed.Vector3D, vector3D2: org.hipparchus.geometry.euclidean.threed.Vector3D, double: float) -> org.hipparchus.geometry.euclidean.threed.Vector3D: ...
    def pointAtLatitude(self, vector3D: org.hipparchus.geometry.euclidean.threed.Vector3D, vector3D2: org.hipparchus.geometry.euclidean.threed.Vector3D, double: float, vector3D3: org.hipparchus.geometry.euclidean.threed.Vector3D) -> org.hipparchus.geometry.euclidean.threed.Vector3D: ...
    def pointAtLongitude(self, vector3D: org.hipparchus.geometry.euclidean.threed.Vector3D, vector3D2: org.hipparchus.geometry.euclidean.threed.Vector3D, double: float) -> org.hipparchus.geometry.euclidean.threed.Vector3D: ...
    def pointOnGround(self, vector3D: org.hipparchus.geometry.euclidean.threed.Vector3D, vector3D2: org.hipparchus.geometry.euclidean.threed.Vector3D, double: float) -> 'NormalizedGeodeticPoint': ...
    _transform_0__T = typing.TypeVar('_transform_0__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _transform_2__T = typing.TypeVar('_transform_2__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def transform(self, fieldGeodeticPoint: org.orekit.bodies.FieldGeodeticPoint[_transform_0__T]) -> org.hipparchus.geometry.euclidean.threed.FieldVector3D[_transform_0__T]: ...
    @typing.overload
    def transform(self, geodeticPoint: org.orekit.bodies.GeodeticPoint) -> org.hipparchus.geometry.euclidean.threed.Vector3D: ...
    @typing.overload
    def transform(self, fieldVector3D: org.hipparchus.geometry.euclidean.threed.FieldVector3D[_transform_2__T], frame: org.orekit.frames.Frame, fieldAbsoluteDate: org.orekit.time.FieldAbsoluteDate[_transform_2__T]) -> org.orekit.bodies.FieldGeodeticPoint[_transform_2__T]: ...
    @typing.overload
    def transform(self, pVCoordinates: org.orekit.utils.PVCoordinates, frame: org.orekit.frames.Frame, absoluteDate: org.orekit.time.AbsoluteDate) -> org.orekit.bodies.FieldGeodeticPoint[org.hipparchus.analysis.differentiation.DerivativeStructure]: ...
    @typing.overload
    def transform(self, vector3D: org.hipparchus.geometry.euclidean.threed.Vector3D, frame: org.orekit.frames.Frame, absoluteDate: org.orekit.time.AbsoluteDate) -> org.orekit.bodies.GeodeticPoint: ...
    @typing.overload
    def transform(self, vector3D: org.hipparchus.geometry.euclidean.threed.Vector3D, frame: org.orekit.frames.Frame, absoluteDate: org.orekit.time.AbsoluteDate, double: float) -> 'NormalizedGeodeticPoint': ...

class GridCreation:
    @staticmethod
    def createLinearGrid(double: float, double2: float, int: int) -> typing.List[float]: ...

class NormalizedGeodeticPoint(org.orekit.bodies.GeodeticPoint):
    def __init__(self, double: float, double2: float, double3: float, double4: float): ...
    def equals(self, object: typing.Any) -> bool: ...
    def getLongitude(self) -> float: ...
    def hashCode(self) -> int: ...

class RoughVisibilityEstimator:
    def __init__(self, oneAxisEllipsoid: org.orekit.bodies.OneAxisEllipsoid, frame: org.orekit.frames.Frame, list: java.util.List[org.orekit.utils.TimeStampedPVCoordinates]): ...
    def estimateVisibility(self, geodeticPoint: org.orekit.bodies.GeodeticPoint) -> org.orekit.time.AbsoluteDate: ...

class Selector:
    def __init__(self): ...
    def select(self, double: float, double2: float) -> float: ...
    def selectFirst(self, double: float, double2: float) -> bool: ...

class SpacecraftToObservedBody(java.io.Serializable):
    @typing.overload
    def __init__(self, frame: org.orekit.frames.Frame, frame2: org.orekit.frames.Frame, absoluteDate: org.orekit.time.AbsoluteDate, absoluteDate2: org.orekit.time.AbsoluteDate, double: float, double2: float, list: java.util.List[org.orekit.utils.TimeStampedPVCoordinates], int: int, cartesianDerivativesFilter: org.orekit.utils.CartesianDerivativesFilter, list2: java.util.List[org.orekit.utils.TimeStampedAngularCoordinates], int2: int, angularDerivativesFilter: org.orekit.utils.AngularDerivativesFilter): ...
    @typing.overload
    def __init__(self, frame: org.orekit.frames.Frame, frame2: org.orekit.frames.Frame, absoluteDate: org.orekit.time.AbsoluteDate, absoluteDate2: org.orekit.time.AbsoluteDate, double: float, double2: float, list: java.util.List[org.orekit.frames.Transform], list2: java.util.List[org.orekit.frames.Transform]): ...
    def getBodyFrame(self) -> org.orekit.frames.Frame: ...
    def getBodyToInertial(self, absoluteDate: org.orekit.time.AbsoluteDate) -> org.orekit.frames.Transform: ...
    def getInertialFrame(self) -> org.orekit.frames.Frame: ...
    def getInertialToBody(self, absoluteDate: org.orekit.time.AbsoluteDate) -> org.orekit.frames.Transform: ...
    def getMaxDate(self) -> org.orekit.time.AbsoluteDate: ...
    def getMinDate(self) -> org.orekit.time.AbsoluteDate: ...
    def getOvershootTolerance(self) -> float: ...
    def getScToInertial(self, absoluteDate: org.orekit.time.AbsoluteDate) -> org.orekit.frames.Transform: ...
    def getTStep(self) -> float: ...
    def isInRange(self, absoluteDate: org.orekit.time.AbsoluteDate) -> bool: ...

class DSGenerator(DerivativeGenerator[org.hipparchus.analysis.differentiation.DerivativeStructure]): ...

class MaxSelector(Selector):
    @staticmethod
    def getInstance() -> 'MaxSelector': ...
    def selectFirst(self, double: float, double2: float) -> bool: ...

class MinSelector(Selector):
    @staticmethod
    def getInstance() -> 'MinSelector': ...
    def selectFirst(self, double: float, double2: float) -> bool: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.orekit.rugged.utils")``.

    DSGenerator: typing.Type[DSGenerator]
    DerivativeGenerator: typing.Type[DerivativeGenerator]
    ExtendedEllipsoid: typing.Type[ExtendedEllipsoid]
    GridCreation: typing.Type[GridCreation]
    MaxSelector: typing.Type[MaxSelector]
    MinSelector: typing.Type[MinSelector]
    NormalizedGeodeticPoint: typing.Type[NormalizedGeodeticPoint]
    RoughVisibilityEstimator: typing.Type[RoughVisibilityEstimator]
    Selector: typing.Type[Selector]
    SpacecraftToObservedBody: typing.Type[SpacecraftToObservedBody]
