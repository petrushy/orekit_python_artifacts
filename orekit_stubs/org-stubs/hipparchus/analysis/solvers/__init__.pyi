import java.lang
import org.hipparchus
import org.hipparchus.analysis
import org.hipparchus.analysis.differentiation
import org.hipparchus.analysis.polynomials
import org.hipparchus.analysis.solvers.class-use
import org.hipparchus.complex
import typing



class AllowedSolution(java.lang.Enum['AllowedSolution']):
    ANY_SIDE: typing.ClassVar['AllowedSolution'] = ...
    LEFT_SIDE: typing.ClassVar['AllowedSolution'] = ...
    RIGHT_SIDE: typing.ClassVar['AllowedSolution'] = ...
    BELOW_SIDE: typing.ClassVar['AllowedSolution'] = ...
    ABOVE_SIDE: typing.ClassVar['AllowedSolution'] = ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'AllowedSolution': ...
    @staticmethod
    def values() -> typing.List['AllowedSolution']: ...

_BaseUnivariateSolver__F = typing.TypeVar('_BaseUnivariateSolver__F', bound=org.hipparchus.analysis.UnivariateFunction)  # <F>
class BaseUnivariateSolver(typing.Generic[_BaseUnivariateSolver__F]):
    def getAbsoluteAccuracy(self) -> float: ...
    def getEvaluations(self) -> int: ...
    def getFunctionValueAccuracy(self) -> float: ...
    def getRelativeAccuracy(self) -> float: ...
    @typing.overload
    def solve(self, int: int, f: _BaseUnivariateSolver__F, double: float) -> float: ...
    @typing.overload
    def solve(self, int: int, f: _BaseUnivariateSolver__F, double: float, double2: float) -> float: ...
    @typing.overload
    def solve(self, int: int, f: _BaseUnivariateSolver__F, double: float, double2: float, double3: float) -> float: ...

_BracketedRealFieldUnivariateSolver__Interval__T = typing.TypeVar('_BracketedRealFieldUnivariateSolver__Interval__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
_BracketedRealFieldUnivariateSolver__T = typing.TypeVar('_BracketedRealFieldUnivariateSolver__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
class BracketedRealFieldUnivariateSolver(typing.Generic[_BracketedRealFieldUnivariateSolver__T]):
    def getAbsoluteAccuracy(self) -> _BracketedRealFieldUnivariateSolver__T: ...
    def getEvaluations(self) -> int: ...
    def getFunctionValueAccuracy(self) -> _BracketedRealFieldUnivariateSolver__T: ...
    def getMaxEvaluations(self) -> int: ...
    def getRelativeAccuracy(self) -> _BracketedRealFieldUnivariateSolver__T: ...
    @typing.overload
    def solve(self, int: int, calculusFieldUnivariateFunction: org.hipparchus.analysis.CalculusFieldUnivariateFunction[_BracketedRealFieldUnivariateSolver__T], t: _BracketedRealFieldUnivariateSolver__T, t2: _BracketedRealFieldUnivariateSolver__T, t3: _BracketedRealFieldUnivariateSolver__T, allowedSolution: AllowedSolution) -> _BracketedRealFieldUnivariateSolver__T: ...
    @typing.overload
    def solve(self, int: int, calculusFieldUnivariateFunction: org.hipparchus.analysis.CalculusFieldUnivariateFunction[_BracketedRealFieldUnivariateSolver__T], t: _BracketedRealFieldUnivariateSolver__T, t2: _BracketedRealFieldUnivariateSolver__T, allowedSolution: AllowedSolution) -> _BracketedRealFieldUnivariateSolver__T: ...
    @typing.overload
    def solveInterval(self, int: int, calculusFieldUnivariateFunction: org.hipparchus.analysis.CalculusFieldUnivariateFunction[_BracketedRealFieldUnivariateSolver__T], t: _BracketedRealFieldUnivariateSolver__T, t2: _BracketedRealFieldUnivariateSolver__T, t3: _BracketedRealFieldUnivariateSolver__T) -> 'BracketedRealFieldUnivariateSolver.Interval'[_BracketedRealFieldUnivariateSolver__T]: ...
    @typing.overload
    def solveInterval(self, int: int, calculusFieldUnivariateFunction: org.hipparchus.analysis.CalculusFieldUnivariateFunction[_BracketedRealFieldUnivariateSolver__T], t: _BracketedRealFieldUnivariateSolver__T, t2: _BracketedRealFieldUnivariateSolver__T) -> 'BracketedRealFieldUnivariateSolver.Interval'[_BracketedRealFieldUnivariateSolver__T]: ...
    class Interval(typing.Generic[_BracketedRealFieldUnivariateSolver__Interval__T]):
        def __init__(self, t: _BracketedRealFieldUnivariateSolver__Interval__T, t2: _BracketedRealFieldUnivariateSolver__Interval__T, t3: _BracketedRealFieldUnivariateSolver__Interval__T, t4: _BracketedRealFieldUnivariateSolver__Interval__T): ...
        def getLeftAbscissa(self) -> _BracketedRealFieldUnivariateSolver__Interval__T: ...
        def getLeftValue(self) -> _BracketedRealFieldUnivariateSolver__Interval__T: ...
        def getRightAbscissa(self) -> _BracketedRealFieldUnivariateSolver__Interval__T: ...
        def getRightValue(self) -> _BracketedRealFieldUnivariateSolver__Interval__T: ...
        def getSide(self, allowedSolution: AllowedSolution) -> _BracketedRealFieldUnivariateSolver__Interval__T: ...

class UnivariateSolverUtils:
    _bracket_3__T = typing.TypeVar('_bracket_3__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _bracket_4__T = typing.TypeVar('_bracket_4__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _bracket_5__T = typing.TypeVar('_bracket_5__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def bracket(univariateFunction: org.hipparchus.analysis.UnivariateFunction, double: float, double2: float, double3: float) -> typing.List[float]: ...
    @typing.overload
    @staticmethod
    def bracket(univariateFunction: org.hipparchus.analysis.UnivariateFunction, double: float, double2: float, double3: float, double4: float, double5: float, int: int) -> typing.List[float]: ...
    @typing.overload
    @staticmethod
    def bracket(univariateFunction: org.hipparchus.analysis.UnivariateFunction, double: float, double2: float, double3: float, int: int) -> typing.List[float]: ...
    @typing.overload
    @staticmethod
    def bracket(calculusFieldUnivariateFunction: org.hipparchus.analysis.CalculusFieldUnivariateFunction[_bracket_3__T], t: _bracket_3__T, t2: _bracket_3__T, t3: _bracket_3__T) -> typing.List[_bracket_3__T]: ...
    @typing.overload
    @staticmethod
    def bracket(calculusFieldUnivariateFunction: org.hipparchus.analysis.CalculusFieldUnivariateFunction[_bracket_4__T], t: _bracket_4__T, t2: _bracket_4__T, t3: _bracket_4__T, int: int) -> typing.List[_bracket_4__T]: ...
    @typing.overload
    @staticmethod
    def bracket(calculusFieldUnivariateFunction: org.hipparchus.analysis.CalculusFieldUnivariateFunction[_bracket_5__T], t: _bracket_5__T, t2: _bracket_5__T, t3: _bracket_5__T, t4: _bracket_5__T, t5: _bracket_5__T, int: int) -> typing.List[_bracket_5__T]: ...
    @staticmethod
    def forceSide(int: int, univariateFunction: org.hipparchus.analysis.UnivariateFunction, bracketedUnivariateSolver: 'BracketedUnivariateSolver'[org.hipparchus.analysis.UnivariateFunction], double: float, double2: float, double3: float, allowedSolution: AllowedSolution) -> float: ...
    @staticmethod
    def isBracketing(univariateFunction: org.hipparchus.analysis.UnivariateFunction, double: float, double2: float) -> bool: ...
    @staticmethod
    def isSequence(double: float, double2: float, double3: float) -> bool: ...
    @staticmethod
    def midpoint(double: float, double2: float) -> float: ...
    @typing.overload
    @staticmethod
    def solve(univariateFunction: org.hipparchus.analysis.UnivariateFunction, double: float, double2: float) -> float: ...
    @typing.overload
    @staticmethod
    def solve(univariateFunction: org.hipparchus.analysis.UnivariateFunction, double: float, double2: float, double3: float) -> float: ...
    @staticmethod
    def verifyBracketing(univariateFunction: org.hipparchus.analysis.UnivariateFunction, double: float, double2: float) -> None: ...
    @staticmethod
    def verifyInterval(double: float, double2: float) -> None: ...
    @staticmethod
    def verifySequence(double: float, double2: float, double3: float) -> None: ...

_BaseAbstractUnivariateSolver__F = typing.TypeVar('_BaseAbstractUnivariateSolver__F', bound=org.hipparchus.analysis.UnivariateFunction)  # <F>
class BaseAbstractUnivariateSolver(BaseUnivariateSolver[_BaseAbstractUnivariateSolver__F], typing.Generic[_BaseAbstractUnivariateSolver__F]):
    def getAbsoluteAccuracy(self) -> float: ...
    def getEvaluations(self) -> int: ...
    def getFunctionValueAccuracy(self) -> float: ...
    def getMax(self) -> float: ...
    def getMin(self) -> float: ...
    def getRelativeAccuracy(self) -> float: ...
    def getStartValue(self) -> float: ...
    @typing.overload
    def solve(self, int: int, f: _BaseAbstractUnivariateSolver__F, double: float) -> float: ...
    @typing.overload
    def solve(self, int: int, f: _BaseAbstractUnivariateSolver__F, double: float, double2: float) -> float: ...
    @typing.overload
    def solve(self, int: int, f: _BaseAbstractUnivariateSolver__F, double: float, double2: float, double3: float) -> float: ...

_BracketedUnivariateSolver__F = typing.TypeVar('_BracketedUnivariateSolver__F', bound=org.hipparchus.analysis.UnivariateFunction)  # <F>
class BracketedUnivariateSolver(BaseUnivariateSolver[_BracketedUnivariateSolver__F], typing.Generic[_BracketedUnivariateSolver__F]):
    @typing.overload
    def solve(self, int: int, f: _BracketedUnivariateSolver__F, double: float) -> float: ...
    @typing.overload
    def solve(self, int: int, f: _BracketedUnivariateSolver__F, double: float, double2: float) -> float: ...
    @typing.overload
    def solve(self, int: int, f: _BracketedUnivariateSolver__F, double: float, double2: float, double3: float) -> float: ...
    @typing.overload
    def solve(self, int: int, f: _BracketedUnivariateSolver__F, double: float, double2: float, double3: float, allowedSolution: AllowedSolution) -> float: ...
    @typing.overload
    def solve(self, int: int, f: _BracketedUnivariateSolver__F, double: float, double2: float, allowedSolution: AllowedSolution) -> float: ...
    @typing.overload
    def solveInterval(self, int: int, f: _BracketedUnivariateSolver__F, double: float, double2: float, double3: float) -> 'BracketedUnivariateSolver.Interval': ...
    @typing.overload
    def solveInterval(self, int: int, f: _BracketedUnivariateSolver__F, double: float, double2: float) -> 'BracketedUnivariateSolver.Interval': ...
    class Interval:
        def __init__(self, double: float, double2: float, double3: float, double4: float): ...
        def getLeftAbscissa(self) -> float: ...
        def getLeftValue(self) -> float: ...
        def getRightAbscissa(self) -> float: ...
        def getRightValue(self) -> float: ...
        def getSide(self, allowedSolution: AllowedSolution) -> float: ...

_FieldBracketingNthOrderBrentSolver__T = typing.TypeVar('_FieldBracketingNthOrderBrentSolver__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
class FieldBracketingNthOrderBrentSolver(BracketedRealFieldUnivariateSolver[_FieldBracketingNthOrderBrentSolver__T], typing.Generic[_FieldBracketingNthOrderBrentSolver__T]):
    def __init__(self, t: _FieldBracketingNthOrderBrentSolver__T, t2: _FieldBracketingNthOrderBrentSolver__T, t3: _FieldBracketingNthOrderBrentSolver__T, int: int): ...
    def getAbsoluteAccuracy(self) -> _FieldBracketingNthOrderBrentSolver__T: ...
    def getEvaluations(self) -> int: ...
    def getFunctionValueAccuracy(self) -> _FieldBracketingNthOrderBrentSolver__T: ...
    def getMaxEvaluations(self) -> int: ...
    def getMaximalOrder(self) -> int: ...
    def getRelativeAccuracy(self) -> _FieldBracketingNthOrderBrentSolver__T: ...
    @typing.overload
    def solve(self, int: int, calculusFieldUnivariateFunction: org.hipparchus.analysis.CalculusFieldUnivariateFunction[_FieldBracketingNthOrderBrentSolver__T], t: _FieldBracketingNthOrderBrentSolver__T, t2: _FieldBracketingNthOrderBrentSolver__T, t3: _FieldBracketingNthOrderBrentSolver__T, allowedSolution: AllowedSolution) -> _FieldBracketingNthOrderBrentSolver__T: ...
    @typing.overload
    def solve(self, int: int, calculusFieldUnivariateFunction: org.hipparchus.analysis.CalculusFieldUnivariateFunction[_FieldBracketingNthOrderBrentSolver__T], t: _FieldBracketingNthOrderBrentSolver__T, t2: _FieldBracketingNthOrderBrentSolver__T, allowedSolution: AllowedSolution) -> _FieldBracketingNthOrderBrentSolver__T: ...
    @typing.overload
    def solveInterval(self, int: int, calculusFieldUnivariateFunction: org.hipparchus.analysis.CalculusFieldUnivariateFunction[_FieldBracketingNthOrderBrentSolver__T], t: _FieldBracketingNthOrderBrentSolver__T, t2: _FieldBracketingNthOrderBrentSolver__T) -> BracketedRealFieldUnivariateSolver.Interval[_FieldBracketingNthOrderBrentSolver__T]: ...
    @typing.overload
    def solveInterval(self, int: int, calculusFieldUnivariateFunction: org.hipparchus.analysis.CalculusFieldUnivariateFunction[_FieldBracketingNthOrderBrentSolver__T], t: _FieldBracketingNthOrderBrentSolver__T, t2: _FieldBracketingNthOrderBrentSolver__T, t3: _FieldBracketingNthOrderBrentSolver__T) -> BracketedRealFieldUnivariateSolver.Interval[_FieldBracketingNthOrderBrentSolver__T]: ...

class PolynomialSolver(BaseUnivariateSolver[org.hipparchus.analysis.polynomials.PolynomialFunction]): ...

class UnivariateDifferentiableSolver(BaseUnivariateSolver[org.hipparchus.analysis.differentiation.UnivariateDifferentiableFunction]): ...

class UnivariateSolver(BaseUnivariateSolver[org.hipparchus.analysis.UnivariateFunction]): ...

class AbstractPolynomialSolver(BaseAbstractUnivariateSolver[org.hipparchus.analysis.polynomials.PolynomialFunction], PolynomialSolver): ...

class AbstractUnivariateDifferentiableSolver(BaseAbstractUnivariateSolver[org.hipparchus.analysis.differentiation.UnivariateDifferentiableFunction], UnivariateDifferentiableSolver): ...

class AbstractUnivariateSolver(BaseAbstractUnivariateSolver[org.hipparchus.analysis.UnivariateFunction], UnivariateSolver): ...

class BaseSecantSolver(AbstractUnivariateSolver, BracketedUnivariateSolver[org.hipparchus.analysis.UnivariateFunction]):
    @typing.overload
    def solve(self, int: int, f: org.hipparchus.analysis.UnivariateFunction, double: float) -> float: ...
    @typing.overload
    def solve(self, int: int, f: org.hipparchus.analysis.UnivariateFunction, double: float, double2: float) -> float: ...
    @typing.overload
    def solve(self, int: int, univariateFunction: org.hipparchus.analysis.UnivariateFunction, double: float, double2: float, double3: float) -> float: ...
    @typing.overload
    def solve(self, int: int, univariateFunction: org.hipparchus.analysis.UnivariateFunction, double: float, double2: float, double3: float, allowedSolution: AllowedSolution) -> float: ...
    @typing.overload
    def solve(self, int: int, univariateFunction: org.hipparchus.analysis.UnivariateFunction, double: float, double2: float, allowedSolution: AllowedSolution) -> float: ...
    @typing.overload
    def solveInterval(self, int: int, f: org.hipparchus.analysis.UnivariateFunction, double: float, double2: float) -> BracketedUnivariateSolver.Interval: ...
    @typing.overload
    def solveInterval(self, int: int, univariateFunction: org.hipparchus.analysis.UnivariateFunction, double: float, double2: float, double3: float) -> BracketedUnivariateSolver.Interval: ...

class BisectionSolver(AbstractUnivariateSolver):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float): ...

class BracketingNthOrderBrentSolver(AbstractUnivariateSolver, BracketedUnivariateSolver[org.hipparchus.analysis.UnivariateFunction]):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float, int: int): ...
    @typing.overload
    def __init__(self, double: float, double2: float, int: int): ...
    @typing.overload
    def __init__(self, double: float, int: int): ...
    def getMaximalOrder(self) -> int: ...
    @typing.overload
    def solve(self, int: int, f: org.hipparchus.analysis.UnivariateFunction, double: float) -> float: ...
    @typing.overload
    def solve(self, int: int, f: org.hipparchus.analysis.UnivariateFunction, double: float, double2: float) -> float: ...
    @typing.overload
    def solve(self, int: int, f: org.hipparchus.analysis.UnivariateFunction, double: float, double2: float, double3: float) -> float: ...
    @typing.overload
    def solve(self, int: int, univariateFunction: org.hipparchus.analysis.UnivariateFunction, double: float, double2: float, double3: float, allowedSolution: AllowedSolution) -> float: ...
    @typing.overload
    def solve(self, int: int, univariateFunction: org.hipparchus.analysis.UnivariateFunction, double: float, double2: float, allowedSolution: AllowedSolution) -> float: ...
    @typing.overload
    def solveInterval(self, int: int, f: org.hipparchus.analysis.UnivariateFunction, double: float, double2: float) -> BracketedUnivariateSolver.Interval: ...
    @typing.overload
    def solveInterval(self, int: int, univariateFunction: org.hipparchus.analysis.UnivariateFunction, double: float, double2: float, double3: float) -> BracketedUnivariateSolver.Interval: ...

class BrentSolver(AbstractUnivariateSolver):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float): ...

class LaguerreSolver(AbstractPolynomialSolver):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float): ...
    def doSolve(self) -> float: ...
    @typing.overload
    def solveAllComplex(self, doubleArray: typing.List[float], double2: float) -> typing.List[org.hipparchus.complex.Complex]: ...
    @typing.overload
    def solveAllComplex(self, doubleArray: typing.List[float], int: int, double2: float) -> typing.List[org.hipparchus.complex.Complex]: ...
    def solveComplex(self, doubleArray: typing.List[float], double2: float) -> org.hipparchus.complex.Complex: ...

class MullerSolver(AbstractUnivariateSolver):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float): ...

class MullerSolver2(AbstractUnivariateSolver):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float): ...

class NewtonRaphsonSolver(AbstractUnivariateDifferentiableSolver):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float): ...
    @typing.overload
    def solve(self, int: int, f: org.hipparchus.analysis.UnivariateFunction, double: float) -> float: ...
    @typing.overload
    def solve(self, int: int, f: org.hipparchus.analysis.UnivariateFunction, double: float, double2: float, double3: float) -> float: ...
    @typing.overload
    def solve(self, int: int, univariateDifferentiableFunction: org.hipparchus.analysis.differentiation.UnivariateDifferentiableFunction, double: float, double2: float) -> float: ...

class RiddersSolver(AbstractUnivariateSolver):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float): ...

class SecantSolver(AbstractUnivariateSolver):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float): ...

class IllinoisSolver(BaseSecantSolver):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float): ...

class PegasusSolver(BaseSecantSolver):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float): ...

class RegulaFalsiSolver(BaseSecantSolver):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float): ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.hipparchus.analysis.solvers")``.

    AbstractPolynomialSolver: typing.Type[AbstractPolynomialSolver]
    AbstractUnivariateDifferentiableSolver: typing.Type[AbstractUnivariateDifferentiableSolver]
    AbstractUnivariateSolver: typing.Type[AbstractUnivariateSolver]
    AllowedSolution: typing.Type[AllowedSolution]
    BaseAbstractUnivariateSolver: typing.Type[BaseAbstractUnivariateSolver]
    BaseSecantSolver: typing.Type[BaseSecantSolver]
    BaseUnivariateSolver: typing.Type[BaseUnivariateSolver]
    BisectionSolver: typing.Type[BisectionSolver]
    BracketedRealFieldUnivariateSolver: typing.Type[BracketedRealFieldUnivariateSolver]
    BracketedUnivariateSolver: typing.Type[BracketedUnivariateSolver]
    BracketingNthOrderBrentSolver: typing.Type[BracketingNthOrderBrentSolver]
    BrentSolver: typing.Type[BrentSolver]
    FieldBracketingNthOrderBrentSolver: typing.Type[FieldBracketingNthOrderBrentSolver]
    IllinoisSolver: typing.Type[IllinoisSolver]
    LaguerreSolver: typing.Type[LaguerreSolver]
    MullerSolver: typing.Type[MullerSolver]
    MullerSolver2: typing.Type[MullerSolver2]
    NewtonRaphsonSolver: typing.Type[NewtonRaphsonSolver]
    PegasusSolver: typing.Type[PegasusSolver]
    PolynomialSolver: typing.Type[PolynomialSolver]
    RegulaFalsiSolver: typing.Type[RegulaFalsiSolver]
    RiddersSolver: typing.Type[RiddersSolver]
    SecantSolver: typing.Type[SecantSolver]
    UnivariateDifferentiableSolver: typing.Type[UnivariateDifferentiableSolver]
    UnivariateSolver: typing.Type[UnivariateSolver]
    UnivariateSolverUtils: typing.Type[UnivariateSolverUtils]
    class-use: org.hipparchus.analysis.solvers.class-use.__module_protocol__
