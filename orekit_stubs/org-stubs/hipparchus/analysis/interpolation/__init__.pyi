import java.io
import org.hipparchus
import org.hipparchus.analysis
import org.hipparchus.analysis.differentiation
import org.hipparchus.analysis.polynomials
import org.hipparchus.random
import typing



class BicubicInterpolatingFunction(org.hipparchus.analysis.BivariateFunction):
    def __init__(self, doubleArray: typing.List[float], doubleArray2: typing.List[float], doubleArray3: typing.List[typing.List[float]], doubleArray4: typing.List[typing.List[float]], doubleArray5: typing.List[typing.List[float]], doubleArray6: typing.List[typing.List[float]]): ...
    def isValidPoint(self, double: float, double2: float) -> bool: ...
    def value(self, double: float, double2: float) -> float: ...

class BilinearInterpolatingFunction(org.hipparchus.analysis.BivariateFunction, org.hipparchus.analysis.FieldBivariateFunction, java.io.Serializable):
    def __init__(self, doubleArray: typing.List[float], doubleArray2: typing.List[float], doubleArray3: typing.List[typing.List[float]]): ...
    def getXInf(self) -> float: ...
    def getXSup(self) -> float: ...
    def getYInf(self) -> float: ...
    def getYSup(self) -> float: ...
    _value_1__T = typing.TypeVar('_value_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def value(self, double: float, double2: float) -> float: ...
    @typing.overload
    def value(self, t: _value_1__T, t2: _value_1__T) -> _value_1__T: ...

class BivariateGridInterpolator:
    def interpolate(self, doubleArray: typing.List[float], doubleArray2: typing.List[float], doubleArray3: typing.List[typing.List[float]]) -> org.hipparchus.analysis.BivariateFunction: ...

_FieldHermiteInterpolator__T = typing.TypeVar('_FieldHermiteInterpolator__T', bound=org.hipparchus.FieldElement)  # <T>
class FieldHermiteInterpolator(typing.Generic[_FieldHermiteInterpolator__T]):
    def __init__(self): ...
    def addSamplePoint(self, t: _FieldHermiteInterpolator__T, *tArray: typing.List[_FieldHermiteInterpolator__T]) -> None: ...
    def derivatives(self, t: _FieldHermiteInterpolator__T, int: int) -> typing.List[typing.List[_FieldHermiteInterpolator__T]]: ...
    def value(self, t: _FieldHermiteInterpolator__T) -> typing.List[_FieldHermiteInterpolator__T]: ...

class FieldUnivariateInterpolator:
    _interpolate__T = typing.TypeVar('_interpolate__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    def interpolate(self, tArray: typing.List[_interpolate__T], tArray2: typing.List[_interpolate__T]) -> org.hipparchus.analysis.CalculusFieldUnivariateFunction[_interpolate__T]: ...

class GridAxis(java.io.Serializable):
    def __init__(self, doubleArray: typing.List[float], int: int): ...
    def getN(self) -> int: ...
    def interpolationIndex(self, double: float) -> int: ...
    def node(self, int: int) -> float: ...
    def size(self) -> int: ...

class HermiteInterpolator(org.hipparchus.analysis.differentiation.UnivariateDifferentiableVectorFunction):
    def __init__(self): ...
    def addSamplePoint(self, double: float, *doubleArray: typing.List[float]) -> None: ...
    def derivatives(self, double: float, int: int) -> typing.List[typing.List[float]]: ...
    def getPolynomials(self) -> typing.List[org.hipparchus.analysis.polynomials.PolynomialFunction]: ...
    _value_1__T = typing.TypeVar('_value_1__T', bound=org.hipparchus.analysis.differentiation.Derivative)  # <T>
    @typing.overload
    def value(self, double: float) -> typing.List[float]: ...
    @typing.overload
    def value(self, t: _value_1__T) -> typing.List[_value_1__T]: ...

class InterpolatingMicrosphere:
    def __init__(self, int: int, int2: int, double: float, double2: float, double3: float, unitSphereRandomVectorGenerator: org.hipparchus.random.UnitSphereRandomVectorGenerator): ...
    def copy(self) -> 'InterpolatingMicrosphere': ...
    def getDimension(self) -> int: ...
    def getSize(self) -> int: ...
    def value(self, doubleArray: typing.List[float], doubleArray2: typing.List[typing.List[float]], doubleArray3: typing.List[float], double4: float, double5: float) -> float: ...

class MultivariateInterpolator:
    def interpolate(self, doubleArray: typing.List[typing.List[float]], doubleArray2: typing.List[float]) -> org.hipparchus.analysis.MultivariateFunction: ...

class PiecewiseBicubicSplineInterpolatingFunction(org.hipparchus.analysis.BivariateFunction, org.hipparchus.analysis.FieldBivariateFunction):
    def __init__(self, doubleArray: typing.List[float], doubleArray2: typing.List[float], doubleArray3: typing.List[typing.List[float]]): ...
    def isValidPoint(self, double: float, double2: float) -> bool: ...
    _value_1__T = typing.TypeVar('_value_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def value(self, double: float, double2: float) -> float: ...
    @typing.overload
    def value(self, t: _value_1__T, t2: _value_1__T) -> _value_1__T: ...

class TricubicInterpolatingFunction(org.hipparchus.analysis.TrivariateFunction):
    def __init__(self, doubleArray: typing.List[float], doubleArray2: typing.List[float], doubleArray3: typing.List[float], doubleArray4: typing.List[typing.List[typing.List[float]]], doubleArray5: typing.List[typing.List[typing.List[float]]], doubleArray6: typing.List[typing.List[typing.List[float]]], doubleArray7: typing.List[typing.List[typing.List[float]]], doubleArray8: typing.List[typing.List[typing.List[float]]], doubleArray9: typing.List[typing.List[typing.List[float]]], doubleArray10: typing.List[typing.List[typing.List[float]]], doubleArray11: typing.List[typing.List[typing.List[float]]]): ...
    def isValidPoint(self, double: float, double2: float, double3: float) -> bool: ...
    def value(self, double: float, double2: float, double3: float) -> float: ...

class TrivariateGridInterpolator:
    def interpolate(self, doubleArray: typing.List[float], doubleArray2: typing.List[float], doubleArray3: typing.List[float], doubleArray4: typing.List[typing.List[typing.List[float]]]) -> org.hipparchus.analysis.TrivariateFunction: ...

class UnivariateInterpolator:
    def interpolate(self, doubleArray: typing.List[float], doubleArray2: typing.List[float]) -> org.hipparchus.analysis.UnivariateFunction: ...

class AkimaSplineInterpolator(UnivariateInterpolator, FieldUnivariateInterpolator):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, boolean: bool): ...
    _interpolate_0__T = typing.TypeVar('_interpolate_0__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def interpolate(self, tArray: typing.List[_interpolate_0__T], tArray2: typing.List[_interpolate_0__T]) -> org.hipparchus.analysis.polynomials.FieldPolynomialSplineFunction[_interpolate_0__T]: ...
    @typing.overload
    def interpolate(self, doubleArray: typing.List[float], doubleArray2: typing.List[float]) -> org.hipparchus.analysis.polynomials.PolynomialSplineFunction: ...

class BicubicInterpolator(BivariateGridInterpolator):
    def __init__(self): ...
    def interpolate(self, doubleArray: typing.List[float], doubleArray2: typing.List[float], doubleArray3: typing.List[typing.List[float]]) -> BicubicInterpolatingFunction: ...

class BilinearInterpolator(BivariateGridInterpolator):
    def __init__(self): ...
    def interpolate(self, doubleArray: typing.List[float], doubleArray2: typing.List[float], doubleArray3: typing.List[typing.List[float]]) -> BilinearInterpolatingFunction: ...

class DividedDifferenceInterpolator(UnivariateInterpolator, java.io.Serializable):
    def __init__(self): ...
    def interpolate(self, doubleArray: typing.List[float], doubleArray2: typing.List[float]) -> org.hipparchus.analysis.polynomials.PolynomialFunctionNewtonForm: ...

class InterpolatingMicrosphere2D(InterpolatingMicrosphere):
    def __init__(self, int: int, double: float, double2: float, double3: float): ...
    def copy(self) -> 'InterpolatingMicrosphere2D': ...

class LinearInterpolator(UnivariateInterpolator, FieldUnivariateInterpolator):
    def __init__(self): ...
    _interpolate_0__T = typing.TypeVar('_interpolate_0__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def interpolate(self, tArray: typing.List[_interpolate_0__T], tArray2: typing.List[_interpolate_0__T]) -> org.hipparchus.analysis.polynomials.FieldPolynomialSplineFunction[_interpolate_0__T]: ...
    @typing.overload
    def interpolate(self, doubleArray: typing.List[float], doubleArray2: typing.List[float]) -> org.hipparchus.analysis.polynomials.PolynomialSplineFunction: ...

class LoessInterpolator(UnivariateInterpolator, java.io.Serializable):
    DEFAULT_BANDWIDTH: typing.ClassVar[float] = ...
    DEFAULT_ROBUSTNESS_ITERS: typing.ClassVar[int] = ...
    DEFAULT_ACCURACY: typing.ClassVar[float] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float, int: int): ...
    @typing.overload
    def __init__(self, double: float, int: int, double2: float): ...
    def interpolate(self, doubleArray: typing.List[float], doubleArray2: typing.List[float]) -> org.hipparchus.analysis.polynomials.PolynomialSplineFunction: ...
    @typing.overload
    def smooth(self, doubleArray: typing.List[float], doubleArray2: typing.List[float]) -> typing.List[float]: ...
    @typing.overload
    def smooth(self, doubleArray: typing.List[float], doubleArray2: typing.List[float], doubleArray3: typing.List[float]) -> typing.List[float]: ...

class MicrosphereProjectionInterpolator(MultivariateInterpolator):
    @typing.overload
    def __init__(self, int: int, int2: int, double: float, double2: float, double3: float, double4: float, boolean: bool, double5: float): ...
    @typing.overload
    def __init__(self, interpolatingMicrosphere: InterpolatingMicrosphere, double: float, boolean: bool, double2: float): ...
    def interpolate(self, doubleArray: typing.List[typing.List[float]], doubleArray2: typing.List[float]) -> org.hipparchus.analysis.MultivariateFunction: ...

class NevilleInterpolator(UnivariateInterpolator, java.io.Serializable):
    def __init__(self): ...
    def interpolate(self, doubleArray: typing.List[float], doubleArray2: typing.List[float]) -> org.hipparchus.analysis.polynomials.PolynomialFunctionLagrangeForm: ...

class PiecewiseBicubicSplineInterpolator(BivariateGridInterpolator):
    def __init__(self): ...
    def interpolate(self, doubleArray: typing.List[float], doubleArray2: typing.List[float], doubleArray3: typing.List[typing.List[float]]) -> PiecewiseBicubicSplineInterpolatingFunction: ...

class SplineInterpolator(UnivariateInterpolator, FieldUnivariateInterpolator):
    def __init__(self): ...
    _interpolate_0__T = typing.TypeVar('_interpolate_0__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def interpolate(self, tArray: typing.List[_interpolate_0__T], tArray2: typing.List[_interpolate_0__T]) -> org.hipparchus.analysis.polynomials.FieldPolynomialSplineFunction[_interpolate_0__T]: ...
    @typing.overload
    def interpolate(self, doubleArray: typing.List[float], doubleArray2: typing.List[float]) -> org.hipparchus.analysis.polynomials.PolynomialSplineFunction: ...

class TricubicInterpolator(TrivariateGridInterpolator):
    def __init__(self): ...
    def interpolate(self, doubleArray: typing.List[float], doubleArray2: typing.List[float], doubleArray3: typing.List[float], doubleArray4: typing.List[typing.List[typing.List[float]]]) -> TricubicInterpolatingFunction: ...

class UnivariatePeriodicInterpolator(UnivariateInterpolator):
    DEFAULT_EXTEND: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self, univariateInterpolator: UnivariateInterpolator, double: float): ...
    @typing.overload
    def __init__(self, univariateInterpolator: UnivariateInterpolator, double: float, int: int): ...
    def interpolate(self, doubleArray: typing.List[float], doubleArray2: typing.List[float]) -> org.hipparchus.analysis.UnivariateFunction: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.hipparchus.analysis.interpolation")``.

    AkimaSplineInterpolator: typing.Type[AkimaSplineInterpolator]
    BicubicInterpolatingFunction: typing.Type[BicubicInterpolatingFunction]
    BicubicInterpolator: typing.Type[BicubicInterpolator]
    BilinearInterpolatingFunction: typing.Type[BilinearInterpolatingFunction]
    BilinearInterpolator: typing.Type[BilinearInterpolator]
    BivariateGridInterpolator: typing.Type[BivariateGridInterpolator]
    DividedDifferenceInterpolator: typing.Type[DividedDifferenceInterpolator]
    FieldHermiteInterpolator: typing.Type[FieldHermiteInterpolator]
    FieldUnivariateInterpolator: typing.Type[FieldUnivariateInterpolator]
    GridAxis: typing.Type[GridAxis]
    HermiteInterpolator: typing.Type[HermiteInterpolator]
    InterpolatingMicrosphere: typing.Type[InterpolatingMicrosphere]
    InterpolatingMicrosphere2D: typing.Type[InterpolatingMicrosphere2D]
    LinearInterpolator: typing.Type[LinearInterpolator]
    LoessInterpolator: typing.Type[LoessInterpolator]
    MicrosphereProjectionInterpolator: typing.Type[MicrosphereProjectionInterpolator]
    MultivariateInterpolator: typing.Type[MultivariateInterpolator]
    NevilleInterpolator: typing.Type[NevilleInterpolator]
    PiecewiseBicubicSplineInterpolatingFunction: typing.Type[PiecewiseBicubicSplineInterpolatingFunction]
    PiecewiseBicubicSplineInterpolator: typing.Type[PiecewiseBicubicSplineInterpolator]
    SplineInterpolator: typing.Type[SplineInterpolator]
    TricubicInterpolatingFunction: typing.Type[TricubicInterpolatingFunction]
    TricubicInterpolator: typing.Type[TricubicInterpolator]
    TrivariateGridInterpolator: typing.Type[TrivariateGridInterpolator]
    UnivariateInterpolator: typing.Type[UnivariateInterpolator]
    UnivariatePeriodicInterpolator: typing.Type[UnivariatePeriodicInterpolator]
