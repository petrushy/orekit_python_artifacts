import java.io
import org
import org.hipparchus
import org.hipparchus.analysis
import org.hipparchus.analysis.differentiation
import typing



_FieldPolynomialFunction__T = typing.TypeVar('_FieldPolynomialFunction__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
class FieldPolynomialFunction(org.hipparchus.analysis.CalculusFieldUnivariateFunction[_FieldPolynomialFunction__T], typing.Generic[_FieldPolynomialFunction__T]):
    def __init__(self, tArray: typing.List[_FieldPolynomialFunction__T]): ...
    def add(self, fieldPolynomialFunction: 'FieldPolynomialFunction'[_FieldPolynomialFunction__T]) -> 'FieldPolynomialFunction'[_FieldPolynomialFunction__T]: ...
    def antiDerivative(self) -> 'FieldPolynomialFunction'[_FieldPolynomialFunction__T]: ...
    def degree(self) -> int: ...
    def getCoefficients(self) -> typing.List[_FieldPolynomialFunction__T]: ...
    def getField(self) -> org.hipparchus.Field[_FieldPolynomialFunction__T]: ...
    @typing.overload
    def integrate(self, double: float, double2: float) -> _FieldPolynomialFunction__T: ...
    @typing.overload
    def integrate(self, t: _FieldPolynomialFunction__T, t2: _FieldPolynomialFunction__T) -> _FieldPolynomialFunction__T: ...
    def multiply(self, fieldPolynomialFunction: 'FieldPolynomialFunction'[_FieldPolynomialFunction__T]) -> 'FieldPolynomialFunction'[_FieldPolynomialFunction__T]: ...
    def negate(self) -> 'FieldPolynomialFunction'[_FieldPolynomialFunction__T]: ...
    def polynomialDerivative(self) -> 'FieldPolynomialFunction'[_FieldPolynomialFunction__T]: ...
    def subtract(self, fieldPolynomialFunction: 'FieldPolynomialFunction'[_FieldPolynomialFunction__T]) -> 'FieldPolynomialFunction'[_FieldPolynomialFunction__T]: ...
    @typing.overload
    def value(self, double: float) -> _FieldPolynomialFunction__T: ...
    @typing.overload
    def value(self, t: _FieldPolynomialFunction__T) -> _FieldPolynomialFunction__T: ...

_FieldPolynomialSplineFunction__T = typing.TypeVar('_FieldPolynomialSplineFunction__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
class FieldPolynomialSplineFunction(org.hipparchus.analysis.CalculusFieldUnivariateFunction[_FieldPolynomialSplineFunction__T], typing.Generic[_FieldPolynomialSplineFunction__T]):
    def __init__(self, tArray: typing.List[_FieldPolynomialSplineFunction__T], fieldPolynomialFunctionArray: typing.List[FieldPolynomialFunction[_FieldPolynomialSplineFunction__T]]): ...
    def getField(self) -> org.hipparchus.Field[_FieldPolynomialSplineFunction__T]: ...
    def getKnots(self) -> typing.List[_FieldPolynomialSplineFunction__T]: ...
    def getN(self) -> int: ...
    def getPolynomials(self) -> typing.List[FieldPolynomialFunction[_FieldPolynomialSplineFunction__T]]: ...
    def isValidPoint(self, t: _FieldPolynomialSplineFunction__T) -> bool: ...
    def polynomialSplineDerivative(self) -> 'FieldPolynomialSplineFunction'[_FieldPolynomialSplineFunction__T]: ...
    @typing.overload
    def value(self, double: float) -> _FieldPolynomialSplineFunction__T: ...
    @typing.overload
    def value(self, t: _FieldPolynomialSplineFunction__T) -> _FieldPolynomialSplineFunction__T: ...

class JacobiKey:
    def __init__(self, int: int, int2: int): ...
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...

class PolynomialFunction(org.hipparchus.analysis.differentiation.UnivariateDifferentiableFunction, org.hipparchus.analysis.FieldUnivariateFunction, java.io.Serializable):
    def __init__(self, *double: float): ...
    def add(self, polynomialFunction: 'PolynomialFunction') -> 'PolynomialFunction': ...
    def antiDerivative(self) -> 'PolynomialFunction': ...
    def degree(self) -> int: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getCoefficients(self) -> typing.List[float]: ...
    def hashCode(self) -> int: ...
    def integrate(self, double: float, double2: float) -> float: ...
    def multiply(self, polynomialFunction: 'PolynomialFunction') -> 'PolynomialFunction': ...
    def negate(self) -> 'PolynomialFunction': ...
    def polynomialDerivative(self) -> 'PolynomialFunction': ...
    def subtract(self, polynomialFunction: 'PolynomialFunction') -> 'PolynomialFunction': ...
    def toString(self) -> str: ...
    _value_1__T = typing.TypeVar('_value_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _value_2__T = typing.TypeVar('_value_2__T', bound=org.hipparchus.analysis.differentiation.Derivative)  # <T>
    @typing.overload
    def value(self, double: float) -> float: ...
    @typing.overload
    def value(self, t: _value_1__T) -> _value_1__T: ...
    @typing.overload
    def value(self, t: _value_2__T) -> _value_2__T: ...
    class Parametric(org.hipparchus.analysis.ParametricUnivariateFunction):
        def __init__(self): ...
        def gradient(self, double: float, *double2: float) -> typing.List[float]: ...
        def value(self, double: float, *double2: float) -> float: ...

class PolynomialFunctionLagrangeForm(org.hipparchus.analysis.UnivariateFunction):
    def __init__(self, doubleArray: typing.List[float], doubleArray2: typing.List[float]): ...
    def degree(self) -> int: ...
    @staticmethod
    def evaluate(doubleArray: typing.List[float], doubleArray2: typing.List[float], double3: float) -> float: ...
    def getCoefficients(self) -> typing.List[float]: ...
    def getInterpolatingPoints(self) -> typing.List[float]: ...
    def getInterpolatingValues(self) -> typing.List[float]: ...
    def value(self, double: float) -> float: ...
    @staticmethod
    def verifyInterpolationArray(doubleArray: typing.List[float], doubleArray2: typing.List[float], boolean: bool) -> bool: ...

class PolynomialFunctionNewtonForm(org.hipparchus.analysis.differentiation.UnivariateDifferentiableFunction, org.hipparchus.analysis.FieldUnivariateFunction):
    def __init__(self, doubleArray: typing.List[float], doubleArray2: typing.List[float]): ...
    def degree(self) -> int: ...
    @staticmethod
    def evaluate(doubleArray: typing.List[float], doubleArray2: typing.List[float], double3: float) -> float: ...
    def getCenters(self) -> typing.List[float]: ...
    def getCoefficients(self) -> typing.List[float]: ...
    def getNewtonCoefficients(self) -> typing.List[float]: ...
    _value_1__T = typing.TypeVar('_value_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _value_2__T = typing.TypeVar('_value_2__T', bound=org.hipparchus.analysis.differentiation.Derivative)  # <T>
    @typing.overload
    def value(self, double: float) -> float: ...
    @typing.overload
    def value(self, t: _value_1__T) -> _value_1__T: ...
    @typing.overload
    def value(self, t: _value_2__T) -> _value_2__T: ...

class PolynomialSplineFunction(org.hipparchus.analysis.differentiation.UnivariateDifferentiableFunction, org.hipparchus.analysis.FieldUnivariateFunction):
    def __init__(self, doubleArray: typing.List[float], polynomialFunctionArray: typing.List[PolynomialFunction]): ...
    def getKnots(self) -> typing.List[float]: ...
    def getN(self) -> int: ...
    def getPolynomials(self) -> typing.List[PolynomialFunction]: ...
    def isValidPoint(self, double: float) -> bool: ...
    def polynomialSplineDerivative(self) -> 'PolynomialSplineFunction': ...
    _value_1__T = typing.TypeVar('_value_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _value_2__T = typing.TypeVar('_value_2__T', bound=org.hipparchus.analysis.differentiation.Derivative)  # <T>
    @typing.overload
    def value(self, double: float) -> float: ...
    @typing.overload
    def value(self, t: _value_1__T) -> _value_1__T: ...
    @typing.overload
    def value(self, t: _value_2__T) -> _value_2__T: ...

class PolynomialsUtils:
    @staticmethod
    def createChebyshevPolynomial(int: int) -> PolynomialFunction: ...
    @staticmethod
    def createHermitePolynomial(int: int) -> PolynomialFunction: ...
    @staticmethod
    def createJacobiPolynomial(int: int, int2: int, int3: int) -> PolynomialFunction: ...
    @staticmethod
    def createLaguerrePolynomial(int: int) -> PolynomialFunction: ...
    @staticmethod
    def createLegendrePolynomial(int: int) -> PolynomialFunction: ...
    @staticmethod
    def shift(doubleArray: typing.List[float], double2: float) -> typing.List[float]: ...

_SmoothStepFactory__FieldSmoothStepFunction__T = typing.TypeVar('_SmoothStepFactory__FieldSmoothStepFunction__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
class SmoothStepFactory:
    @staticmethod
    def checkBetweenZeroAndOneIncluded(double: float) -> None: ...
    _getClamp_0__T = typing.TypeVar('_getClamp_0__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def getClamp(field: org.hipparchus.Field[_getClamp_0__T]) -> 'SmoothStepFactory.FieldSmoothStepFunction'[_getClamp_0__T]: ...
    @typing.overload
    @staticmethod
    def getClamp() -> 'SmoothStepFactory.SmoothStepFunction': ...
    _getCubic_0__T = typing.TypeVar('_getCubic_0__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def getCubic(field: org.hipparchus.Field[_getCubic_0__T]) -> 'SmoothStepFactory.FieldSmoothStepFunction'[_getCubic_0__T]: ...
    @typing.overload
    @staticmethod
    def getCubic() -> 'SmoothStepFactory.SmoothStepFunction': ...
    _getFieldGeneralOrder__T = typing.TypeVar('_getFieldGeneralOrder__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @staticmethod
    def getFieldGeneralOrder(field: org.hipparchus.Field[_getFieldGeneralOrder__T], int: int) -> 'SmoothStepFactory.FieldSmoothStepFunction'[_getFieldGeneralOrder__T]: ...
    @staticmethod
    def getGeneralOrder(int: int) -> 'SmoothStepFactory.SmoothStepFunction': ...
    _getQuadratic_0__T = typing.TypeVar('_getQuadratic_0__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def getQuadratic(field: org.hipparchus.Field[_getQuadratic_0__T]) -> 'SmoothStepFactory.FieldSmoothStepFunction'[_getQuadratic_0__T]: ...
    @typing.overload
    @staticmethod
    def getQuadratic() -> 'SmoothStepFactory.SmoothStepFunction': ...
    _getQuintic_0__T = typing.TypeVar('_getQuintic_0__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def getQuintic(field: org.hipparchus.Field[_getQuintic_0__T]) -> 'SmoothStepFactory.FieldSmoothStepFunction'[_getQuintic_0__T]: ...
    @typing.overload
    @staticmethod
    def getQuintic() -> 'SmoothStepFactory.SmoothStepFunction': ...
    class FieldSmoothStepFunction(FieldPolynomialFunction[_SmoothStepFactory__FieldSmoothStepFunction__T], typing.Generic[_SmoothStepFactory__FieldSmoothStepFunction__T]):
        @typing.overload
        def value(self, double: float) -> _SmoothStepFactory__FieldSmoothStepFunction__T: ...
        @typing.overload
        def value(self, double: float, double2: float, t: _SmoothStepFactory__FieldSmoothStepFunction__T) -> _SmoothStepFactory__FieldSmoothStepFunction__T: ...
        @typing.overload
        def value(self, t: _SmoothStepFactory__FieldSmoothStepFunction__T) -> _SmoothStepFactory__FieldSmoothStepFunction__T: ...
    class QuadraticSmoothStepFunction(org.hipparchus.analysis.polynomials.SmoothStepFactory.SmoothStepFunction):
        _value_2__T = typing.TypeVar('_value_2__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
        _value_3__T = typing.TypeVar('_value_3__T', bound=org.hipparchus.analysis.differentiation.Derivative)  # <T>
        @typing.overload
        def value(self, double: float) -> float: ...
        @typing.overload
        def value(self, double: float, double2: float, double3: float) -> float: ...
        @typing.overload
        def value(self, t: _value_2__T) -> _value_2__T: ...
        @typing.overload
        def value(self, t: _value_3__T) -> _value_3__T: ...
    class SmoothStepFunction(PolynomialFunction):
        _value_2__T = typing.TypeVar('_value_2__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
        _value_3__T = typing.TypeVar('_value_3__T', bound=org.hipparchus.analysis.differentiation.Derivative)  # <T>
        @typing.overload
        def value(self, double: float) -> float: ...
        @typing.overload
        def value(self, double: float, double2: float, double3: float) -> float: ...
        @typing.overload
        def value(self, t: _value_2__T) -> _value_2__T: ...
        @typing.overload
        def value(self, t: _value_3__T) -> _value_3__T: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.hipparchus.analysis.polynomials")``.

    FieldPolynomialFunction: typing.Type[FieldPolynomialFunction]
    FieldPolynomialSplineFunction: typing.Type[FieldPolynomialSplineFunction]
    JacobiKey: typing.Type[JacobiKey]
    PolynomialFunction: typing.Type[PolynomialFunction]
    PolynomialFunctionLagrangeForm: typing.Type[PolynomialFunctionLagrangeForm]
    PolynomialFunctionNewtonForm: typing.Type[PolynomialFunctionNewtonForm]
    PolynomialSplineFunction: typing.Type[PolynomialSplineFunction]
    PolynomialsUtils: typing.Type[PolynomialsUtils]
    SmoothStepFactory: typing.Type[SmoothStepFactory]
