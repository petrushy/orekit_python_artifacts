import java.io
import java.lang
import java.util
import org.hipparchus.analysis
import org.hipparchus.linear
import org.hipparchus.optim
import org.hipparchus.optim.nonlinear.scalar
import typing



class LinearConstraint(java.io.Serializable):
    @typing.overload
    def __init__(self, doubleArray: typing.List[float], double2: float, relationship: 'Relationship', doubleArray2: typing.List[float], double4: float): ...
    @typing.overload
    def __init__(self, doubleArray: typing.List[float], relationship: 'Relationship', double2: float): ...
    @typing.overload
    def __init__(self, realVector: org.hipparchus.linear.RealVector, double: float, relationship: 'Relationship', realVector2: org.hipparchus.linear.RealVector, double2: float): ...
    @typing.overload
    def __init__(self, realVector: org.hipparchus.linear.RealVector, relationship: 'Relationship', double: float): ...
    def equals(self, object: typing.Any) -> bool: ...
    def getCoefficients(self) -> org.hipparchus.linear.RealVector: ...
    def getRelationship(self) -> 'Relationship': ...
    def getValue(self) -> float: ...
    def hashCode(self) -> int: ...

class LinearConstraintSet(org.hipparchus.optim.OptimizationData):
    @typing.overload
    def __init__(self, collection: typing.Union[java.util.Collection[LinearConstraint], typing.Sequence[LinearConstraint], typing.Set[LinearConstraint]]): ...
    @typing.overload
    def __init__(self, *linearConstraint: LinearConstraint): ...
    def getConstraints(self) -> java.util.Collection[LinearConstraint]: ...

class LinearObjectiveFunction(org.hipparchus.analysis.MultivariateFunction, org.hipparchus.optim.OptimizationData, java.io.Serializable):
    @typing.overload
    def __init__(self, doubleArray: typing.List[float], double2: float): ...
    @typing.overload
    def __init__(self, realVector: org.hipparchus.linear.RealVector, double: float): ...
    def equals(self, object: typing.Any) -> bool: ...
    def getCoefficients(self) -> org.hipparchus.linear.RealVector: ...
    def getConstantTerm(self) -> float: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def value(self, doubleArray: typing.List[float]) -> float: ...
    @typing.overload
    def value(self, realVector: org.hipparchus.linear.RealVector) -> float: ...

class LinearOptimizer(org.hipparchus.optim.nonlinear.scalar.MultivariateOptimizer):
    @typing.overload
    def optimize(self) -> typing.Any: ...
    @typing.overload
    def optimize(self, *optimizationData: org.hipparchus.optim.OptimizationData) -> org.hipparchus.optim.PointValuePair: ...

class NonNegativeConstraint(org.hipparchus.optim.OptimizationData):
    def __init__(self, boolean: bool): ...
    def isRestrictedToNonNegative(self) -> bool: ...

class PivotSelectionRule(java.lang.Enum['PivotSelectionRule'], org.hipparchus.optim.OptimizationData):
    DANTZIG: typing.ClassVar['PivotSelectionRule'] = ...
    BLAND: typing.ClassVar['PivotSelectionRule'] = ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'PivotSelectionRule': ...
    @staticmethod
    def values() -> typing.List['PivotSelectionRule']: ...

class Relationship(java.lang.Enum['Relationship']):
    EQ: typing.ClassVar['Relationship'] = ...
    LEQ: typing.ClassVar['Relationship'] = ...
    GEQ: typing.ClassVar['Relationship'] = ...
    def oppositeRelationship(self) -> 'Relationship': ...
    def toString(self) -> str: ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'Relationship': ...
    @staticmethod
    def values() -> typing.List['Relationship']: ...

class SolutionCallback(org.hipparchus.optim.OptimizationData):
    def __init__(self): ...
    def getSolution(self) -> org.hipparchus.optim.PointValuePair: ...
    def isSolutionOptimal(self) -> bool: ...

class SimplexSolver(LinearOptimizer):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float): ...
    @typing.overload
    def __init__(self, double: float, int: int): ...
    @typing.overload
    def __init__(self, double: float, int: int, double2: float): ...
    def doOptimize(self) -> org.hipparchus.optim.PointValuePair: ...
    @typing.overload
    def optimize(self) -> typing.Any: ...
    @typing.overload
    def optimize(self, *optimizationData: org.hipparchus.optim.OptimizationData) -> org.hipparchus.optim.PointValuePair: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.hipparchus.optim.linear")``.

    LinearConstraint: typing.Type[LinearConstraint]
    LinearConstraintSet: typing.Type[LinearConstraintSet]
    LinearObjectiveFunction: typing.Type[LinearObjectiveFunction]
    LinearOptimizer: typing.Type[LinearOptimizer]
    NonNegativeConstraint: typing.Type[NonNegativeConstraint]
    PivotSelectionRule: typing.Type[PivotSelectionRule]
    Relationship: typing.Type[Relationship]
    SimplexSolver: typing.Type[SimplexSolver]
    SolutionCallback: typing.Type[SolutionCallback]
