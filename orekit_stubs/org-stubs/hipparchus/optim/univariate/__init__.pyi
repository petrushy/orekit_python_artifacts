import java.io
import org.hipparchus.analysis
import org.hipparchus.optim
import org.hipparchus.optim.nonlinear.scalar
import org.hipparchus.random
import typing



class BracketFinder:
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float, int: int): ...
    def getEvaluations(self) -> int: ...
    def getFHi(self) -> float: ...
    def getFLo(self) -> float: ...
    def getFMid(self) -> float: ...
    def getHi(self) -> float: ...
    def getLo(self) -> float: ...
    def getMaxEvaluations(self) -> int: ...
    def getMid(self) -> float: ...
    def search(self, univariateFunction: org.hipparchus.analysis.UnivariateFunction, goalType: org.hipparchus.optim.nonlinear.scalar.GoalType, double: float, double2: float) -> None: ...

class SearchInterval(org.hipparchus.optim.OptimizationData):
    @typing.overload
    def __init__(self, double: float, double2: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float): ...
    def getMax(self) -> float: ...
    def getMin(self) -> float: ...
    def getStartValue(self) -> float: ...

class SimpleUnivariateValueChecker(org.hipparchus.optim.AbstractConvergenceChecker['UnivariatePointValuePair']):
    @typing.overload
    def __init__(self, double: float, double2: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float, int: int): ...
    def converged(self, int: int, univariatePointValuePair: 'UnivariatePointValuePair', univariatePointValuePair2: 'UnivariatePointValuePair') -> bool: ...

class UnivariateObjectiveFunction(org.hipparchus.optim.OptimizationData):
    def __init__(self, univariateFunction: org.hipparchus.analysis.UnivariateFunction): ...
    def getObjectiveFunction(self) -> org.hipparchus.analysis.UnivariateFunction: ...

class UnivariateOptimizer(org.hipparchus.optim.BaseOptimizer['UnivariatePointValuePair']):
    def getGoalType(self) -> org.hipparchus.optim.nonlinear.scalar.GoalType: ...
    def getMax(self) -> float: ...
    def getMin(self) -> float: ...
    def getStartValue(self) -> float: ...
    @typing.overload
    def optimize(self) -> typing.Any: ...
    @typing.overload
    def optimize(self, *optimizationData: org.hipparchus.optim.OptimizationData) -> 'UnivariatePointValuePair': ...

class UnivariatePointValuePair(java.io.Serializable):
    def __init__(self, double: float, double2: float): ...
    def getPoint(self) -> float: ...
    def getValue(self) -> float: ...

class BrentOptimizer(UnivariateOptimizer):
    @typing.overload
    def __init__(self, double: float, double2: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float, convergenceChecker: org.hipparchus.optim.ConvergenceChecker[UnivariatePointValuePair]): ...

class MultiStartUnivariateOptimizer(UnivariateOptimizer):
    def __init__(self, univariateOptimizer: UnivariateOptimizer, int: int, randomGenerator: org.hipparchus.random.RandomGenerator): ...
    def getEvaluations(self) -> int: ...
    def getOptima(self) -> typing.List[UnivariatePointValuePair]: ...
    @typing.overload
    def optimize(self) -> typing.Any: ...
    @typing.overload
    def optimize(self, *optimizationData: org.hipparchus.optim.OptimizationData) -> UnivariatePointValuePair: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.hipparchus.optim.univariate")``.

    BracketFinder: typing.Type[BracketFinder]
    BrentOptimizer: typing.Type[BrentOptimizer]
    MultiStartUnivariateOptimizer: typing.Type[MultiStartUnivariateOptimizer]
    SearchInterval: typing.Type[SearchInterval]
    SimpleUnivariateValueChecker: typing.Type[SimpleUnivariateValueChecker]
    UnivariateObjectiveFunction: typing.Type[UnivariateObjectiveFunction]
    UnivariateOptimizer: typing.Type[UnivariateOptimizer]
    UnivariatePointValuePair: typing.Type[UnivariatePointValuePair]
