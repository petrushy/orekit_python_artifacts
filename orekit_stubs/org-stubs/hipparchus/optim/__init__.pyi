import java.io
import java.lang
import java.util
import org.hipparchus.exception
import org.hipparchus.optim.linear
import org.hipparchus.optim.nonlinear
import org.hipparchus.optim.univariate
import org.hipparchus.random
import org.hipparchus.util
import typing



_BaseOptimizer__P = typing.TypeVar('_BaseOptimizer__P')  # <P>
class BaseOptimizer(typing.Generic[_BaseOptimizer__P]):
    def getConvergenceChecker(self) -> 'ConvergenceChecker'[_BaseOptimizer__P]: ...
    def getEvaluations(self) -> int: ...
    def getIterations(self) -> int: ...
    def getMaxEvaluations(self) -> int: ...
    def getMaxIterations(self) -> int: ...
    @typing.overload
    def optimize(self) -> _BaseOptimizer__P: ...
    @typing.overload
    def optimize(self, *optimizationData: 'OptimizationData') -> _BaseOptimizer__P: ...

_ConvergenceChecker__P = typing.TypeVar('_ConvergenceChecker__P')  # <P>
class ConvergenceChecker(typing.Generic[_ConvergenceChecker__P]):
    def converged(self, int: int, p: _ConvergenceChecker__P, p2: _ConvergenceChecker__P) -> bool: ...

class LocalizedOptimFormats(java.lang.Enum['LocalizedOptimFormats'], org.hipparchus.exception.Localizable):
    EQUAL_VERTICES_IN_SIMPLEX: typing.ClassVar['LocalizedOptimFormats'] = ...
    INVALID_IMPLEMENTATION: typing.ClassVar['LocalizedOptimFormats'] = ...
    NO_FEASIBLE_SOLUTION: typing.ClassVar['LocalizedOptimFormats'] = ...
    SIMPLEX_NEED_ONE_POINT: typing.ClassVar['LocalizedOptimFormats'] = ...
    TOO_SMALL_COST_RELATIVE_TOLERANCE: typing.ClassVar['LocalizedOptimFormats'] = ...
    TOO_SMALL_ORTHOGONALITY_TOLERANCE: typing.ClassVar['LocalizedOptimFormats'] = ...
    TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE: typing.ClassVar['LocalizedOptimFormats'] = ...
    TRUST_REGION_STEP_FAILED: typing.ClassVar['LocalizedOptimFormats'] = ...
    UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN: typing.ClassVar['LocalizedOptimFormats'] = ...
    UNABLE_TO_SOLVE_SINGULAR_PROBLEM: typing.ClassVar['LocalizedOptimFormats'] = ...
    UNBOUNDED_SOLUTION: typing.ClassVar['LocalizedOptimFormats'] = ...
    CONSTRAINTS_RANK: typing.ClassVar['LocalizedOptimFormats'] = ...
    def getLocalizedString(self, locale: java.util.Locale) -> str: ...
    def getSourceString(self) -> str: ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'LocalizedOptimFormats': ...
    @staticmethod
    def values() -> typing.List['LocalizedOptimFormats']: ...

class OptimizationData: ...

_OptimizationProblem__P = typing.TypeVar('_OptimizationProblem__P')  # <P>
class OptimizationProblem(typing.Generic[_OptimizationProblem__P]):
    def getConvergenceChecker(self) -> ConvergenceChecker[_OptimizationProblem__P]: ...
    def getEvaluationCounter(self) -> org.hipparchus.util.Incrementor: ...
    def getIterationCounter(self) -> org.hipparchus.util.Incrementor: ...

class PointValuePair(org.hipparchus.util.Pair[typing.List[float], float], java.io.Serializable):
    @typing.overload
    def __init__(self, doubleArray: typing.List[float], double2: float): ...
    @typing.overload
    def __init__(self, doubleArray: typing.List[float], double2: float, boolean: bool): ...
    def getPoint(self) -> typing.List[float]: ...
    def getPointRef(self) -> typing.List[float]: ...

class PointVectorValuePair(org.hipparchus.util.Pair[typing.List[float], typing.List[float]], java.io.Serializable):
    @typing.overload
    def __init__(self, doubleArray: typing.List[float], doubleArray2: typing.List[float]): ...
    @typing.overload
    def __init__(self, doubleArray: typing.List[float], doubleArray2: typing.List[float], boolean: bool): ...
    def getPoint(self) -> typing.List[float]: ...
    def getPointRef(self) -> typing.List[float]: ...
    def getValue(self) -> typing.List[float]: ...
    def getValueRef(self) -> typing.List[float]: ...

_AbstractConvergenceChecker__P = typing.TypeVar('_AbstractConvergenceChecker__P')  # <P>
class AbstractConvergenceChecker(ConvergenceChecker[_AbstractConvergenceChecker__P], typing.Generic[_AbstractConvergenceChecker__P]):
    def __init__(self, double: float, double2: float): ...
    def converged(self, int: int, p: _AbstractConvergenceChecker__P, p2: _AbstractConvergenceChecker__P) -> bool: ...
    def getAbsoluteThreshold(self) -> float: ...
    def getRelativeThreshold(self) -> float: ...

_AbstractOptimizationProblem__P = typing.TypeVar('_AbstractOptimizationProblem__P')  # <P>
class AbstractOptimizationProblem(OptimizationProblem[_AbstractOptimizationProblem__P], typing.Generic[_AbstractOptimizationProblem__P]):
    def getConvergenceChecker(self) -> ConvergenceChecker[_AbstractOptimizationProblem__P]: ...
    def getEvaluationCounter(self) -> org.hipparchus.util.Incrementor: ...
    def getIterationCounter(self) -> org.hipparchus.util.Incrementor: ...

_BaseMultivariateOptimizer__P = typing.TypeVar('_BaseMultivariateOptimizer__P')  # <P>
class BaseMultivariateOptimizer(BaseOptimizer[_BaseMultivariateOptimizer__P], typing.Generic[_BaseMultivariateOptimizer__P]):
    def getLowerBound(self) -> typing.List[float]: ...
    def getStartPoint(self) -> typing.List[float]: ...
    def getUpperBound(self) -> typing.List[float]: ...
    @typing.overload
    def optimize(self, *optimizationData: OptimizationData) -> _BaseMultivariateOptimizer__P: ...
    @typing.overload
    def optimize(self) -> _BaseMultivariateOptimizer__P: ...

_ConvergenceCheckerAndMultiplexer__P = typing.TypeVar('_ConvergenceCheckerAndMultiplexer__P')  # <P>
class ConvergenceCheckerAndMultiplexer(ConvergenceChecker[_ConvergenceCheckerAndMultiplexer__P], typing.Generic[_ConvergenceCheckerAndMultiplexer__P]):
    def __init__(self, list: java.util.List[ConvergenceChecker[_ConvergenceCheckerAndMultiplexer__P]]): ...
    def converged(self, int: int, p: _ConvergenceCheckerAndMultiplexer__P, p2: _ConvergenceCheckerAndMultiplexer__P) -> bool: ...

_ConvergenceCheckerOrMultiplexer__P = typing.TypeVar('_ConvergenceCheckerOrMultiplexer__P')  # <P>
class ConvergenceCheckerOrMultiplexer(ConvergenceChecker[_ConvergenceCheckerOrMultiplexer__P], typing.Generic[_ConvergenceCheckerOrMultiplexer__P]):
    def __init__(self, list: java.util.List[ConvergenceChecker[_ConvergenceCheckerOrMultiplexer__P]]): ...
    def converged(self, int: int, p: _ConvergenceCheckerOrMultiplexer__P, p2: _ConvergenceCheckerOrMultiplexer__P) -> bool: ...

class InitialGuess(OptimizationData):
    def __init__(self, doubleArray: typing.List[float]): ...
    def getInitialGuess(self) -> typing.List[float]: ...

class MaxEval(OptimizationData):
    def __init__(self, int: int): ...
    def getMaxEval(self) -> int: ...
    @staticmethod
    def unlimited() -> 'MaxEval': ...

class MaxIter(OptimizationData):
    def __init__(self, int: int): ...
    def getMaxIter(self) -> int: ...
    @staticmethod
    def unlimited() -> 'MaxIter': ...

class SimpleBounds(OptimizationData):
    def __init__(self, doubleArray: typing.List[float], doubleArray2: typing.List[float]): ...
    def getLower(self) -> typing.List[float]: ...
    def getUpper(self) -> typing.List[float]: ...
    @staticmethod
    def unbounded(int: int) -> 'SimpleBounds': ...

_BaseMultiStartMultivariateOptimizer__P = typing.TypeVar('_BaseMultiStartMultivariateOptimizer__P')  # <P>
class BaseMultiStartMultivariateOptimizer(BaseMultivariateOptimizer[_BaseMultiStartMultivariateOptimizer__P], typing.Generic[_BaseMultiStartMultivariateOptimizer__P]):
    def __init__(self, baseMultivariateOptimizer: BaseMultivariateOptimizer[_BaseMultiStartMultivariateOptimizer__P], int: int, randomVectorGenerator: org.hipparchus.random.RandomVectorGenerator): ...
    def getEvaluations(self) -> int: ...
    def getOptima(self) -> typing.List[_BaseMultiStartMultivariateOptimizer__P]: ...
    @typing.overload
    def optimize(self, *optimizationData: OptimizationData) -> _BaseMultiStartMultivariateOptimizer__P: ...
    @typing.overload
    def optimize(self) -> _BaseMultiStartMultivariateOptimizer__P: ...

_SimplePointChecker__P = typing.TypeVar('_SimplePointChecker__P', bound=org.hipparchus.util.Pair)  # <P>
class SimplePointChecker(AbstractConvergenceChecker[_SimplePointChecker__P], typing.Generic[_SimplePointChecker__P]):
    @typing.overload
    def __init__(self, double: float, double2: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float, int: int): ...
    def converged(self, int: int, p: _SimplePointChecker__P, p2: _SimplePointChecker__P) -> bool: ...

class SimpleValueChecker(AbstractConvergenceChecker[PointValuePair]):
    @typing.overload
    def __init__(self, double: float, double2: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float, int: int): ...
    def converged(self, int: int, pointValuePair: PointValuePair, pointValuePair2: PointValuePair) -> bool: ...

class SimpleVectorValueChecker(AbstractConvergenceChecker[PointVectorValuePair]):
    @typing.overload
    def __init__(self, double: float, double2: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float, int: int): ...
    def converged(self, int: int, pointVectorValuePair: PointVectorValuePair, pointVectorValuePair2: PointVectorValuePair) -> bool: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.hipparchus.optim")``.

    AbstractConvergenceChecker: typing.Type[AbstractConvergenceChecker]
    AbstractOptimizationProblem: typing.Type[AbstractOptimizationProblem]
    BaseMultiStartMultivariateOptimizer: typing.Type[BaseMultiStartMultivariateOptimizer]
    BaseMultivariateOptimizer: typing.Type[BaseMultivariateOptimizer]
    BaseOptimizer: typing.Type[BaseOptimizer]
    ConvergenceChecker: typing.Type[ConvergenceChecker]
    ConvergenceCheckerAndMultiplexer: typing.Type[ConvergenceCheckerAndMultiplexer]
    ConvergenceCheckerOrMultiplexer: typing.Type[ConvergenceCheckerOrMultiplexer]
    InitialGuess: typing.Type[InitialGuess]
    LocalizedOptimFormats: typing.Type[LocalizedOptimFormats]
    MaxEval: typing.Type[MaxEval]
    MaxIter: typing.Type[MaxIter]
    OptimizationData: typing.Type[OptimizationData]
    OptimizationProblem: typing.Type[OptimizationProblem]
    PointValuePair: typing.Type[PointValuePair]
    PointVectorValuePair: typing.Type[PointVectorValuePair]
    SimpleBounds: typing.Type[SimpleBounds]
    SimplePointChecker: typing.Type[SimplePointChecker]
    SimpleValueChecker: typing.Type[SimpleValueChecker]
    SimpleVectorValueChecker: typing.Type[SimpleVectorValueChecker]
    linear: org.hipparchus.optim.linear.__module_protocol__
    nonlinear: org.hipparchus.optim.nonlinear.__module_protocol__
    univariate: org.hipparchus.optim.univariate.__module_protocol__
