import java.lang
import org.hipparchus.analysis
import org.hipparchus.linear
import org.hipparchus.optim
import org.hipparchus.optim.nonlinear.scalar.class-use
import org.hipparchus.optim.nonlinear.scalar.gradient
import org.hipparchus.optim.nonlinear.scalar.noderiv
import org.hipparchus.optim.univariate
import org.hipparchus.random
import typing



class GoalType(java.lang.Enum['GoalType'], org.hipparchus.optim.OptimizationData):
    MAXIMIZE: typing.ClassVar['GoalType'] = ...
    MINIMIZE: typing.ClassVar['GoalType'] = ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'GoalType': ...
    @staticmethod
    def values() -> typing.List['GoalType']: ...

class LeastSquaresConverter(org.hipparchus.analysis.MultivariateFunction):
    @typing.overload
    def __init__(self, multivariateVectorFunction: org.hipparchus.analysis.MultivariateVectorFunction, doubleArray: typing.List[float]): ...
    @typing.overload
    def __init__(self, multivariateVectorFunction: org.hipparchus.analysis.MultivariateVectorFunction, doubleArray: typing.List[float], doubleArray2: typing.List[float]): ...
    @typing.overload
    def __init__(self, multivariateVectorFunction: org.hipparchus.analysis.MultivariateVectorFunction, doubleArray: typing.List[float], realMatrix: org.hipparchus.linear.RealMatrix): ...
    def value(self, doubleArray: typing.List[float]) -> float: ...

class LineSearch:
    def __init__(self, multivariateOptimizer: 'MultivariateOptimizer', double: float, double2: float, double3: float): ...
    def search(self, doubleArray: typing.List[float], doubleArray2: typing.List[float]) -> org.hipparchus.optim.univariate.UnivariatePointValuePair: ...

class MultiStartMultivariateOptimizer(org.hipparchus.optim.BaseMultiStartMultivariateOptimizer[org.hipparchus.optim.PointValuePair]):
    def __init__(self, multivariateOptimizer: 'MultivariateOptimizer', int: int, randomVectorGenerator: org.hipparchus.random.RandomVectorGenerator): ...
    def getOptima(self) -> typing.List[org.hipparchus.optim.PointValuePair]: ...

class MultivariateFunctionMappingAdapter(org.hipparchus.analysis.MultivariateFunction):
    def __init__(self, multivariateFunction: org.hipparchus.analysis.MultivariateFunction, doubleArray: typing.List[float], doubleArray2: typing.List[float]): ...
    def boundedToUnbounded(self, doubleArray: typing.List[float]) -> typing.List[float]: ...
    def unboundedToBounded(self, doubleArray: typing.List[float]) -> typing.List[float]: ...
    def value(self, doubleArray: typing.List[float]) -> float: ...

class MultivariateFunctionPenaltyAdapter(org.hipparchus.analysis.MultivariateFunction):
    def __init__(self, multivariateFunction: org.hipparchus.analysis.MultivariateFunction, doubleArray: typing.List[float], doubleArray2: typing.List[float], double3: float, doubleArray3: typing.List[float]): ...
    def value(self, doubleArray: typing.List[float]) -> float: ...

class MultivariateOptimizer(org.hipparchus.optim.BaseMultivariateOptimizer[org.hipparchus.optim.PointValuePair]):
    def computeObjectiveValue(self, doubleArray: typing.List[float]) -> float: ...
    def getGoalType(self) -> GoalType: ...
    @typing.overload
    def optimize(self) -> typing.Any: ...
    @typing.overload
    def optimize(self, optimizationDataArray: typing.List[org.hipparchus.optim.OptimizationData]) -> org.hipparchus.optim.PointValuePair: ...

class ObjectiveFunction(org.hipparchus.optim.OptimizationData):
    def __init__(self, multivariateFunction: org.hipparchus.analysis.MultivariateFunction): ...
    def getObjectiveFunction(self) -> org.hipparchus.analysis.MultivariateFunction: ...

class ObjectiveFunctionGradient(org.hipparchus.optim.OptimizationData):
    def __init__(self, multivariateVectorFunction: org.hipparchus.analysis.MultivariateVectorFunction): ...
    def getObjectiveFunctionGradient(self) -> org.hipparchus.analysis.MultivariateVectorFunction: ...

class GradientMultivariateOptimizer(MultivariateOptimizer):
    @typing.overload
    def optimize(self) -> typing.Any: ...
    @typing.overload
    def optimize(self, optimizationDataArray: typing.List[org.hipparchus.optim.OptimizationData]) -> org.hipparchus.optim.PointValuePair: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.hipparchus.optim.nonlinear.scalar")``.

    GoalType: typing.Type[GoalType]
    GradientMultivariateOptimizer: typing.Type[GradientMultivariateOptimizer]
    LeastSquaresConverter: typing.Type[LeastSquaresConverter]
    LineSearch: typing.Type[LineSearch]
    MultiStartMultivariateOptimizer: typing.Type[MultiStartMultivariateOptimizer]
    MultivariateFunctionMappingAdapter: typing.Type[MultivariateFunctionMappingAdapter]
    MultivariateFunctionPenaltyAdapter: typing.Type[MultivariateFunctionPenaltyAdapter]
    MultivariateOptimizer: typing.Type[MultivariateOptimizer]
    ObjectiveFunction: typing.Type[ObjectiveFunction]
    ObjectiveFunctionGradient: typing.Type[ObjectiveFunctionGradient]
    class-use: org.hipparchus.optim.nonlinear.scalar.class-use.__module_protocol__
    gradient: org.hipparchus.optim.nonlinear.scalar.gradient.__module_protocol__
    noderiv: org.hipparchus.optim.nonlinear.scalar.noderiv.__module_protocol__
