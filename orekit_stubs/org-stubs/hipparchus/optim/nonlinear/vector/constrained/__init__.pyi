import org.hipparchus.analysis
import org.hipparchus.linear
import org.hipparchus.optim
import typing



class ADMMQPConvergenceChecker(org.hipparchus.optim.ConvergenceChecker['LagrangeSolution'], org.hipparchus.optim.OptimizationData):
    @typing.overload
    def converged(self, double: float, double2: float, double3: float, double4: float) -> bool: ...
    @typing.overload
    def converged(self, int: int, lagrangeSolution: 'LagrangeSolution', lagrangeSolution2: 'LagrangeSolution') -> bool: ...
    def maxDual(self, realVector: org.hipparchus.linear.RealVector, realVector2: org.hipparchus.linear.RealVector) -> float: ...
    def maxPrimal(self, realVector: org.hipparchus.linear.RealVector, realVector2: org.hipparchus.linear.RealVector) -> float: ...
    def residualDual(self, realVector: org.hipparchus.linear.RealVector, realVector2: org.hipparchus.linear.RealVector) -> float: ...
    def residualPrime(self, realVector: org.hipparchus.linear.RealVector, realVector2: org.hipparchus.linear.RealVector) -> float: ...

class ADMMQPModifiedRuizEquilibrium:
    def __init__(self, realMatrix: org.hipparchus.linear.RealMatrix, realMatrix2: org.hipparchus.linear.RealMatrix, realVector: org.hipparchus.linear.RealVector): ...
    def getScaledA(self) -> org.hipparchus.linear.RealMatrix: ...
    def getScaledH(self) -> org.hipparchus.linear.RealMatrix: ...
    def getScaledLUb(self, realVector: org.hipparchus.linear.RealVector) -> org.hipparchus.linear.RealVector: ...
    def getScaledQ(self) -> org.hipparchus.linear.RealVector: ...
    def normalize(self, double: float, int: int) -> None: ...
    def unscaleX(self, realVector: org.hipparchus.linear.RealVector) -> org.hipparchus.linear.RealVector: ...
    def unscaleY(self, realVector: org.hipparchus.linear.RealVector) -> org.hipparchus.linear.RealVector: ...
    def unscaleZ(self, realVector: org.hipparchus.linear.RealVector) -> org.hipparchus.linear.RealVector: ...

class ADMMQPOption(org.hipparchus.optim.OptimizationData):
    DEFAULT_EPS: typing.ClassVar[float] = ...
    DEFAULT_EPS_INFEASIBLE: typing.ClassVar[float] = ...
    DEFAULT_SIGMA: typing.ClassVar[float] = ...
    DEFAULT_ALPHA: typing.ClassVar[float] = ...
    DEFAULT_SCALING: typing.ClassVar[bool] = ...
    DEFAULT_SCALING_MAX_ITERATION: typing.ClassVar[int] = ...
    DEFAULT_RHO_UPDATE: typing.ClassVar[bool] = ...
    DEFAULT_RHO_MAX: typing.ClassVar[float] = ...
    DEFAULT_RHO_MIN: typing.ClassVar[float] = ...
    DEFAULT_MAX_RHO_ITERATION: typing.ClassVar[int] = ...
    DEFAULT_POLISHING: typing.ClassVar[bool] = ...
    DEFAULT_POLISHING_ITERATION: typing.ClassVar[int] = ...
    def __init__(self): ...
    def getAlpha(self) -> float: ...
    def getEps(self) -> float: ...
    def getEpsInfeasible(self) -> float: ...
    def getMaxRhoIteration(self) -> int: ...
    def getPolishIteration(self) -> int: ...
    def getRhoMax(self) -> float: ...
    def getRhoMin(self) -> float: ...
    def getScaleMaxIteration(self) -> int: ...
    def getSigma(self) -> float: ...
    def isPolishing(self) -> bool: ...
    def isScaling(self) -> bool: ...
    def setAlpha(self, double: float) -> None: ...
    def setEps(self, double: float) -> None: ...
    def setEpsInfeasible(self, double: float) -> None: ...
    def setMaxRhoIteration(self, int: int) -> None: ...
    def setPolishing(self, boolean: bool) -> None: ...
    def setPolishingIteration(self, int: int) -> None: ...
    def setRhoMax(self, double: float) -> None: ...
    def setRhoMin(self, double: float) -> None: ...
    def setScaleMaxIteration(self, int: int) -> None: ...
    def setScaling(self, boolean: bool) -> None: ...
    def setSigma(self, double: float) -> None: ...
    def setUpdateRho(self, boolean: bool) -> None: ...
    def updateRho(self) -> bool: ...

class ConstraintOptimizer(org.hipparchus.optim.BaseMultivariateOptimizer['LagrangeSolution']):
    def __init__(self): ...
    @typing.overload
    def optimize(self) -> typing.Any: ...
    @typing.overload
    def optimize(self, *optimizationData: org.hipparchus.optim.OptimizationData) -> 'LagrangeSolution': ...

_KarushKuhnTuckerSolver__T = typing.TypeVar('_KarushKuhnTuckerSolver__T')  # <T>
class KarushKuhnTuckerSolver(org.hipparchus.optim.OptimizationData, typing.Generic[_KarushKuhnTuckerSolver__T]):
    def iterate(self, *realVector: org.hipparchus.linear.RealVector) -> _KarushKuhnTuckerSolver__T: ...
    def solve(self, realVector: org.hipparchus.linear.RealVector, realVector2: org.hipparchus.linear.RealVector) -> _KarushKuhnTuckerSolver__T: ...

class LagrangeSolution:
    def __init__(self, realVector: org.hipparchus.linear.RealVector, realVector2: org.hipparchus.linear.RealVector, double: float): ...
    def getLambda(self) -> org.hipparchus.linear.RealVector: ...
    def getValue(self) -> float: ...
    def getX(self) -> org.hipparchus.linear.RealVector: ...

class SQPOption(org.hipparchus.optim.OptimizationData):
    DEFAULT_CONV_CRITERIA: typing.ClassVar[int] = ...
    DEFAULT_EPSILON: typing.ClassVar[float] = ...
    DEFAULT_RHO: typing.ClassVar[float] = ...
    DEFAULT_SIGMA_MAX: typing.ClassVar[float] = ...
    DEFAULT_QP_MAX_LOOP: typing.ClassVar[int] = ...
    DEFAULT_MU: typing.ClassVar[float] = ...
    DEFAULT_B: typing.ClassVar[float] = ...
    DEFAULT_USE_FUNCTION_HESSIAN: typing.ClassVar[bool] = ...
    DEFAULT_MAX_LINE_SEARCH_ITERATION: typing.ClassVar[int] = ...
    def __init__(self): ...
    def getB(self) -> float: ...
    def getConvCriteria(self) -> int: ...
    def getEps(self) -> float: ...
    def getMaxLineSearchIteration(self) -> int: ...
    def getMu(self) -> float: ...
    def getQpMaxLoop(self) -> int: ...
    def getRhoCons(self) -> float: ...
    def getSigmaMax(self) -> float: ...
    def setB(self, double: float) -> None: ...
    def setConvCriteria(self, int: int) -> None: ...
    def setEps(self, double: float) -> None: ...
    def setMaxLineSearchIteration(self, int: int) -> None: ...
    def setMu(self, double: float) -> None: ...
    def setQpMaxLoop(self, int: int) -> None: ...
    def setRhoCons(self, double: float) -> None: ...
    def setSigmaMax(self, double: float) -> None: ...
    def setUseFunHessian(self, boolean: bool) -> None: ...
    def useFunHessian(self) -> bool: ...

class TwiceDifferentiableFunction(org.hipparchus.analysis.MultivariateFunction):
    def __init__(self): ...
    def dim(self) -> int: ...
    @typing.overload
    def gradient(self, realVector: org.hipparchus.linear.RealVector) -> org.hipparchus.linear.RealVector: ...
    @typing.overload
    def gradient(self, doubleArray: typing.List[float]) -> org.hipparchus.linear.RealVector: ...
    @typing.overload
    def hessian(self, realVector: org.hipparchus.linear.RealVector) -> org.hipparchus.linear.RealMatrix: ...
    @typing.overload
    def hessian(self, doubleArray: typing.List[float]) -> org.hipparchus.linear.RealMatrix: ...
    @typing.overload
    def value(self, realVector: org.hipparchus.linear.RealVector) -> float: ...
    @typing.overload
    def value(self, doubleArray: typing.List[float]) -> float: ...

class VectorDifferentiableFunction(org.hipparchus.analysis.MultivariateVectorFunction):
    def dim(self) -> int: ...
    def dimY(self) -> int: ...
    def gradient(self, doubleArray: typing.List[float]) -> org.hipparchus.linear.RealMatrix: ...
    def jacobian(self, realVector: org.hipparchus.linear.RealVector) -> org.hipparchus.linear.RealMatrix: ...
    @typing.overload
    def value(self, realVector: org.hipparchus.linear.RealVector) -> org.hipparchus.linear.RealVector: ...
    @typing.overload
    def value(self, doubleArray: typing.List[float]) -> typing.List[float]: ...

class ADMMQPKKT(KarushKuhnTuckerSolver['ADMMQPSolution']):
    def initialize(self, realMatrix: org.hipparchus.linear.RealMatrix, realMatrix2: org.hipparchus.linear.RealMatrix, realVector: org.hipparchus.linear.RealVector, int: int, realVector2: org.hipparchus.linear.RealVector, realVector3: org.hipparchus.linear.RealVector, double: float, double2: float, double3: float) -> None: ...
    def iterate(self, *realVector: org.hipparchus.linear.RealVector) -> 'ADMMQPSolution': ...
    def solve(self, realVector: org.hipparchus.linear.RealVector, realVector2: org.hipparchus.linear.RealVector) -> 'ADMMQPSolution': ...
    def updateSigmaRho(self, double: float, int: int, double2: float) -> None: ...

class ADMMQPSolution(LagrangeSolution):
    @typing.overload
    def __init__(self, realVector: org.hipparchus.linear.RealVector, realVector2: org.hipparchus.linear.RealVector): ...
    @typing.overload
    def __init__(self, realVector: org.hipparchus.linear.RealVector, realVector2: org.hipparchus.linear.RealVector, double: float): ...
    @typing.overload
    def __init__(self, realVector: org.hipparchus.linear.RealVector, realVector2: org.hipparchus.linear.RealVector, realVector3: org.hipparchus.linear.RealVector, realVector4: org.hipparchus.linear.RealVector): ...
    @typing.overload
    def __init__(self, realVector: org.hipparchus.linear.RealVector, realVector2: org.hipparchus.linear.RealVector, realVector3: org.hipparchus.linear.RealVector, realVector4: org.hipparchus.linear.RealVector, double: float): ...
    def getV(self) -> org.hipparchus.linear.RealVector: ...
    def getZ(self) -> org.hipparchus.linear.RealVector: ...

class AbstractSQPOptimizer(ConstraintOptimizer):
    def getEqConstraint(self) -> 'EqualityConstraint': ...
    def getIqConstraint(self) -> 'InequalityConstraint': ...
    def getObj(self) -> TwiceDifferentiableFunction: ...
    def getSettings(self) -> SQPOption: ...
    @typing.overload
    def optimize(self) -> typing.Any: ...
    @typing.overload
    def optimize(self, *optimizationData: org.hipparchus.optim.OptimizationData) -> LagrangeSolution: ...

class Constraint(VectorDifferentiableFunction, org.hipparchus.optim.OptimizationData):
    def getLowerBound(self) -> org.hipparchus.linear.RealVector: ...
    def getUpperBound(self) -> org.hipparchus.linear.RealVector: ...
    def overshoot(self, realVector: org.hipparchus.linear.RealVector) -> float: ...

class QPOptimizer(ConstraintOptimizer):
    def __init__(self): ...

class QuadraticFunction(TwiceDifferentiableFunction):
    @typing.overload
    def __init__(self, doubleArray: typing.List[typing.List[float]], doubleArray2: typing.List[float], double3: float): ...
    @typing.overload
    def __init__(self, realMatrix: org.hipparchus.linear.RealMatrix, realVector: org.hipparchus.linear.RealVector, double: float): ...
    def dim(self) -> int: ...
    def getD(self) -> float: ...
    def getP(self) -> org.hipparchus.linear.RealMatrix: ...
    def getQ(self) -> org.hipparchus.linear.RealVector: ...
    @typing.overload
    def gradient(self, realVector: org.hipparchus.linear.RealVector) -> org.hipparchus.linear.RealVector: ...
    @typing.overload
    def gradient(self, doubleArray: typing.List[float]) -> org.hipparchus.linear.RealVector: ...
    @typing.overload
    def hessian(self, realVector: org.hipparchus.linear.RealVector) -> org.hipparchus.linear.RealMatrix: ...
    @typing.overload
    def hessian(self, doubleArray: typing.List[float]) -> org.hipparchus.linear.RealMatrix: ...
    @typing.overload
    def value(self, realVector: org.hipparchus.linear.RealVector) -> float: ...
    @typing.overload
    def value(self, doubleArray: typing.List[float]) -> float: ...

class ADMMQPOptimizer(QPOptimizer):
    def __init__(self): ...
    def doOptimize(self) -> LagrangeSolution: ...
    def getConvergenceChecker(self) -> org.hipparchus.optim.ConvergenceChecker[LagrangeSolution]: ...
    def isConverged(self) -> bool: ...
    @typing.overload
    def optimize(self) -> typing.Any: ...
    @typing.overload
    def optimize(self, *optimizationData: org.hipparchus.optim.OptimizationData) -> LagrangeSolution: ...

class BoundedConstraint(Constraint):
    def __init__(self, realVector: org.hipparchus.linear.RealVector, realVector2: org.hipparchus.linear.RealVector): ...
    def dimY(self) -> int: ...
    def getLowerBound(self) -> org.hipparchus.linear.RealVector: ...
    def getUpperBound(self) -> org.hipparchus.linear.RealVector: ...
    def overshoot(self, realVector: org.hipparchus.linear.RealVector) -> float: ...

class SQPOptimizerGM(AbstractSQPOptimizer):
    def __init__(self): ...
    def doOptimize(self) -> LagrangeSolution: ...

class SQPOptimizerS(AbstractSQPOptimizer):
    def __init__(self): ...
    def doOptimize(self) -> LagrangeSolution: ...

class EqualityConstraint(BoundedConstraint):
    def __init__(self, realVector: org.hipparchus.linear.RealVector): ...

class InequalityConstraint(BoundedConstraint):
    def __init__(self, realVector: org.hipparchus.linear.RealVector): ...

class LinearBoundedConstraint(BoundedConstraint, org.hipparchus.optim.OptimizationData):
    @typing.overload
    def __init__(self, doubleArray: typing.List[typing.List[float]], doubleArray2: typing.List[float], doubleArray3: typing.List[float]): ...
    @typing.overload
    def __init__(self, realMatrix: org.hipparchus.linear.RealMatrix, realVector: org.hipparchus.linear.RealVector, realVector2: org.hipparchus.linear.RealVector): ...
    def dim(self) -> int: ...
    def jacobian(self, realVector: org.hipparchus.linear.RealVector) -> org.hipparchus.linear.RealMatrix: ...
    @typing.overload
    def value(self, doubleArray: typing.List[float]) -> typing.List[float]: ...
    @typing.overload
    def value(self, realVector: org.hipparchus.linear.RealVector) -> org.hipparchus.linear.RealVector: ...

class LinearEqualityConstraint(EqualityConstraint, org.hipparchus.optim.OptimizationData):
    @typing.overload
    def __init__(self, doubleArray: typing.List[typing.List[float]], doubleArray2: typing.List[float]): ...
    @typing.overload
    def __init__(self, realMatrix: org.hipparchus.linear.RealMatrix, realVector: org.hipparchus.linear.RealVector): ...
    def dim(self) -> int: ...
    def getA(self) -> org.hipparchus.linear.RealMatrix: ...
    def jacobian(self, realVector: org.hipparchus.linear.RealVector) -> org.hipparchus.linear.RealMatrix: ...
    @typing.overload
    def value(self, doubleArray: typing.List[float]) -> typing.List[float]: ...
    @typing.overload
    def value(self, realVector: org.hipparchus.linear.RealVector) -> org.hipparchus.linear.RealVector: ...

class LinearInequalityConstraint(InequalityConstraint, org.hipparchus.optim.OptimizationData):
    @typing.overload
    def __init__(self, doubleArray: typing.List[typing.List[float]], doubleArray2: typing.List[float]): ...
    @typing.overload
    def __init__(self, realMatrix: org.hipparchus.linear.RealMatrix, realVector: org.hipparchus.linear.RealVector): ...
    def dim(self) -> int: ...
    def jacobian(self, realVector: org.hipparchus.linear.RealVector) -> org.hipparchus.linear.RealMatrix: ...
    @typing.overload
    def value(self, doubleArray: typing.List[float]) -> typing.List[float]: ...
    @typing.overload
    def value(self, realVector: org.hipparchus.linear.RealVector) -> org.hipparchus.linear.RealVector: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.hipparchus.optim.nonlinear.vector.constrained")``.

    ADMMQPConvergenceChecker: typing.Type[ADMMQPConvergenceChecker]
    ADMMQPKKT: typing.Type[ADMMQPKKT]
    ADMMQPModifiedRuizEquilibrium: typing.Type[ADMMQPModifiedRuizEquilibrium]
    ADMMQPOptimizer: typing.Type[ADMMQPOptimizer]
    ADMMQPOption: typing.Type[ADMMQPOption]
    ADMMQPSolution: typing.Type[ADMMQPSolution]
    AbstractSQPOptimizer: typing.Type[AbstractSQPOptimizer]
    BoundedConstraint: typing.Type[BoundedConstraint]
    Constraint: typing.Type[Constraint]
    ConstraintOptimizer: typing.Type[ConstraintOptimizer]
    EqualityConstraint: typing.Type[EqualityConstraint]
    InequalityConstraint: typing.Type[InequalityConstraint]
    KarushKuhnTuckerSolver: typing.Type[KarushKuhnTuckerSolver]
    LagrangeSolution: typing.Type[LagrangeSolution]
    LinearBoundedConstraint: typing.Type[LinearBoundedConstraint]
    LinearEqualityConstraint: typing.Type[LinearEqualityConstraint]
    LinearInequalityConstraint: typing.Type[LinearInequalityConstraint]
    QPOptimizer: typing.Type[QPOptimizer]
    QuadraticFunction: typing.Type[QuadraticFunction]
    SQPOptimizerGM: typing.Type[SQPOptimizerGM]
    SQPOptimizerS: typing.Type[SQPOptimizerS]
    SQPOption: typing.Type[SQPOption]
    TwiceDifferentiableFunction: typing.Type[TwiceDifferentiableFunction]
    VectorDifferentiableFunction: typing.Type[VectorDifferentiableFunction]
