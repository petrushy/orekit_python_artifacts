import java.io
import java.lang
import java.text
import java.util
import org.hipparchus
import org.hipparchus.geometry
import org.hipparchus.geometry.enclosing
import org.hipparchus.geometry.euclidean.oned
import org.hipparchus.geometry.euclidean.twod
import org.hipparchus.geometry.partitioning
import org.hipparchus.util
import typing



class Euclidean3D(java.io.Serializable, org.hipparchus.geometry.Space):
    def getDimension(self) -> int: ...
    @staticmethod
    def getInstance() -> 'Euclidean3D': ...
    def getSubSpace(self) -> org.hipparchus.geometry.euclidean.twod.Euclidean2D: ...

_FieldLine__T = typing.TypeVar('_FieldLine__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
class FieldLine(typing.Generic[_FieldLine__T]):
    @typing.overload
    def __init__(self, fieldLine: 'FieldLine'[_FieldLine__T]): ...
    @typing.overload
    def __init__(self, fieldVector3D: 'FieldVector3D'[_FieldLine__T], fieldVector3D2: 'FieldVector3D'[_FieldLine__T], double: float): ...
    def closestPoint(self, fieldLine: 'FieldLine'[_FieldLine__T]) -> 'FieldVector3D'[_FieldLine__T]: ...
    @typing.overload
    def contains(self, fieldVector3D: 'FieldVector3D'[_FieldLine__T]) -> bool: ...
    @typing.overload
    def contains(self, vector3D: 'Vector3D') -> bool: ...
    @typing.overload
    def distance(self, fieldLine: 'FieldLine'[_FieldLine__T]) -> _FieldLine__T: ...
    @typing.overload
    def distance(self, fieldVector3D: 'FieldVector3D'[_FieldLine__T]) -> _FieldLine__T: ...
    @typing.overload
    def distance(self, vector3D: 'Vector3D') -> _FieldLine__T: ...
    @typing.overload
    def getAbscissa(self, fieldVector3D: 'FieldVector3D'[_FieldLine__T]) -> _FieldLine__T: ...
    @typing.overload
    def getAbscissa(self, vector3D: 'Vector3D') -> _FieldLine__T: ...
    def getDirection(self) -> 'FieldVector3D'[_FieldLine__T]: ...
    def getOrigin(self) -> 'FieldVector3D'[_FieldLine__T]: ...
    def getTolerance(self) -> float: ...
    def intersection(self, fieldLine: 'FieldLine'[_FieldLine__T]) -> 'FieldVector3D'[_FieldLine__T]: ...
    def isSimilarTo(self, fieldLine: 'FieldLine'[_FieldLine__T]) -> bool: ...
    @typing.overload
    def pointAt(self, double: float) -> 'FieldVector3D'[_FieldLine__T]: ...
    @typing.overload
    def pointAt(self, t: _FieldLine__T) -> 'FieldVector3D'[_FieldLine__T]: ...
    def reset(self, fieldVector3D: 'FieldVector3D'[_FieldLine__T], fieldVector3D2: 'FieldVector3D'[_FieldLine__T]) -> None: ...
    def revert(self) -> 'FieldLine'[_FieldLine__T]: ...

_FieldRotation__T = typing.TypeVar('_FieldRotation__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
class FieldRotation(java.io.Serializable, typing.Generic[_FieldRotation__T]):
    @typing.overload
    def __init__(self, t: _FieldRotation__T, t2: _FieldRotation__T, t3: _FieldRotation__T, t4: _FieldRotation__T, boolean: bool): ...
    @typing.overload
    def __init__(self, tArray: typing.List[typing.List[_FieldRotation__T]], double: float): ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_FieldRotation__T], rotation: 'Rotation'): ...
    @typing.overload
    def __init__(self, fieldVector3D: 'FieldVector3D'[_FieldRotation__T], t: _FieldRotation__T, rotationConvention: 'RotationConvention'): ...
    @typing.overload
    def __init__(self, fieldVector3D: 'FieldVector3D'[_FieldRotation__T], fieldVector3D2: 'FieldVector3D'[_FieldRotation__T]): ...
    @typing.overload
    def __init__(self, fieldVector3D: 'FieldVector3D'[_FieldRotation__T], fieldVector3D2: 'FieldVector3D'[_FieldRotation__T], fieldVector3D3: 'FieldVector3D'[_FieldRotation__T], fieldVector3D4: 'FieldVector3D'[_FieldRotation__T]): ...
    @typing.overload
    def __init__(self, rotationOrder: 'RotationOrder', rotationConvention: 'RotationConvention', t: _FieldRotation__T, t2: _FieldRotation__T, t3: _FieldRotation__T): ...
    _applyInverseTo_4__T = typing.TypeVar('_applyInverseTo_4__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _applyInverseTo_5__T = typing.TypeVar('_applyInverseTo_5__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def applyInverseTo(self, fieldRotation: 'FieldRotation'[_FieldRotation__T]) -> 'FieldRotation'[_FieldRotation__T]: ...
    @typing.overload
    def applyInverseTo(self, rotation: 'Rotation') -> 'FieldRotation'[_FieldRotation__T]: ...
    @typing.overload
    def applyInverseTo(self, fieldVector3D: 'FieldVector3D'[_FieldRotation__T]) -> 'FieldVector3D'[_FieldRotation__T]: ...
    @typing.overload
    def applyInverseTo(self, vector3D: 'Vector3D') -> 'FieldVector3D'[_FieldRotation__T]: ...
    @typing.overload
    @staticmethod
    def applyInverseTo(rotation: 'Rotation', fieldRotation: 'FieldRotation'[_applyInverseTo_4__T]) -> 'FieldRotation'[_applyInverseTo_4__T]: ...
    @typing.overload
    @staticmethod
    def applyInverseTo(rotation: 'Rotation', fieldVector3D: 'FieldVector3D'[_applyInverseTo_5__T]) -> 'FieldVector3D'[_applyInverseTo_5__T]: ...
    @typing.overload
    def applyInverseTo(self, doubleArray: typing.List[float], tArray: typing.List[_FieldRotation__T]) -> None: ...
    @typing.overload
    def applyInverseTo(self, tArray: typing.List[_FieldRotation__T], tArray2: typing.List[_FieldRotation__T]) -> None: ...
    _applyTo_4__T = typing.TypeVar('_applyTo_4__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _applyTo_5__T = typing.TypeVar('_applyTo_5__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def applyTo(self, fieldRotation: 'FieldRotation'[_FieldRotation__T]) -> 'FieldRotation'[_FieldRotation__T]: ...
    @typing.overload
    def applyTo(self, rotation: 'Rotation') -> 'FieldRotation'[_FieldRotation__T]: ...
    @typing.overload
    def applyTo(self, fieldVector3D: 'FieldVector3D'[_FieldRotation__T]) -> 'FieldVector3D'[_FieldRotation__T]: ...
    @typing.overload
    def applyTo(self, vector3D: 'Vector3D') -> 'FieldVector3D'[_FieldRotation__T]: ...
    @typing.overload
    @staticmethod
    def applyTo(rotation: 'Rotation', fieldRotation: 'FieldRotation'[_applyTo_4__T]) -> 'FieldRotation'[_applyTo_4__T]: ...
    @typing.overload
    @staticmethod
    def applyTo(rotation: 'Rotation', fieldVector3D: 'FieldVector3D'[_applyTo_5__T]) -> 'FieldVector3D'[_applyTo_5__T]: ...
    @typing.overload
    def applyTo(self, doubleArray: typing.List[float], tArray: typing.List[_FieldRotation__T]) -> None: ...
    @typing.overload
    def applyTo(self, tArray: typing.List[_FieldRotation__T], tArray2: typing.List[_FieldRotation__T]) -> None: ...
    @typing.overload
    def compose(self, fieldRotation: 'FieldRotation'[_FieldRotation__T], rotationConvention: 'RotationConvention') -> 'FieldRotation'[_FieldRotation__T]: ...
    @typing.overload
    def compose(self, rotation: 'Rotation', rotationConvention: 'RotationConvention') -> 'FieldRotation'[_FieldRotation__T]: ...
    @typing.overload
    def composeInverse(self, fieldRotation: 'FieldRotation'[_FieldRotation__T], rotationConvention: 'RotationConvention') -> 'FieldRotation'[_FieldRotation__T]: ...
    @typing.overload
    def composeInverse(self, rotation: 'Rotation', rotationConvention: 'RotationConvention') -> 'FieldRotation'[_FieldRotation__T]: ...
    _distance__T = typing.TypeVar('_distance__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @staticmethod
    def distance(fieldRotation: 'FieldRotation'[_distance__T], fieldRotation2: 'FieldRotation'[_distance__T]) -> _distance__T: ...
    def getAngle(self) -> _FieldRotation__T: ...
    def getAngles(self, rotationOrder: 'RotationOrder', rotationConvention: 'RotationConvention') -> typing.List[_FieldRotation__T]: ...
    def getAxis(self, rotationConvention: 'RotationConvention') -> 'FieldVector3D'[_FieldRotation__T]: ...
    _getIdentity__T = typing.TypeVar('_getIdentity__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @staticmethod
    def getIdentity(field: org.hipparchus.Field[_getIdentity__T]) -> 'FieldRotation'[_getIdentity__T]: ...
    def getMatrix(self) -> typing.List[typing.List[_FieldRotation__T]]: ...
    def getQ0(self) -> _FieldRotation__T: ...
    def getQ1(self) -> _FieldRotation__T: ...
    def getQ2(self) -> _FieldRotation__T: ...
    def getQ3(self) -> _FieldRotation__T: ...
    def revert(self) -> 'FieldRotation'[_FieldRotation__T]: ...
    def toRotation(self) -> 'Rotation': ...

_FieldVector3D__T = typing.TypeVar('_FieldVector3D__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
class FieldVector3D(org.hipparchus.util.FieldBlendable['FieldVector3D'[_FieldVector3D__T], _FieldVector3D__T], java.io.Serializable, typing.Generic[_FieldVector3D__T]):
    @typing.overload
    def __init__(self, double: float, fieldVector3D: 'FieldVector3D'[_FieldVector3D__T]): ...
    @typing.overload
    def __init__(self, double: float, fieldVector3D: 'FieldVector3D'[_FieldVector3D__T], double2: float, fieldVector3D2: 'FieldVector3D'[_FieldVector3D__T]): ...
    @typing.overload
    def __init__(self, double: float, fieldVector3D: 'FieldVector3D'[_FieldVector3D__T], double2: float, fieldVector3D2: 'FieldVector3D'[_FieldVector3D__T], double3: float, fieldVector3D3: 'FieldVector3D'[_FieldVector3D__T]): ...
    @typing.overload
    def __init__(self, double: float, fieldVector3D: 'FieldVector3D'[_FieldVector3D__T], double2: float, fieldVector3D2: 'FieldVector3D'[_FieldVector3D__T], double3: float, fieldVector3D3: 'FieldVector3D'[_FieldVector3D__T], double4: float, fieldVector3D4: 'FieldVector3D'[_FieldVector3D__T]): ...
    @typing.overload
    def __init__(self, t: _FieldVector3D__T, t2: _FieldVector3D__T): ...
    @typing.overload
    def __init__(self, t: _FieldVector3D__T, t2: _FieldVector3D__T, t3: _FieldVector3D__T): ...
    @typing.overload
    def __init__(self, t: _FieldVector3D__T, fieldVector3D: 'FieldVector3D'[_FieldVector3D__T]): ...
    @typing.overload
    def __init__(self, t: _FieldVector3D__T, fieldVector3D: 'FieldVector3D'[_FieldVector3D__T], t2: _FieldVector3D__T, fieldVector3D2: 'FieldVector3D'[_FieldVector3D__T]): ...
    @typing.overload
    def __init__(self, t: _FieldVector3D__T, fieldVector3D: 'FieldVector3D'[_FieldVector3D__T], t2: _FieldVector3D__T, fieldVector3D2: 'FieldVector3D'[_FieldVector3D__T], t3: _FieldVector3D__T, fieldVector3D3: 'FieldVector3D'[_FieldVector3D__T]): ...
    @typing.overload
    def __init__(self, t: _FieldVector3D__T, fieldVector3D: 'FieldVector3D'[_FieldVector3D__T], t2: _FieldVector3D__T, fieldVector3D2: 'FieldVector3D'[_FieldVector3D__T], t3: _FieldVector3D__T, fieldVector3D3: 'FieldVector3D'[_FieldVector3D__T], t4: _FieldVector3D__T, fieldVector3D4: 'FieldVector3D'[_FieldVector3D__T]): ...
    @typing.overload
    def __init__(self, t: _FieldVector3D__T, vector3D: 'Vector3D'): ...
    @typing.overload
    def __init__(self, t: _FieldVector3D__T, vector3D: 'Vector3D', t2: _FieldVector3D__T, vector3D2: 'Vector3D'): ...
    @typing.overload
    def __init__(self, t: _FieldVector3D__T, vector3D: 'Vector3D', t2: _FieldVector3D__T, vector3D2: 'Vector3D', t3: _FieldVector3D__T, vector3D3: 'Vector3D'): ...
    @typing.overload
    def __init__(self, t: _FieldVector3D__T, vector3D: 'Vector3D', t2: _FieldVector3D__T, vector3D2: 'Vector3D', t3: _FieldVector3D__T, vector3D3: 'Vector3D', t4: _FieldVector3D__T, vector3D4: 'Vector3D'): ...
    @typing.overload
    def __init__(self, tArray: typing.List[_FieldVector3D__T]): ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_FieldVector3D__T], vector3D: 'Vector3D'): ...
    @typing.overload
    def add(self, double: float, fieldVector3D: 'FieldVector3D'[_FieldVector3D__T]) -> 'FieldVector3D'[_FieldVector3D__T]: ...
    @typing.overload
    def add(self, double: float, vector3D: 'Vector3D') -> 'FieldVector3D'[_FieldVector3D__T]: ...
    @typing.overload
    def add(self, t: _FieldVector3D__T, fieldVector3D: 'FieldVector3D'[_FieldVector3D__T]) -> 'FieldVector3D'[_FieldVector3D__T]: ...
    @typing.overload
    def add(self, t: _FieldVector3D__T, vector3D: 'Vector3D') -> 'FieldVector3D'[_FieldVector3D__T]: ...
    @typing.overload
    def add(self, fieldVector3D: 'FieldVector3D'[_FieldVector3D__T]) -> 'FieldVector3D'[_FieldVector3D__T]: ...
    @typing.overload
    def add(self, vector3D: 'Vector3D') -> 'FieldVector3D'[_FieldVector3D__T]: ...
    _angle_0__T = typing.TypeVar('_angle_0__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _angle_1__T = typing.TypeVar('_angle_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _angle_2__T = typing.TypeVar('_angle_2__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def angle(fieldVector3D: 'FieldVector3D'[_angle_0__T], fieldVector3D2: 'FieldVector3D'[_angle_0__T]) -> _angle_0__T: ...
    @typing.overload
    @staticmethod
    def angle(fieldVector3D: 'FieldVector3D'[_angle_1__T], vector3D: 'Vector3D') -> _angle_1__T: ...
    @typing.overload
    @staticmethod
    def angle(vector3D: 'Vector3D', fieldVector3D: 'FieldVector3D'[_angle_2__T]) -> _angle_2__T: ...
    def blendArithmeticallyWith(self, fieldVector3D: 'FieldVector3D'[_FieldVector3D__T], t: _FieldVector3D__T) -> 'FieldVector3D'[_FieldVector3D__T]: ...
    _crossProduct_2__T = typing.TypeVar('_crossProduct_2__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _crossProduct_3__T = typing.TypeVar('_crossProduct_3__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _crossProduct_4__T = typing.TypeVar('_crossProduct_4__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def crossProduct(self, fieldVector3D: 'FieldVector3D'[_FieldVector3D__T]) -> 'FieldVector3D'[_FieldVector3D__T]: ...
    @typing.overload
    def crossProduct(self, vector3D: 'Vector3D') -> 'FieldVector3D'[_FieldVector3D__T]: ...
    @typing.overload
    @staticmethod
    def crossProduct(fieldVector3D: 'FieldVector3D'[_crossProduct_2__T], fieldVector3D2: 'FieldVector3D'[_crossProduct_2__T]) -> 'FieldVector3D'[_crossProduct_2__T]: ...
    @typing.overload
    @staticmethod
    def crossProduct(fieldVector3D: 'FieldVector3D'[_crossProduct_3__T], vector3D: 'Vector3D') -> 'FieldVector3D'[_crossProduct_3__T]: ...
    @typing.overload
    @staticmethod
    def crossProduct(vector3D: 'Vector3D', fieldVector3D: 'FieldVector3D'[_crossProduct_4__T]) -> 'FieldVector3D'[_crossProduct_4__T]: ...
    _distance_2__T = typing.TypeVar('_distance_2__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _distance_3__T = typing.TypeVar('_distance_3__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _distance_4__T = typing.TypeVar('_distance_4__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def distance(self, fieldVector3D: 'FieldVector3D'[_FieldVector3D__T]) -> _FieldVector3D__T: ...
    @typing.overload
    def distance(self, vector3D: 'Vector3D') -> _FieldVector3D__T: ...
    @typing.overload
    @staticmethod
    def distance(fieldVector3D: 'FieldVector3D'[_distance_2__T], fieldVector3D2: 'FieldVector3D'[_distance_2__T]) -> _distance_2__T: ...
    @typing.overload
    @staticmethod
    def distance(fieldVector3D: 'FieldVector3D'[_distance_3__T], vector3D: 'Vector3D') -> _distance_3__T: ...
    @typing.overload
    @staticmethod
    def distance(vector3D: 'Vector3D', fieldVector3D: 'FieldVector3D'[_distance_4__T]) -> _distance_4__T: ...
    _distance1_2__T = typing.TypeVar('_distance1_2__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _distance1_3__T = typing.TypeVar('_distance1_3__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _distance1_4__T = typing.TypeVar('_distance1_4__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def distance1(self, fieldVector3D: 'FieldVector3D'[_FieldVector3D__T]) -> _FieldVector3D__T: ...
    @typing.overload
    def distance1(self, vector3D: 'Vector3D') -> _FieldVector3D__T: ...
    @typing.overload
    @staticmethod
    def distance1(fieldVector3D: 'FieldVector3D'[_distance1_2__T], fieldVector3D2: 'FieldVector3D'[_distance1_2__T]) -> _distance1_2__T: ...
    @typing.overload
    @staticmethod
    def distance1(fieldVector3D: 'FieldVector3D'[_distance1_3__T], vector3D: 'Vector3D') -> _distance1_3__T: ...
    @typing.overload
    @staticmethod
    def distance1(vector3D: 'Vector3D', fieldVector3D: 'FieldVector3D'[_distance1_4__T]) -> _distance1_4__T: ...
    _distanceInf_2__T = typing.TypeVar('_distanceInf_2__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _distanceInf_3__T = typing.TypeVar('_distanceInf_3__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _distanceInf_4__T = typing.TypeVar('_distanceInf_4__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def distanceInf(self, fieldVector3D: 'FieldVector3D'[_FieldVector3D__T]) -> _FieldVector3D__T: ...
    @typing.overload
    def distanceInf(self, vector3D: 'Vector3D') -> _FieldVector3D__T: ...
    @typing.overload
    @staticmethod
    def distanceInf(fieldVector3D: 'FieldVector3D'[_distanceInf_2__T], fieldVector3D2: 'FieldVector3D'[_distanceInf_2__T]) -> _distanceInf_2__T: ...
    @typing.overload
    @staticmethod
    def distanceInf(fieldVector3D: 'FieldVector3D'[_distanceInf_3__T], vector3D: 'Vector3D') -> _distanceInf_3__T: ...
    @typing.overload
    @staticmethod
    def distanceInf(vector3D: 'Vector3D', fieldVector3D: 'FieldVector3D'[_distanceInf_4__T]) -> _distanceInf_4__T: ...
    _distanceSq_2__T = typing.TypeVar('_distanceSq_2__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _distanceSq_3__T = typing.TypeVar('_distanceSq_3__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _distanceSq_4__T = typing.TypeVar('_distanceSq_4__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def distanceSq(self, fieldVector3D: 'FieldVector3D'[_FieldVector3D__T]) -> _FieldVector3D__T: ...
    @typing.overload
    def distanceSq(self, vector3D: 'Vector3D') -> _FieldVector3D__T: ...
    @typing.overload
    @staticmethod
    def distanceSq(fieldVector3D: 'FieldVector3D'[_distanceSq_2__T], fieldVector3D2: 'FieldVector3D'[_distanceSq_2__T]) -> _distanceSq_2__T: ...
    @typing.overload
    @staticmethod
    def distanceSq(fieldVector3D: 'FieldVector3D'[_distanceSq_3__T], vector3D: 'Vector3D') -> _distanceSq_3__T: ...
    @typing.overload
    @staticmethod
    def distanceSq(vector3D: 'Vector3D', fieldVector3D: 'FieldVector3D'[_distanceSq_4__T]) -> _distanceSq_4__T: ...
    _dotProduct_2__T = typing.TypeVar('_dotProduct_2__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _dotProduct_3__T = typing.TypeVar('_dotProduct_3__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _dotProduct_4__T = typing.TypeVar('_dotProduct_4__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def dotProduct(self, fieldVector3D: 'FieldVector3D'[_FieldVector3D__T]) -> _FieldVector3D__T: ...
    @typing.overload
    def dotProduct(self, vector3D: 'Vector3D') -> _FieldVector3D__T: ...
    @typing.overload
    @staticmethod
    def dotProduct(fieldVector3D: 'FieldVector3D'[_dotProduct_2__T], fieldVector3D2: 'FieldVector3D'[_dotProduct_2__T]) -> _dotProduct_2__T: ...
    @typing.overload
    @staticmethod
    def dotProduct(fieldVector3D: 'FieldVector3D'[_dotProduct_3__T], vector3D: 'Vector3D') -> _dotProduct_3__T: ...
    @typing.overload
    @staticmethod
    def dotProduct(vector3D: 'Vector3D', fieldVector3D: 'FieldVector3D'[_dotProduct_4__T]) -> _dotProduct_4__T: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getAlpha(self) -> _FieldVector3D__T: ...
    def getDelta(self) -> _FieldVector3D__T: ...
    _getMinusI__T = typing.TypeVar('_getMinusI__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @staticmethod
    def getMinusI(field: org.hipparchus.Field[_getMinusI__T]) -> 'FieldVector3D'[_getMinusI__T]: ...
    _getMinusJ__T = typing.TypeVar('_getMinusJ__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @staticmethod
    def getMinusJ(field: org.hipparchus.Field[_getMinusJ__T]) -> 'FieldVector3D'[_getMinusJ__T]: ...
    _getMinusK__T = typing.TypeVar('_getMinusK__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @staticmethod
    def getMinusK(field: org.hipparchus.Field[_getMinusK__T]) -> 'FieldVector3D'[_getMinusK__T]: ...
    _getNaN__T = typing.TypeVar('_getNaN__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @staticmethod
    def getNaN(field: org.hipparchus.Field[_getNaN__T]) -> 'FieldVector3D'[_getNaN__T]: ...
    _getNegativeInfinity__T = typing.TypeVar('_getNegativeInfinity__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @staticmethod
    def getNegativeInfinity(field: org.hipparchus.Field[_getNegativeInfinity__T]) -> 'FieldVector3D'[_getNegativeInfinity__T]: ...
    def getNorm(self) -> _FieldVector3D__T: ...
    def getNorm1(self) -> _FieldVector3D__T: ...
    def getNormInf(self) -> _FieldVector3D__T: ...
    def getNormSq(self) -> _FieldVector3D__T: ...
    _getPlusI__T = typing.TypeVar('_getPlusI__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @staticmethod
    def getPlusI(field: org.hipparchus.Field[_getPlusI__T]) -> 'FieldVector3D'[_getPlusI__T]: ...
    _getPlusJ__T = typing.TypeVar('_getPlusJ__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @staticmethod
    def getPlusJ(field: org.hipparchus.Field[_getPlusJ__T]) -> 'FieldVector3D'[_getPlusJ__T]: ...
    _getPlusK__T = typing.TypeVar('_getPlusK__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @staticmethod
    def getPlusK(field: org.hipparchus.Field[_getPlusK__T]) -> 'FieldVector3D'[_getPlusK__T]: ...
    _getPositiveInfinity__T = typing.TypeVar('_getPositiveInfinity__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @staticmethod
    def getPositiveInfinity(field: org.hipparchus.Field[_getPositiveInfinity__T]) -> 'FieldVector3D'[_getPositiveInfinity__T]: ...
    def getX(self) -> _FieldVector3D__T: ...
    def getY(self) -> _FieldVector3D__T: ...
    def getZ(self) -> _FieldVector3D__T: ...
    _getZero__T = typing.TypeVar('_getZero__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @staticmethod
    def getZero(field: org.hipparchus.Field[_getZero__T]) -> 'FieldVector3D'[_getZero__T]: ...
    def hashCode(self) -> int: ...
    def isInfinite(self) -> bool: ...
    def isNaN(self) -> bool: ...
    def negate(self) -> 'FieldVector3D'[_FieldVector3D__T]: ...
    def normalize(self) -> 'FieldVector3D'[_FieldVector3D__T]: ...
    def orthogonal(self) -> 'FieldVector3D'[_FieldVector3D__T]: ...
    @typing.overload
    def scalarMultiply(self, double: float) -> 'FieldVector3D'[_FieldVector3D__T]: ...
    @typing.overload
    def scalarMultiply(self, t: _FieldVector3D__T) -> 'FieldVector3D'[_FieldVector3D__T]: ...
    @typing.overload
    def subtract(self, double: float, fieldVector3D: 'FieldVector3D'[_FieldVector3D__T]) -> 'FieldVector3D'[_FieldVector3D__T]: ...
    @typing.overload
    def subtract(self, double: float, vector3D: 'Vector3D') -> 'FieldVector3D'[_FieldVector3D__T]: ...
    @typing.overload
    def subtract(self, t: _FieldVector3D__T, fieldVector3D: 'FieldVector3D'[_FieldVector3D__T]) -> 'FieldVector3D'[_FieldVector3D__T]: ...
    @typing.overload
    def subtract(self, t: _FieldVector3D__T, vector3D: 'Vector3D') -> 'FieldVector3D'[_FieldVector3D__T]: ...
    @typing.overload
    def subtract(self, fieldVector3D: 'FieldVector3D'[_FieldVector3D__T]) -> 'FieldVector3D'[_FieldVector3D__T]: ...
    @typing.overload
    def subtract(self, vector3D: 'Vector3D') -> 'FieldVector3D'[_FieldVector3D__T]: ...
    def toArray(self) -> typing.List[_FieldVector3D__T]: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    def toString(self, numberFormat: java.text.NumberFormat) -> str: ...
    def toVector3D(self) -> 'Vector3D': ...

class Line(org.hipparchus.geometry.partitioning.Embedding[Euclidean3D, org.hipparchus.geometry.euclidean.oned.Euclidean1D]):
    @typing.overload
    def __init__(self, line: 'Line'): ...
    @typing.overload
    def __init__(self, vector3D: 'Vector3D', vector3D2: 'Vector3D', double: float): ...
    def closestPoint(self, line: 'Line') -> 'Vector3D': ...
    def contains(self, vector3D: 'Vector3D') -> bool: ...
    @typing.overload
    def distance(self, line: 'Line') -> float: ...
    @typing.overload
    def distance(self, vector3D: 'Vector3D') -> float: ...
    @staticmethod
    def fromDirection(vector3D: 'Vector3D', vector3D2: 'Vector3D', double: float) -> 'Line': ...
    def getAbscissa(self, vector3D: 'Vector3D') -> float: ...
    def getDirection(self) -> 'Vector3D': ...
    def getOrigin(self) -> 'Vector3D': ...
    def getTolerance(self) -> float: ...
    def intersection(self, line: 'Line') -> 'Vector3D': ...
    def isSimilarTo(self, line: 'Line') -> bool: ...
    def pointAt(self, double: float) -> 'Vector3D': ...
    def reset(self, vector3D: 'Vector3D', vector3D2: 'Vector3D') -> None: ...
    def revert(self) -> 'Line': ...
    @typing.overload
    def toSpace(self, point: org.hipparchus.geometry.Point[org.hipparchus.geometry.euclidean.oned.Euclidean1D]) -> 'Vector3D': ...
    @typing.overload
    def toSpace(self, vector: org.hipparchus.geometry.Vector[org.hipparchus.geometry.euclidean.oned.Euclidean1D, org.hipparchus.geometry.euclidean.oned.Vector1D]) -> 'Vector3D': ...
    @typing.overload
    def toSubSpace(self, point: org.hipparchus.geometry.Point[Euclidean3D]) -> org.hipparchus.geometry.euclidean.oned.Vector1D: ...
    @typing.overload
    def toSubSpace(self, vector: org.hipparchus.geometry.Vector[Euclidean3D, 'Vector3D']) -> org.hipparchus.geometry.euclidean.oned.Vector1D: ...
    def wholeLine(self) -> 'SubLine': ...

class OutlineExtractor:
    def __init__(self, vector3D: 'Vector3D', vector3D2: 'Vector3D'): ...
    def getOutline(self, polyhedronsSet: 'PolyhedronsSet') -> typing.List[typing.List[org.hipparchus.geometry.euclidean.twod.Vector2D]]: ...

class Plane(org.hipparchus.geometry.partitioning.Hyperplane[Euclidean3D], org.hipparchus.geometry.partitioning.Embedding[Euclidean3D, org.hipparchus.geometry.euclidean.twod.Euclidean2D]):
    @typing.overload
    def __init__(self, plane: 'Plane'): ...
    @typing.overload
    def __init__(self, vector3D: 'Vector3D', double: float): ...
    @typing.overload
    def __init__(self, vector3D: 'Vector3D', vector3D2: 'Vector3D', double: float): ...
    @typing.overload
    def __init__(self, vector3D: 'Vector3D', vector3D2: 'Vector3D', vector3D3: 'Vector3D', double: float): ...
    def contains(self, vector3D: 'Vector3D') -> bool: ...
    def copySelf(self) -> 'Plane': ...
    def emptyHyperplane(self) -> 'SubPlane': ...
    def getNormal(self) -> 'Vector3D': ...
    @typing.overload
    def getOffset(self, point: org.hipparchus.geometry.Point[Euclidean3D]) -> float: ...
    @typing.overload
    def getOffset(self, vector: org.hipparchus.geometry.Vector[Euclidean3D, 'Vector3D']) -> float: ...
    @typing.overload
    def getOffset(self, plane: 'Plane') -> float: ...
    def getOrigin(self) -> 'Vector3D': ...
    def getPointAt(self, vector2D: org.hipparchus.geometry.euclidean.twod.Vector2D, double: float) -> 'Vector3D': ...
    def getTolerance(self) -> float: ...
    def getU(self) -> 'Vector3D': ...
    def getV(self) -> 'Vector3D': ...
    @typing.overload
    def intersection(self, plane: 'Plane') -> Line: ...
    @typing.overload
    def intersection(self, line: Line) -> 'Vector3D': ...
    @typing.overload
    @staticmethod
    def intersection(plane: 'Plane', plane2: 'Plane', plane3: 'Plane') -> 'Vector3D': ...
    def isSimilarTo(self, plane: 'Plane') -> bool: ...
    def project(self, point: org.hipparchus.geometry.Point[Euclidean3D]) -> org.hipparchus.geometry.Point[Euclidean3D]: ...
    @typing.overload
    def reset(self, plane: 'Plane') -> None: ...
    @typing.overload
    def reset(self, vector3D: 'Vector3D', vector3D2: 'Vector3D') -> None: ...
    def revertSelf(self) -> None: ...
    def rotate(self, vector3D: 'Vector3D', rotation: 'Rotation') -> 'Plane': ...
    def sameOrientationAs(self, hyperplane: org.hipparchus.geometry.partitioning.Hyperplane[Euclidean3D]) -> bool: ...
    @typing.overload
    def toSpace(self, point: org.hipparchus.geometry.Point[org.hipparchus.geometry.euclidean.twod.Euclidean2D]) -> 'Vector3D': ...
    @typing.overload
    def toSpace(self, vector: org.hipparchus.geometry.Vector[org.hipparchus.geometry.euclidean.twod.Euclidean2D, org.hipparchus.geometry.euclidean.twod.Vector2D]) -> 'Vector3D': ...
    @typing.overload
    def toSubSpace(self, point: org.hipparchus.geometry.Point[Euclidean3D]) -> org.hipparchus.geometry.euclidean.twod.Vector2D: ...
    @typing.overload
    def toSubSpace(self, vector: org.hipparchus.geometry.Vector[Euclidean3D, 'Vector3D']) -> org.hipparchus.geometry.euclidean.twod.Vector2D: ...
    def translate(self, vector3D: 'Vector3D') -> 'Plane': ...
    def wholeHyperplane(self) -> 'SubPlane': ...
    def wholeSpace(self) -> 'PolyhedronsSet': ...

class PolyhedronsSet(org.hipparchus.geometry.partitioning.AbstractRegion[Euclidean3D, org.hipparchus.geometry.euclidean.twod.Euclidean2D]):
    @typing.overload
    def __init__(self, double: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float, double4: float, double5: float, double6: float, double7: float): ...
    @typing.overload
    def __init__(self, collection: typing.Union[java.util.Collection[org.hipparchus.geometry.partitioning.SubHyperplane[Euclidean3D]], typing.Sequence[org.hipparchus.geometry.partitioning.SubHyperplane[Euclidean3D]], typing.Set[org.hipparchus.geometry.partitioning.SubHyperplane[Euclidean3D]]], double: float): ...
    @typing.overload
    def __init__(self, list: java.util.List['Vector3D'], list2: java.util.List[typing.List[int]], double: float): ...
    @typing.overload
    def __init__(self, bRep: 'PolyhedronsSet.BRep', double: float): ...
    @typing.overload
    def __init__(self, bSPTree: org.hipparchus.geometry.partitioning.BSPTree[Euclidean3D], double: float): ...
    def buildNew(self, bSPTree: org.hipparchus.geometry.partitioning.BSPTree[Euclidean3D]) -> 'PolyhedronsSet': ...
    def firstIntersection(self, vector3D: 'Vector3D', line: Line) -> org.hipparchus.geometry.partitioning.SubHyperplane[Euclidean3D]: ...
    def getBRep(self) -> 'PolyhedronsSet.BRep': ...
    def rotate(self, vector3D: 'Vector3D', rotation: 'Rotation') -> 'PolyhedronsSet': ...
    def translate(self, vector3D: 'Vector3D') -> 'PolyhedronsSet': ...
    class BRep:
        def __init__(self, list: java.util.List['Vector3D'], list2: java.util.List[typing.List[int]]): ...
        def getFacets(self) -> java.util.List[typing.List[int]]: ...
        def getVertices(self) -> java.util.List['Vector3D']: ...

class Rotation(java.io.Serializable):
    IDENTITY: typing.ClassVar['Rotation'] = ...
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float, double4: float, boolean: bool): ...
    @typing.overload
    def __init__(self, doubleArray: typing.List[typing.List[float]], double2: float): ...
    @typing.overload
    def __init__(self, rotationOrder: 'RotationOrder', rotationConvention: 'RotationConvention', double: float, double2: float, double3: float): ...
    @typing.overload
    def __init__(self, vector3D: 'Vector3D', double: float, rotationConvention: 'RotationConvention'): ...
    @typing.overload
    def __init__(self, vector3D: 'Vector3D', vector3D2: 'Vector3D'): ...
    @typing.overload
    def __init__(self, vector3D: 'Vector3D', vector3D2: 'Vector3D', vector3D3: 'Vector3D', vector3D4: 'Vector3D'): ...
    @typing.overload
    def applyInverseTo(self, rotation: 'Rotation') -> 'Rotation': ...
    @typing.overload
    def applyInverseTo(self, vector3D: 'Vector3D') -> 'Vector3D': ...
    @typing.overload
    def applyInverseTo(self, doubleArray: typing.List[float], doubleArray2: typing.List[float]) -> None: ...
    @typing.overload
    def applyTo(self, rotation: 'Rotation') -> 'Rotation': ...
    @typing.overload
    def applyTo(self, vector3D: 'Vector3D') -> 'Vector3D': ...
    @typing.overload
    def applyTo(self, doubleArray: typing.List[float], doubleArray2: typing.List[float]) -> None: ...
    def compose(self, rotation: 'Rotation', rotationConvention: 'RotationConvention') -> 'Rotation': ...
    def composeInverse(self, rotation: 'Rotation', rotationConvention: 'RotationConvention') -> 'Rotation': ...
    @staticmethod
    def distance(rotation: 'Rotation', rotation2: 'Rotation') -> float: ...
    def getAngle(self) -> float: ...
    def getAngles(self, rotationOrder: 'RotationOrder', rotationConvention: 'RotationConvention') -> typing.List[float]: ...
    def getAxis(self, rotationConvention: 'RotationConvention') -> 'Vector3D': ...
    def getMatrix(self) -> typing.List[typing.List[float]]: ...
    def getQ0(self) -> float: ...
    def getQ1(self) -> float: ...
    def getQ2(self) -> float: ...
    def getQ3(self) -> float: ...
    def revert(self) -> 'Rotation': ...

class RotationConvention(java.lang.Enum['RotationConvention']):
    VECTOR_OPERATOR: typing.ClassVar['RotationConvention'] = ...
    FRAME_TRANSFORM: typing.ClassVar['RotationConvention'] = ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'RotationConvention': ...
    @staticmethod
    def values() -> typing.List['RotationConvention']: ...

class RotationOrder(java.lang.Enum['RotationOrder']):
    XYZ: typing.ClassVar['RotationOrder'] = ...
    XZY: typing.ClassVar['RotationOrder'] = ...
    YXZ: typing.ClassVar['RotationOrder'] = ...
    YZX: typing.ClassVar['RotationOrder'] = ...
    ZXY: typing.ClassVar['RotationOrder'] = ...
    ZYX: typing.ClassVar['RotationOrder'] = ...
    XYX: typing.ClassVar['RotationOrder'] = ...
    XZX: typing.ClassVar['RotationOrder'] = ...
    YXY: typing.ClassVar['RotationOrder'] = ...
    YZY: typing.ClassVar['RotationOrder'] = ...
    ZXZ: typing.ClassVar['RotationOrder'] = ...
    ZYZ: typing.ClassVar['RotationOrder'] = ...
    def getA1(self) -> 'Vector3D': ...
    def getA2(self) -> 'Vector3D': ...
    def getA3(self) -> 'Vector3D': ...
    _getAngles_1__T = typing.TypeVar('_getAngles_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def getAngles(self, rotation: Rotation, rotationConvention: RotationConvention) -> typing.List[float]: ...
    @typing.overload
    def getAngles(self, fieldRotation: FieldRotation[_getAngles_1__T], rotationConvention: RotationConvention) -> typing.List[_getAngles_1__T]: ...
    @staticmethod
    def getRotationOrder(string: str) -> 'RotationOrder': ...
    def toString(self) -> str: ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'RotationOrder': ...
    @staticmethod
    def values() -> typing.List['RotationOrder']: ...

class Segment:
    def __init__(self, vector3D: 'Vector3D', vector3D2: 'Vector3D', line: Line): ...
    def getEnd(self) -> 'Vector3D': ...
    def getLine(self) -> Line: ...
    def getStart(self) -> 'Vector3D': ...

class SphereGenerator(org.hipparchus.geometry.enclosing.SupportBallGenerator[Euclidean3D, 'Vector3D']):
    def __init__(self): ...
    def ballOnSupport(self, list: java.util.List['Vector3D']) -> org.hipparchus.geometry.enclosing.EnclosingBall[Euclidean3D, 'Vector3D']: ...

class SphericalCoordinates(java.io.Serializable):
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float): ...
    @typing.overload
    def __init__(self, vector3D: 'Vector3D'): ...
    def getCartesian(self) -> 'Vector3D': ...
    def getPhi(self) -> float: ...
    def getR(self) -> float: ...
    def getTheta(self) -> float: ...
    def toCartesianGradient(self, doubleArray: typing.List[float]) -> typing.List[float]: ...
    def toCartesianHessian(self, doubleArray: typing.List[typing.List[float]], doubleArray2: typing.List[float]) -> typing.List[typing.List[float]]: ...

class SubLine:
    @typing.overload
    def __init__(self, line: Line, intervalsSet: org.hipparchus.geometry.euclidean.oned.IntervalsSet): ...
    @typing.overload
    def __init__(self, segment: Segment): ...
    @typing.overload
    def __init__(self, vector3D: 'Vector3D', vector3D2: 'Vector3D', double: float): ...
    def getSegments(self) -> java.util.List[Segment]: ...
    def intersection(self, subLine: 'SubLine', boolean: bool) -> 'Vector3D': ...

class SubPlane(org.hipparchus.geometry.partitioning.AbstractSubHyperplane[Euclidean3D, org.hipparchus.geometry.euclidean.twod.Euclidean2D]):
    def __init__(self, hyperplane: org.hipparchus.geometry.partitioning.Hyperplane[Euclidean3D], region: org.hipparchus.geometry.partitioning.Region[org.hipparchus.geometry.euclidean.twod.Euclidean2D]): ...
    def split(self, hyperplane: org.hipparchus.geometry.partitioning.Hyperplane[Euclidean3D]) -> org.hipparchus.geometry.partitioning.SubHyperplane.SplitSubHyperplane[Euclidean3D]: ...

class Vector3D(java.io.Serializable, org.hipparchus.geometry.Vector[Euclidean3D, 'Vector3D']):
    ZERO: typing.ClassVar['Vector3D'] = ...
    PLUS_I: typing.ClassVar['Vector3D'] = ...
    MINUS_I: typing.ClassVar['Vector3D'] = ...
    PLUS_J: typing.ClassVar['Vector3D'] = ...
    MINUS_J: typing.ClassVar['Vector3D'] = ...
    PLUS_K: typing.ClassVar['Vector3D'] = ...
    MINUS_K: typing.ClassVar['Vector3D'] = ...
    NaN: typing.ClassVar['Vector3D'] = ...
    POSITIVE_INFINITY: typing.ClassVar['Vector3D'] = ...
    NEGATIVE_INFINITY: typing.ClassVar['Vector3D'] = ...
    @typing.overload
    def __init__(self, double: float, double2: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float): ...
    @typing.overload
    def __init__(self, double: float, vector3D: 'Vector3D'): ...
    @typing.overload
    def __init__(self, double: float, vector3D: 'Vector3D', double2: float, vector3D2: 'Vector3D'): ...
    @typing.overload
    def __init__(self, double: float, vector3D: 'Vector3D', double2: float, vector3D2: 'Vector3D', double3: float, vector3D3: 'Vector3D'): ...
    @typing.overload
    def __init__(self, double: float, vector3D: 'Vector3D', double2: float, vector3D2: 'Vector3D', double3: float, vector3D3: 'Vector3D', double4: float, vector3D4: 'Vector3D'): ...
    @typing.overload
    def __init__(self, doubleArray: typing.List[float]): ...
    @typing.overload
    def add(self, double: float, vector: org.hipparchus.geometry.Vector[Euclidean3D, 'Vector3D']) -> 'Vector3D': ...
    @typing.overload
    def add(self, vector: org.hipparchus.geometry.Vector[Euclidean3D, 'Vector3D']) -> 'Vector3D': ...
    @staticmethod
    def angle(vector3D: 'Vector3D', vector3D2: 'Vector3D') -> float: ...
    @typing.overload
    def crossProduct(self, vector: org.hipparchus.geometry.Vector[Euclidean3D, 'Vector3D']) -> 'Vector3D': ...
    @typing.overload
    @staticmethod
    def crossProduct(vector3D: 'Vector3D', vector3D2: 'Vector3D') -> 'Vector3D': ...
    @typing.overload
    def distance(self, point: org.hipparchus.geometry.Point[Euclidean3D]) -> float: ...
    @typing.overload
    @staticmethod
    def distance(vector3D: 'Vector3D', vector3D2: 'Vector3D') -> float: ...
    @typing.overload
    def distance1(self, vector: org.hipparchus.geometry.Vector[Euclidean3D, 'Vector3D']) -> float: ...
    @typing.overload
    @staticmethod
    def distance1(vector3D: 'Vector3D', vector3D2: 'Vector3D') -> float: ...
    @typing.overload
    def distanceInf(self, vector: org.hipparchus.geometry.Vector[Euclidean3D, 'Vector3D']) -> float: ...
    @typing.overload
    @staticmethod
    def distanceInf(vector3D: 'Vector3D', vector3D2: 'Vector3D') -> float: ...
    @typing.overload
    def distanceSq(self, vector: org.hipparchus.geometry.Vector[Euclidean3D, 'Vector3D']) -> float: ...
    @typing.overload
    @staticmethod
    def distanceSq(vector3D: 'Vector3D', vector3D2: 'Vector3D') -> float: ...
    @typing.overload
    def dotProduct(self, vector: org.hipparchus.geometry.Vector[Euclidean3D, 'Vector3D']) -> float: ...
    @typing.overload
    @staticmethod
    def dotProduct(vector3D: 'Vector3D', vector3D2: 'Vector3D') -> float: ...
    def equals(self, object: typing.Any) -> bool: ...
    def equalsIeee754(self, object: typing.Any) -> bool: ...
    def getAlpha(self) -> float: ...
    def getDelta(self) -> float: ...
    def getNorm(self) -> float: ...
    def getNorm1(self) -> float: ...
    def getNormInf(self) -> float: ...
    def getNormSq(self) -> float: ...
    def getSpace(self) -> org.hipparchus.geometry.Space: ...
    def getX(self) -> float: ...
    def getY(self) -> float: ...
    def getZ(self) -> float: ...
    def getZero(self) -> 'Vector3D': ...
    def hashCode(self) -> int: ...
    def isInfinite(self) -> bool: ...
    def isNaN(self) -> bool: ...
    def negate(self) -> 'Vector3D': ...
    def orthogonal(self) -> 'Vector3D': ...
    def scalarMultiply(self, double: float) -> 'Vector3D': ...
    @typing.overload
    def subtract(self, double: float, vector: org.hipparchus.geometry.Vector[Euclidean3D, 'Vector3D']) -> 'Vector3D': ...
    @typing.overload
    def subtract(self, vector: org.hipparchus.geometry.Vector[Euclidean3D, 'Vector3D']) -> 'Vector3D': ...
    def toArray(self) -> typing.List[float]: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    def toString(self, numberFormat: java.text.NumberFormat) -> str: ...

class Vector3DFormat(org.hipparchus.geometry.VectorFormat[Euclidean3D, Vector3D]):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: str, string2: str, string3: str): ...
    @typing.overload
    def __init__(self, string: str, string2: str, string3: str, numberFormat: java.text.NumberFormat): ...
    @typing.overload
    def __init__(self, numberFormat: java.text.NumberFormat): ...
    @typing.overload
    def format(self, vector: org.hipparchus.geometry.Vector[org.hipparchus.geometry.Space, org.hipparchus.geometry.Vector]) -> str: ...
    @typing.overload
    def format(self, vector: org.hipparchus.geometry.Vector[Euclidean3D, Vector3D], stringBuffer: java.lang.StringBuffer, fieldPosition: java.text.FieldPosition) -> java.lang.StringBuffer: ...
    @typing.overload
    @staticmethod
    def getVector3DFormat() -> 'Vector3DFormat': ...
    @typing.overload
    @staticmethod
    def getVector3DFormat(locale: java.util.Locale) -> 'Vector3DFormat': ...
    @typing.overload
    def parse(self, string: str) -> Vector3D: ...
    @typing.overload
    def parse(self, string: str, parsePosition: java.text.ParsePosition) -> Vector3D: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.hipparchus.geometry.euclidean.threed")``.

    Euclidean3D: typing.Type[Euclidean3D]
    FieldLine: typing.Type[FieldLine]
    FieldRotation: typing.Type[FieldRotation]
    FieldVector3D: typing.Type[FieldVector3D]
    Line: typing.Type[Line]
    OutlineExtractor: typing.Type[OutlineExtractor]
    Plane: typing.Type[Plane]
    PolyhedronsSet: typing.Type[PolyhedronsSet]
    Rotation: typing.Type[Rotation]
    RotationConvention: typing.Type[RotationConvention]
    RotationOrder: typing.Type[RotationOrder]
    Segment: typing.Type[Segment]
    SphereGenerator: typing.Type[SphereGenerator]
    SphericalCoordinates: typing.Type[SphericalCoordinates]
    SubLine: typing.Type[SubLine]
    SubPlane: typing.Type[SubPlane]
    Vector3D: typing.Type[Vector3D]
    Vector3DFormat: typing.Type[Vector3DFormat]
