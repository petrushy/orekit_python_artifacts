import org.hipparchus
import org.hipparchus.linear
import org.hipparchus.ode
import org.hipparchus.ode.nonstiff.class-use
import typing



_AdamsFieldIntegrator__T = typing.TypeVar('_AdamsFieldIntegrator__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
class AdamsFieldIntegrator(org.hipparchus.ode.MultistepFieldIntegrator[_AdamsFieldIntegrator__T], typing.Generic[_AdamsFieldIntegrator__T]):
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_AdamsFieldIntegrator__T], string: str, int: int, int2: int, double: float, double2: float, double3: float, double4: float): ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_AdamsFieldIntegrator__T], string: str, int: int, int2: int, double: float, double2: float, doubleArray: typing.List[float], doubleArray2: typing.List[float]): ...
    def integrate(self, fieldExpandableODE: org.hipparchus.ode.FieldExpandableODE[_AdamsFieldIntegrator__T], fieldODEState: org.hipparchus.ode.FieldODEState[_AdamsFieldIntegrator__T], t: _AdamsFieldIntegrator__T) -> org.hipparchus.ode.FieldODEStateAndDerivative[_AdamsFieldIntegrator__T]: ...
    def updateHighOrderDerivativesPhase1(self, array2DRowFieldMatrix: org.hipparchus.linear.Array2DRowFieldMatrix[_AdamsFieldIntegrator__T]) -> org.hipparchus.linear.Array2DRowFieldMatrix[_AdamsFieldIntegrator__T]: ...
    def updateHighOrderDerivativesPhase2(self, tArray: typing.List[_AdamsFieldIntegrator__T], tArray2: typing.List[_AdamsFieldIntegrator__T], array2DRowFieldMatrix: org.hipparchus.linear.Array2DRowFieldMatrix[_AdamsFieldIntegrator__T]) -> None: ...

class AdamsIntegrator(org.hipparchus.ode.MultistepIntegrator):
    @typing.overload
    def __init__(self, string: str, int: int, int2: int, double: float, double2: float, double3: float, double4: float): ...
    @typing.overload
    def __init__(self, string: str, int: int, int2: int, double: float, double2: float, doubleArray: typing.List[float], doubleArray2: typing.List[float]): ...
    @typing.overload
    def integrate(self, ordinaryDifferentialEquation: org.hipparchus.ode.OrdinaryDifferentialEquation, oDEState: org.hipparchus.ode.ODEState, double: float) -> org.hipparchus.ode.ODEStateAndDerivative: ...
    @typing.overload
    def integrate(self, expandableODE: org.hipparchus.ode.ExpandableODE, oDEState: org.hipparchus.ode.ODEState, double: float) -> org.hipparchus.ode.ODEStateAndDerivative: ...
    def updateHighOrderDerivativesPhase1(self, array2DRowRealMatrix: org.hipparchus.linear.Array2DRowRealMatrix) -> org.hipparchus.linear.Array2DRowRealMatrix: ...
    def updateHighOrderDerivativesPhase2(self, doubleArray: typing.List[float], doubleArray2: typing.List[float], array2DRowRealMatrix: org.hipparchus.linear.Array2DRowRealMatrix) -> None: ...

_AdamsNordsieckFieldTransformer__T = typing.TypeVar('_AdamsNordsieckFieldTransformer__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
class AdamsNordsieckFieldTransformer(typing.Generic[_AdamsNordsieckFieldTransformer__T]):
    _getInstance__T = typing.TypeVar('_getInstance__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @staticmethod
    def getInstance(field: org.hipparchus.Field[_getInstance__T], int: int) -> 'AdamsNordsieckFieldTransformer'[_getInstance__T]: ...
    def initializeHighOrderDerivatives(self, t: _AdamsNordsieckFieldTransformer__T, tArray: typing.List[_AdamsNordsieckFieldTransformer__T], tArray2: typing.List[typing.List[_AdamsNordsieckFieldTransformer__T]], tArray3: typing.List[typing.List[_AdamsNordsieckFieldTransformer__T]]) -> org.hipparchus.linear.Array2DRowFieldMatrix[_AdamsNordsieckFieldTransformer__T]: ...
    def updateHighOrderDerivativesPhase1(self, array2DRowFieldMatrix: org.hipparchus.linear.Array2DRowFieldMatrix[_AdamsNordsieckFieldTransformer__T]) -> org.hipparchus.linear.Array2DRowFieldMatrix[_AdamsNordsieckFieldTransformer__T]: ...
    def updateHighOrderDerivativesPhase2(self, tArray: typing.List[_AdamsNordsieckFieldTransformer__T], tArray2: typing.List[_AdamsNordsieckFieldTransformer__T], array2DRowFieldMatrix: org.hipparchus.linear.Array2DRowFieldMatrix[_AdamsNordsieckFieldTransformer__T]) -> None: ...

class AdamsNordsieckTransformer:
    @staticmethod
    def getInstance(int: int) -> 'AdamsNordsieckTransformer': ...
    def initializeHighOrderDerivatives(self, double: float, doubleArray: typing.List[float], doubleArray2: typing.List[typing.List[float]], doubleArray3: typing.List[typing.List[float]]) -> org.hipparchus.linear.Array2DRowRealMatrix: ...
    def updateHighOrderDerivativesPhase1(self, array2DRowRealMatrix: org.hipparchus.linear.Array2DRowRealMatrix) -> org.hipparchus.linear.Array2DRowRealMatrix: ...
    def updateHighOrderDerivativesPhase2(self, doubleArray: typing.List[float], doubleArray2: typing.List[float], array2DRowRealMatrix: org.hipparchus.linear.Array2DRowRealMatrix) -> None: ...

_AdaptiveStepsizeFieldIntegrator__T = typing.TypeVar('_AdaptiveStepsizeFieldIntegrator__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
class AdaptiveStepsizeFieldIntegrator(org.hipparchus.ode.AbstractFieldIntegrator[_AdaptiveStepsizeFieldIntegrator__T], typing.Generic[_AdaptiveStepsizeFieldIntegrator__T]):
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_AdaptiveStepsizeFieldIntegrator__T], string: str, double: float, double2: float, double3: float, double4: float): ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_AdaptiveStepsizeFieldIntegrator__T], string: str, double: float, double2: float, doubleArray: typing.List[float], doubleArray2: typing.List[float]): ...
    def getMaxStep(self) -> float: ...
    def getMinStep(self) -> float: ...
    def initializeStep(self, boolean: bool, int: int, tArray: typing.List[_AdaptiveStepsizeFieldIntegrator__T], fieldODEStateAndDerivative: org.hipparchus.ode.FieldODEStateAndDerivative[_AdaptiveStepsizeFieldIntegrator__T], fieldEquationsMapper: org.hipparchus.ode.FieldEquationsMapper[_AdaptiveStepsizeFieldIntegrator__T]) -> float: ...
    def setInitialStepSize(self, double: float) -> None: ...
    @typing.overload
    def setStepSizeControl(self, double: float, double2: float, double3: float, double4: float) -> None: ...
    @typing.overload
    def setStepSizeControl(self, double: float, double2: float, doubleArray: typing.List[float], doubleArray2: typing.List[float]) -> None: ...

class AdaptiveStepsizeIntegrator(org.hipparchus.ode.AbstractIntegrator):
    @typing.overload
    def __init__(self, string: str, double: float, double2: float, double3: float, double4: float): ...
    @typing.overload
    def __init__(self, string: str, double: float, double2: float, doubleArray: typing.List[float], doubleArray2: typing.List[float]): ...
    def getMaxStep(self) -> float: ...
    def getMinStep(self) -> float: ...
    def initializeStep(self, boolean: bool, int: int, doubleArray: typing.List[float], oDEStateAndDerivative: org.hipparchus.ode.ODEStateAndDerivative) -> float: ...
    def setInitialStepSize(self, double: float) -> None: ...
    @typing.overload
    def setStepSizeControl(self, double: float, double2: float, double3: float, double4: float) -> None: ...
    @typing.overload
    def setStepSizeControl(self, double: float, double2: float, doubleArray: typing.List[float], doubleArray2: typing.List[float]) -> None: ...

class ButcherArrayProvider:
    def getA(self) -> typing.List[typing.List[float]]: ...
    def getB(self) -> typing.List[float]: ...
    def getC(self) -> typing.List[float]: ...

_FieldButcherArrayProvider__T = typing.TypeVar('_FieldButcherArrayProvider__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
class FieldButcherArrayProvider(typing.Generic[_FieldButcherArrayProvider__T]):
    def getA(self) -> typing.List[typing.List[_FieldButcherArrayProvider__T]]: ...
    def getB(self) -> typing.List[_FieldButcherArrayProvider__T]: ...
    def getC(self) -> typing.List[_FieldButcherArrayProvider__T]: ...

class StepsizeHelper:
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float, double4: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float, doubleArray: typing.List[float], doubleArray2: typing.List[float]): ...
    _filterStep_1__T = typing.TypeVar('_filterStep_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def filterStep(self, double: float, boolean: bool, boolean2: bool) -> float: ...
    @typing.overload
    def filterStep(self, t: _filterStep_1__T, boolean: bool, boolean2: bool) -> _filterStep_1__T: ...
    def getDummyStepsize(self) -> float: ...
    def getInitialStep(self) -> float: ...
    def getMainSetDimension(self) -> int: ...
    def getMaxStep(self) -> float: ...
    def getMinStep(self) -> float: ...
    def getRelativeTolerance(self, int: int) -> float: ...
    _getTolerance_1__T = typing.TypeVar('_getTolerance_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def getTolerance(self, int: int, double: float) -> float: ...
    @typing.overload
    def getTolerance(self, int: int, t: _getTolerance_1__T) -> _getTolerance_1__T: ...
    def setInitialStepSize(self, double: float) -> None: ...

_AdamsBashforthFieldIntegrator__T = typing.TypeVar('_AdamsBashforthFieldIntegrator__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
class AdamsBashforthFieldIntegrator(AdamsFieldIntegrator[_AdamsBashforthFieldIntegrator__T], typing.Generic[_AdamsBashforthFieldIntegrator__T]):
    METHOD_NAME: typing.ClassVar[str] = ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_AdamsBashforthFieldIntegrator__T], int: int, double: float, double2: float, double3: float, double4: float): ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_AdamsBashforthFieldIntegrator__T], int: int, double: float, double2: float, doubleArray: typing.List[float], doubleArray2: typing.List[float]): ...

class AdamsBashforthIntegrator(AdamsIntegrator):
    METHOD_NAME: typing.ClassVar[str] = ...
    @typing.overload
    def __init__(self, int: int, double: float, double2: float, double3: float, double4: float): ...
    @typing.overload
    def __init__(self, int: int, double: float, double2: float, doubleArray: typing.List[float], doubleArray2: typing.List[float]): ...

_AdamsMoultonFieldIntegrator__T = typing.TypeVar('_AdamsMoultonFieldIntegrator__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
class AdamsMoultonFieldIntegrator(AdamsFieldIntegrator[_AdamsMoultonFieldIntegrator__T], typing.Generic[_AdamsMoultonFieldIntegrator__T]):
    METHOD_NAME: typing.ClassVar[str] = ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_AdamsMoultonFieldIntegrator__T], int: int, double: float, double2: float, double3: float, double4: float): ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_AdamsMoultonFieldIntegrator__T], int: int, double: float, double2: float, doubleArray: typing.List[float], doubleArray2: typing.List[float]): ...

class AdamsMoultonIntegrator(AdamsIntegrator):
    METHOD_NAME: typing.ClassVar[str] = ...
    @typing.overload
    def __init__(self, int: int, double: float, double2: float, double3: float, double4: float): ...
    @typing.overload
    def __init__(self, int: int, double: float, double2: float, doubleArray: typing.List[float], doubleArray2: typing.List[float]): ...

class ExplicitRungeKuttaIntegrator(ButcherArrayProvider, org.hipparchus.ode.ODEIntegrator):
    @staticmethod
    def applyExternalButcherWeights(doubleArray: typing.List[float], doubleArray2: typing.List[typing.List[float]], double3: float, doubleArray3: typing.List[float]) -> typing.List[float]: ...
    @staticmethod
    def applyInternalButcherWeights(expandableODE: org.hipparchus.ode.ExpandableODE, double: float, doubleArray: typing.List[float], double3: float, doubleArray2: typing.List[typing.List[float]], doubleArray3: typing.List[float], doubleArray4: typing.List[typing.List[float]]) -> None: ...
    def getNumberOfStages(self) -> int: ...
    def singleStep(self, ordinaryDifferentialEquation: org.hipparchus.ode.OrdinaryDifferentialEquation, double: float, doubleArray: typing.List[float], double3: float) -> typing.List[float]: ...

_FieldExplicitRungeKuttaIntegrator__T = typing.TypeVar('_FieldExplicitRungeKuttaIntegrator__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
class FieldExplicitRungeKuttaIntegrator(FieldButcherArrayProvider[_FieldExplicitRungeKuttaIntegrator__T], org.hipparchus.ode.FieldODEIntegrator[_FieldExplicitRungeKuttaIntegrator__T], typing.Generic[_FieldExplicitRungeKuttaIntegrator__T]):
    _applyExternalButcherWeights_0__T = typing.TypeVar('_applyExternalButcherWeights_0__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _applyExternalButcherWeights_1__T = typing.TypeVar('_applyExternalButcherWeights_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def applyExternalButcherWeights(tArray: typing.List[_applyExternalButcherWeights_0__T], tArray2: typing.List[typing.List[_applyExternalButcherWeights_0__T]], t3: _applyExternalButcherWeights_0__T, doubleArray: typing.List[float]) -> typing.List[_applyExternalButcherWeights_0__T]: ...
    @typing.overload
    @staticmethod
    def applyExternalButcherWeights(tArray: typing.List[_applyExternalButcherWeights_1__T], tArray2: typing.List[typing.List[_applyExternalButcherWeights_1__T]], t3: _applyExternalButcherWeights_1__T, tArray3: typing.List[_applyExternalButcherWeights_1__T]) -> typing.List[_applyExternalButcherWeights_1__T]: ...
    _applyInternalButcherWeights_0__T = typing.TypeVar('_applyInternalButcherWeights_0__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _applyInternalButcherWeights_1__T = typing.TypeVar('_applyInternalButcherWeights_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def applyInternalButcherWeights(fieldExpandableODE: org.hipparchus.ode.FieldExpandableODE[_applyInternalButcherWeights_0__T], t: _applyInternalButcherWeights_0__T, tArray: typing.List[_applyInternalButcherWeights_0__T], t3: _applyInternalButcherWeights_0__T, doubleArray: typing.List[typing.List[float]], doubleArray2: typing.List[float], tArray2: typing.List[typing.List[_applyInternalButcherWeights_0__T]]) -> None: ...
    @typing.overload
    @staticmethod
    def applyInternalButcherWeights(fieldExpandableODE: org.hipparchus.ode.FieldExpandableODE[_applyInternalButcherWeights_1__T], t: _applyInternalButcherWeights_1__T, tArray: typing.List[_applyInternalButcherWeights_1__T], t3: _applyInternalButcherWeights_1__T, tArray2: typing.List[typing.List[_applyInternalButcherWeights_1__T]], tArray3: typing.List[_applyInternalButcherWeights_1__T], tArray4: typing.List[typing.List[_applyInternalButcherWeights_1__T]]) -> None: ...
    _fraction_0__T = typing.TypeVar('_fraction_0__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _fraction_1__T = typing.TypeVar('_fraction_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def fraction(field: org.hipparchus.Field[_fraction_0__T], double: float, double2: float) -> _fraction_0__T: ...
    @typing.overload
    @staticmethod
    def fraction(field: org.hipparchus.Field[_fraction_1__T], int: int, int2: int) -> _fraction_1__T: ...
    def getNumberOfStages(self) -> int: ...
    def getRealA(self) -> typing.List[typing.List[float]]: ...
    def getRealB(self) -> typing.List[float]: ...
    def getRealC(self) -> typing.List[float]: ...
    def isUsingFieldCoefficients(self) -> bool: ...
    def singleStep(self, fieldOrdinaryDifferentialEquation: org.hipparchus.ode.FieldOrdinaryDifferentialEquation[_FieldExplicitRungeKuttaIntegrator__T], t: _FieldExplicitRungeKuttaIntegrator__T, tArray: typing.List[_FieldExplicitRungeKuttaIntegrator__T], t3: _FieldExplicitRungeKuttaIntegrator__T) -> typing.List[_FieldExplicitRungeKuttaIntegrator__T]: ...

class GraggBulirschStoerIntegrator(AdaptiveStepsizeIntegrator):
    METHOD_NAME: typing.ClassVar[str] = ...
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float, double4: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float, doubleArray: typing.List[float], doubleArray2: typing.List[float]): ...
    @typing.overload
    def integrate(self, ordinaryDifferentialEquation: org.hipparchus.ode.OrdinaryDifferentialEquation, oDEState: org.hipparchus.ode.ODEState, double: float) -> org.hipparchus.ode.ODEStateAndDerivative: ...
    @typing.overload
    def integrate(self, expandableODE: org.hipparchus.ode.ExpandableODE, oDEState: org.hipparchus.ode.ODEState, double: float) -> org.hipparchus.ode.ODEStateAndDerivative: ...
    def setControlFactors(self, double: float, double2: float, double3: float, double4: float) -> None: ...
    def setInterpolationControl(self, boolean: bool, int: int) -> None: ...
    def setOrderControl(self, int: int, double: float, double2: float) -> None: ...
    def setStabilityCheck(self, boolean: bool, int: int, int2: int, double: float) -> None: ...

_EmbeddedRungeKuttaFieldIntegrator__T = typing.TypeVar('_EmbeddedRungeKuttaFieldIntegrator__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
class EmbeddedRungeKuttaFieldIntegrator(AdaptiveStepsizeFieldIntegrator[_EmbeddedRungeKuttaFieldIntegrator__T], FieldExplicitRungeKuttaIntegrator[_EmbeddedRungeKuttaFieldIntegrator__T], typing.Generic[_EmbeddedRungeKuttaFieldIntegrator__T]):
    def getMaxGrowth(self) -> _EmbeddedRungeKuttaFieldIntegrator__T: ...
    def getMinReduction(self) -> _EmbeddedRungeKuttaFieldIntegrator__T: ...
    def getNumberOfStages(self) -> int: ...
    def getOrder(self) -> int: ...
    def getSafety(self) -> _EmbeddedRungeKuttaFieldIntegrator__T: ...
    def integrate(self, fieldExpandableODE: org.hipparchus.ode.FieldExpandableODE[_EmbeddedRungeKuttaFieldIntegrator__T], fieldODEState: org.hipparchus.ode.FieldODEState[_EmbeddedRungeKuttaFieldIntegrator__T], t: _EmbeddedRungeKuttaFieldIntegrator__T) -> org.hipparchus.ode.FieldODEStateAndDerivative[_EmbeddedRungeKuttaFieldIntegrator__T]: ...
    def isUsingFieldCoefficients(self) -> bool: ...
    def setMaxGrowth(self, t: _EmbeddedRungeKuttaFieldIntegrator__T) -> None: ...
    def setMinReduction(self, t: _EmbeddedRungeKuttaFieldIntegrator__T) -> None: ...
    def setSafety(self, t: _EmbeddedRungeKuttaFieldIntegrator__T) -> None: ...
    def setUsingFieldCoefficients(self, boolean: bool) -> None: ...

class EmbeddedRungeKuttaIntegrator(AdaptiveStepsizeIntegrator, ExplicitRungeKuttaIntegrator):
    def getMaxGrowth(self) -> float: ...
    def getMinReduction(self) -> float: ...
    def getOrder(self) -> int: ...
    def getSafety(self) -> float: ...
    @typing.overload
    def integrate(self, ordinaryDifferentialEquation: org.hipparchus.ode.OrdinaryDifferentialEquation, oDEState: org.hipparchus.ode.ODEState, double: float) -> org.hipparchus.ode.ODEStateAndDerivative: ...
    @typing.overload
    def integrate(self, expandableODE: org.hipparchus.ode.ExpandableODE, oDEState: org.hipparchus.ode.ODEState, double: float) -> org.hipparchus.ode.ODEStateAndDerivative: ...
    def setMaxGrowth(self, double: float) -> None: ...
    def setMinReduction(self, double: float) -> None: ...
    def setSafety(self, double: float) -> None: ...

_RungeKuttaFieldIntegrator__T = typing.TypeVar('_RungeKuttaFieldIntegrator__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
class RungeKuttaFieldIntegrator(org.hipparchus.ode.AbstractFieldIntegrator[_RungeKuttaFieldIntegrator__T], FieldExplicitRungeKuttaIntegrator[_RungeKuttaFieldIntegrator__T], typing.Generic[_RungeKuttaFieldIntegrator__T]):
    def getDefaultStep(self) -> _RungeKuttaFieldIntegrator__T: ...
    def getNumberOfStages(self) -> int: ...
    def integrate(self, fieldExpandableODE: org.hipparchus.ode.FieldExpandableODE[_RungeKuttaFieldIntegrator__T], fieldODEState: org.hipparchus.ode.FieldODEState[_RungeKuttaFieldIntegrator__T], t: _RungeKuttaFieldIntegrator__T) -> org.hipparchus.ode.FieldODEStateAndDerivative[_RungeKuttaFieldIntegrator__T]: ...
    def isUsingFieldCoefficients(self) -> bool: ...
    def setUsingFieldCoefficients(self, boolean: bool) -> None: ...

class RungeKuttaIntegrator(org.hipparchus.ode.AbstractIntegrator, ExplicitRungeKuttaIntegrator):
    def getDefaultStep(self) -> float: ...
    @typing.overload
    def integrate(self, ordinaryDifferentialEquation: org.hipparchus.ode.OrdinaryDifferentialEquation, oDEState: org.hipparchus.ode.ODEState, double: float) -> org.hipparchus.ode.ODEStateAndDerivative: ...
    @typing.overload
    def integrate(self, expandableODE: org.hipparchus.ode.ExpandableODE, oDEState: org.hipparchus.ode.ODEState, double: float) -> org.hipparchus.ode.ODEStateAndDerivative: ...

_ClassicalRungeKuttaFieldIntegrator__T = typing.TypeVar('_ClassicalRungeKuttaFieldIntegrator__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
class ClassicalRungeKuttaFieldIntegrator(RungeKuttaFieldIntegrator[_ClassicalRungeKuttaFieldIntegrator__T], typing.Generic[_ClassicalRungeKuttaFieldIntegrator__T]):
    METHOD_NAME: typing.ClassVar[str] = ...
    def __init__(self, field: org.hipparchus.Field[_ClassicalRungeKuttaFieldIntegrator__T], t: _ClassicalRungeKuttaFieldIntegrator__T): ...
    def getA(self) -> typing.List[typing.List[_ClassicalRungeKuttaFieldIntegrator__T]]: ...
    def getB(self) -> typing.List[_ClassicalRungeKuttaFieldIntegrator__T]: ...
    def getC(self) -> typing.List[_ClassicalRungeKuttaFieldIntegrator__T]: ...

class ClassicalRungeKuttaIntegrator(RungeKuttaIntegrator):
    METHOD_NAME: typing.ClassVar[str] = ...
    def __init__(self, double: float): ...
    def getA(self) -> typing.List[typing.List[float]]: ...
    def getB(self) -> typing.List[float]: ...
    def getC(self) -> typing.List[float]: ...

_DormandPrince54FieldIntegrator__T = typing.TypeVar('_DormandPrince54FieldIntegrator__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
class DormandPrince54FieldIntegrator(EmbeddedRungeKuttaFieldIntegrator[_DormandPrince54FieldIntegrator__T], typing.Generic[_DormandPrince54FieldIntegrator__T]):
    METHOD_NAME: typing.ClassVar[str] = ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_DormandPrince54FieldIntegrator__T], double: float, double2: float, double3: float, double4: float): ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_DormandPrince54FieldIntegrator__T], double: float, double2: float, doubleArray: typing.List[float], doubleArray2: typing.List[float]): ...
    def getA(self) -> typing.List[typing.List[_DormandPrince54FieldIntegrator__T]]: ...
    def getB(self) -> typing.List[_DormandPrince54FieldIntegrator__T]: ...
    def getC(self) -> typing.List[_DormandPrince54FieldIntegrator__T]: ...
    def getOrder(self) -> int: ...

class DormandPrince54Integrator(EmbeddedRungeKuttaIntegrator):
    METHOD_NAME: typing.ClassVar[str] = ...
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float, double4: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float, doubleArray: typing.List[float], doubleArray2: typing.List[float]): ...
    def getA(self) -> typing.List[typing.List[float]]: ...
    def getB(self) -> typing.List[float]: ...
    def getC(self) -> typing.List[float]: ...
    def getOrder(self) -> int: ...

_DormandPrince853FieldIntegrator__T = typing.TypeVar('_DormandPrince853FieldIntegrator__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
class DormandPrince853FieldIntegrator(EmbeddedRungeKuttaFieldIntegrator[_DormandPrince853FieldIntegrator__T], typing.Generic[_DormandPrince853FieldIntegrator__T]):
    METHOD_NAME: typing.ClassVar[str] = ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_DormandPrince853FieldIntegrator__T], double: float, double2: float, double3: float, double4: float): ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_DormandPrince853FieldIntegrator__T], double: float, double2: float, doubleArray: typing.List[float], doubleArray2: typing.List[float]): ...
    def getA(self) -> typing.List[typing.List[_DormandPrince853FieldIntegrator__T]]: ...
    def getB(self) -> typing.List[_DormandPrince853FieldIntegrator__T]: ...
    def getC(self) -> typing.List[_DormandPrince853FieldIntegrator__T]: ...
    def getOrder(self) -> int: ...

class DormandPrince853Integrator(EmbeddedRungeKuttaIntegrator):
    METHOD_NAME: typing.ClassVar[str] = ...
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float, double4: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float, doubleArray: typing.List[float], doubleArray2: typing.List[float]): ...
    def getA(self) -> typing.List[typing.List[float]]: ...
    def getB(self) -> typing.List[float]: ...
    def getC(self) -> typing.List[float]: ...
    def getOrder(self) -> int: ...

_EulerFieldIntegrator__T = typing.TypeVar('_EulerFieldIntegrator__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
class EulerFieldIntegrator(RungeKuttaFieldIntegrator[_EulerFieldIntegrator__T], typing.Generic[_EulerFieldIntegrator__T]):
    METHOD_NAME: typing.ClassVar[str] = ...
    def __init__(self, field: org.hipparchus.Field[_EulerFieldIntegrator__T], t: _EulerFieldIntegrator__T): ...
    def getA(self) -> typing.List[typing.List[_EulerFieldIntegrator__T]]: ...
    def getB(self) -> typing.List[_EulerFieldIntegrator__T]: ...
    def getC(self) -> typing.List[_EulerFieldIntegrator__T]: ...

class EulerIntegrator(RungeKuttaIntegrator):
    METHOD_NAME: typing.ClassVar[str] = ...
    def __init__(self, double: float): ...
    def getA(self) -> typing.List[typing.List[float]]: ...
    def getB(self) -> typing.List[float]: ...
    def getC(self) -> typing.List[float]: ...

_GillFieldIntegrator__T = typing.TypeVar('_GillFieldIntegrator__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
class GillFieldIntegrator(RungeKuttaFieldIntegrator[_GillFieldIntegrator__T], typing.Generic[_GillFieldIntegrator__T]):
    METHOD_NAME: typing.ClassVar[str] = ...
    def __init__(self, field: org.hipparchus.Field[_GillFieldIntegrator__T], t: _GillFieldIntegrator__T): ...
    def getA(self) -> typing.List[typing.List[_GillFieldIntegrator__T]]: ...
    def getB(self) -> typing.List[_GillFieldIntegrator__T]: ...
    def getC(self) -> typing.List[_GillFieldIntegrator__T]: ...

class GillIntegrator(RungeKuttaIntegrator):
    METHOD_NAME: typing.ClassVar[str] = ...
    def __init__(self, double: float): ...
    def getA(self) -> typing.List[typing.List[float]]: ...
    def getB(self) -> typing.List[float]: ...
    def getC(self) -> typing.List[float]: ...

_HighamHall54FieldIntegrator__T = typing.TypeVar('_HighamHall54FieldIntegrator__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
class HighamHall54FieldIntegrator(EmbeddedRungeKuttaFieldIntegrator[_HighamHall54FieldIntegrator__T], typing.Generic[_HighamHall54FieldIntegrator__T]):
    METHOD_NAME: typing.ClassVar[str] = ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_HighamHall54FieldIntegrator__T], double: float, double2: float, double3: float, double4: float): ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_HighamHall54FieldIntegrator__T], double: float, double2: float, doubleArray: typing.List[float], doubleArray2: typing.List[float]): ...
    def getA(self) -> typing.List[typing.List[_HighamHall54FieldIntegrator__T]]: ...
    def getB(self) -> typing.List[_HighamHall54FieldIntegrator__T]: ...
    def getC(self) -> typing.List[_HighamHall54FieldIntegrator__T]: ...
    def getOrder(self) -> int: ...

class HighamHall54Integrator(EmbeddedRungeKuttaIntegrator):
    METHOD_NAME: typing.ClassVar[str] = ...
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float, double4: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float, doubleArray: typing.List[float], doubleArray2: typing.List[float]): ...
    def getA(self) -> typing.List[typing.List[float]]: ...
    def getB(self) -> typing.List[float]: ...
    def getC(self) -> typing.List[float]: ...
    def getOrder(self) -> int: ...

_LutherFieldIntegrator__T = typing.TypeVar('_LutherFieldIntegrator__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
class LutherFieldIntegrator(RungeKuttaFieldIntegrator[_LutherFieldIntegrator__T], typing.Generic[_LutherFieldIntegrator__T]):
    METHOD_NAME: typing.ClassVar[str] = ...
    def __init__(self, field: org.hipparchus.Field[_LutherFieldIntegrator__T], t: _LutherFieldIntegrator__T): ...
    def getA(self) -> typing.List[typing.List[_LutherFieldIntegrator__T]]: ...
    def getB(self) -> typing.List[_LutherFieldIntegrator__T]: ...
    def getC(self) -> typing.List[_LutherFieldIntegrator__T]: ...

class LutherIntegrator(RungeKuttaIntegrator):
    METHOD_NAME: typing.ClassVar[str] = ...
    def __init__(self, double: float): ...
    def getA(self) -> typing.List[typing.List[float]]: ...
    def getB(self) -> typing.List[float]: ...
    def getC(self) -> typing.List[float]: ...

_MidpointFieldIntegrator__T = typing.TypeVar('_MidpointFieldIntegrator__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
class MidpointFieldIntegrator(RungeKuttaFieldIntegrator[_MidpointFieldIntegrator__T], typing.Generic[_MidpointFieldIntegrator__T]):
    METHOD_NAME: typing.ClassVar[str] = ...
    def __init__(self, field: org.hipparchus.Field[_MidpointFieldIntegrator__T], t: _MidpointFieldIntegrator__T): ...
    def getA(self) -> typing.List[typing.List[_MidpointFieldIntegrator__T]]: ...
    def getB(self) -> typing.List[_MidpointFieldIntegrator__T]: ...
    def getC(self) -> typing.List[_MidpointFieldIntegrator__T]: ...

class MidpointIntegrator(RungeKuttaIntegrator):
    METHOD_NAME: typing.ClassVar[str] = ...
    def __init__(self, double: float): ...
    def getA(self) -> typing.List[typing.List[float]]: ...
    def getB(self) -> typing.List[float]: ...
    def getC(self) -> typing.List[float]: ...

_ThreeEighthesFieldIntegrator__T = typing.TypeVar('_ThreeEighthesFieldIntegrator__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
class ThreeEighthesFieldIntegrator(RungeKuttaFieldIntegrator[_ThreeEighthesFieldIntegrator__T], typing.Generic[_ThreeEighthesFieldIntegrator__T]):
    METHOD_NAME: typing.ClassVar[str] = ...
    def __init__(self, field: org.hipparchus.Field[_ThreeEighthesFieldIntegrator__T], t: _ThreeEighthesFieldIntegrator__T): ...
    def getA(self) -> typing.List[typing.List[_ThreeEighthesFieldIntegrator__T]]: ...
    def getB(self) -> typing.List[_ThreeEighthesFieldIntegrator__T]: ...
    def getC(self) -> typing.List[_ThreeEighthesFieldIntegrator__T]: ...

class ThreeEighthesIntegrator(RungeKuttaIntegrator):
    METHOD_NAME: typing.ClassVar[str] = ...
    def __init__(self, double: float): ...
    def getA(self) -> typing.List[typing.List[float]]: ...
    def getB(self) -> typing.List[float]: ...
    def getC(self) -> typing.List[float]: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.hipparchus.ode.nonstiff")``.

    AdamsBashforthFieldIntegrator: typing.Type[AdamsBashforthFieldIntegrator]
    AdamsBashforthIntegrator: typing.Type[AdamsBashforthIntegrator]
    AdamsFieldIntegrator: typing.Type[AdamsFieldIntegrator]
    AdamsIntegrator: typing.Type[AdamsIntegrator]
    AdamsMoultonFieldIntegrator: typing.Type[AdamsMoultonFieldIntegrator]
    AdamsMoultonIntegrator: typing.Type[AdamsMoultonIntegrator]
    AdamsNordsieckFieldTransformer: typing.Type[AdamsNordsieckFieldTransformer]
    AdamsNordsieckTransformer: typing.Type[AdamsNordsieckTransformer]
    AdaptiveStepsizeFieldIntegrator: typing.Type[AdaptiveStepsizeFieldIntegrator]
    AdaptiveStepsizeIntegrator: typing.Type[AdaptiveStepsizeIntegrator]
    ButcherArrayProvider: typing.Type[ButcherArrayProvider]
    ClassicalRungeKuttaFieldIntegrator: typing.Type[ClassicalRungeKuttaFieldIntegrator]
    ClassicalRungeKuttaIntegrator: typing.Type[ClassicalRungeKuttaIntegrator]
    DormandPrince54FieldIntegrator: typing.Type[DormandPrince54FieldIntegrator]
    DormandPrince54Integrator: typing.Type[DormandPrince54Integrator]
    DormandPrince853FieldIntegrator: typing.Type[DormandPrince853FieldIntegrator]
    DormandPrince853Integrator: typing.Type[DormandPrince853Integrator]
    EmbeddedRungeKuttaFieldIntegrator: typing.Type[EmbeddedRungeKuttaFieldIntegrator]
    EmbeddedRungeKuttaIntegrator: typing.Type[EmbeddedRungeKuttaIntegrator]
    EulerFieldIntegrator: typing.Type[EulerFieldIntegrator]
    EulerIntegrator: typing.Type[EulerIntegrator]
    ExplicitRungeKuttaIntegrator: typing.Type[ExplicitRungeKuttaIntegrator]
    FieldButcherArrayProvider: typing.Type[FieldButcherArrayProvider]
    FieldExplicitRungeKuttaIntegrator: typing.Type[FieldExplicitRungeKuttaIntegrator]
    GillFieldIntegrator: typing.Type[GillFieldIntegrator]
    GillIntegrator: typing.Type[GillIntegrator]
    GraggBulirschStoerIntegrator: typing.Type[GraggBulirschStoerIntegrator]
    HighamHall54FieldIntegrator: typing.Type[HighamHall54FieldIntegrator]
    HighamHall54Integrator: typing.Type[HighamHall54Integrator]
    LutherFieldIntegrator: typing.Type[LutherFieldIntegrator]
    LutherIntegrator: typing.Type[LutherIntegrator]
    MidpointFieldIntegrator: typing.Type[MidpointFieldIntegrator]
    MidpointIntegrator: typing.Type[MidpointIntegrator]
    RungeKuttaFieldIntegrator: typing.Type[RungeKuttaFieldIntegrator]
    RungeKuttaIntegrator: typing.Type[RungeKuttaIntegrator]
    StepsizeHelper: typing.Type[StepsizeHelper]
    ThreeEighthesFieldIntegrator: typing.Type[ThreeEighthesFieldIntegrator]
    ThreeEighthesIntegrator: typing.Type[ThreeEighthesIntegrator]
    class-use: org.hipparchus.ode.nonstiff.class-use.__module_protocol__
