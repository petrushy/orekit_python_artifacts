import decimal
import java.io
import java.lang
import java.math
import java.text
import java.util
import java.util.stream
import org
import org.hipparchus
import org.hipparchus.exception
import org.hipparchus.linear
import org.hipparchus.random
import org.hipparchus.util.class-use
import typing



class AbstractOpenIntHashMap:
    @typing.overload
    def containsKey(self, int: int) -> bool: ...
    @typing.overload
    def containsKey(self, int: int, int2: int) -> bool: ...
    def getSize(self) -> int: ...
    def size(self) -> int: ...

class ArithmeticUtils:
    @typing.overload
    @staticmethod
    def addAndCheck(int: int, int2: int) -> int: ...
    @typing.overload
    @staticmethod
    def addAndCheck(long: int, long2: int) -> int: ...
    @typing.overload
    @staticmethod
    def divideUnsigned(int: int, int2: int) -> int: ...
    @typing.overload
    @staticmethod
    def divideUnsigned(long: int, long2: int) -> int: ...
    @typing.overload
    @staticmethod
    def gcd(int: int, int2: int) -> int: ...
    @typing.overload
    @staticmethod
    def gcd(long: int, long2: int) -> int: ...
    @staticmethod
    def isPowerOfTwo(long: int) -> bool: ...
    @typing.overload
    @staticmethod
    def lcm(int: int, int2: int) -> int: ...
    @typing.overload
    @staticmethod
    def lcm(long: int, long2: int) -> int: ...
    @typing.overload
    @staticmethod
    def mulAndCheck(int: int, int2: int) -> int: ...
    @typing.overload
    @staticmethod
    def mulAndCheck(long: int, long2: int) -> int: ...
    @typing.overload
    @staticmethod
    def pow(int: int, int2: int) -> int: ...
    @typing.overload
    @staticmethod
    def pow(bigInteger: java.math.BigInteger, int: int) -> java.math.BigInteger: ...
    @typing.overload
    @staticmethod
    def pow(bigInteger: java.math.BigInteger, bigInteger2: java.math.BigInteger) -> java.math.BigInteger: ...
    @typing.overload
    @staticmethod
    def pow(bigInteger: java.math.BigInteger, long: int) -> java.math.BigInteger: ...
    @typing.overload
    @staticmethod
    def pow(long: int, int: int) -> int: ...
    @typing.overload
    @staticmethod
    def remainderUnsigned(int: int, int2: int) -> int: ...
    @typing.overload
    @staticmethod
    def remainderUnsigned(long: int, long2: int) -> int: ...
    @typing.overload
    @staticmethod
    def subAndCheck(int: int, int2: int) -> int: ...
    @typing.overload
    @staticmethod
    def subAndCheck(long: int, long2: int) -> int: ...

class BigReal(org.hipparchus.FieldElement['BigReal'], java.lang.Comparable['BigReal'], java.io.Serializable):
    ZERO: typing.ClassVar['BigReal'] = ...
    ONE: typing.ClassVar['BigReal'] = ...
    @typing.overload
    def __init__(self, charArray: typing.List[str]): ...
    @typing.overload
    def __init__(self, charArray: typing.List[str], int: int, int2: int): ...
    @typing.overload
    def __init__(self, charArray: typing.List[str], int: int, int2: int, mathContext: java.math.MathContext): ...
    @typing.overload
    def __init__(self, charArray: typing.List[str], mathContext: java.math.MathContext): ...
    @typing.overload
    def __init__(self, double: float): ...
    @typing.overload
    def __init__(self, double: float, mathContext: java.math.MathContext): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, mathContext: java.math.MathContext): ...
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, mathContext: java.math.MathContext): ...
    @typing.overload
    def __init__(self, bigDecimal: typing.Union[java.math.BigDecimal, decimal.Decimal]): ...
    @typing.overload
    def __init__(self, bigInteger: java.math.BigInteger): ...
    @typing.overload
    def __init__(self, bigInteger: java.math.BigInteger, int: int): ...
    @typing.overload
    def __init__(self, bigInteger: java.math.BigInteger, int: int, mathContext: java.math.MathContext): ...
    @typing.overload
    def __init__(self, bigInteger: java.math.BigInteger, mathContext: java.math.MathContext): ...
    @typing.overload
    def __init__(self, long: int): ...
    @typing.overload
    def __init__(self, long: int, mathContext: java.math.MathContext): ...
    def add(self, bigReal: 'BigReal') -> 'BigReal': ...
    def bigDecimalValue(self) -> java.math.BigDecimal: ...
    def compareTo(self, bigReal: 'BigReal') -> int: ...
    def divide(self, bigReal: 'BigReal') -> 'BigReal': ...
    def doubleValue(self) -> float: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getField(self) -> org.hipparchus.Field['BigReal']: ...
    def getReal(self) -> float: ...
    def getRoundingMode(self) -> java.math.RoundingMode: ...
    def getScale(self) -> int: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def multiply(self, int: int) -> 'BigReal': ...
    @typing.overload
    def multiply(self, bigReal: 'BigReal') -> 'BigReal': ...
    def negate(self) -> 'BigReal': ...
    def reciprocal(self) -> 'BigReal': ...
    def setRoundingMode(self, roundingMode: java.math.RoundingMode) -> None: ...
    def setScale(self, int: int) -> None: ...
    def subtract(self, bigReal: 'BigReal') -> 'BigReal': ...

class BigRealField(org.hipparchus.Field[BigReal], java.io.Serializable):
    def equals(self, object: typing.Any) -> bool: ...
    @staticmethod
    def getInstance() -> 'BigRealField': ...
    def getOne(self) -> BigReal: ...
    def getRuntimeClass(self) -> typing.Type[BigReal]: ...
    def getZero(self) -> BigReal: ...
    def hashCode(self) -> int: ...

class Binary64(java.lang.Number, org.hipparchus.CalculusFieldElement['Binary64'], java.lang.Comparable['Binary64']):
    ZERO: typing.ClassVar['Binary64'] = ...
    ONE: typing.ClassVar['Binary64'] = ...
    PI: typing.ClassVar['Binary64'] = ...
    NEGATIVE_INFINITY: typing.ClassVar['Binary64'] = ...
    POSITIVE_INFINITY: typing.ClassVar['Binary64'] = ...
    NAN: typing.ClassVar['Binary64'] = ...
    def __init__(self, double: float): ...
    def abs(self) -> 'Binary64': ...
    def acos(self) -> 'Binary64': ...
    def acosh(self) -> 'Binary64': ...
    @typing.overload
    def add(self, double: float) -> 'Binary64': ...
    @typing.overload
    def add(self, binary64: 'Binary64') -> 'Binary64': ...
    def asin(self) -> 'Binary64': ...
    def asinh(self) -> 'Binary64': ...
    def atan(self) -> 'Binary64': ...
    def atan2(self, binary64: 'Binary64') -> 'Binary64': ...
    def atanh(self) -> 'Binary64': ...
    def byteValue(self) -> int: ...
    def cbrt(self) -> 'Binary64': ...
    def ceil(self) -> 'Binary64': ...
    def compareTo(self, binary64: 'Binary64') -> int: ...
    @typing.overload
    def copySign(self, double: float) -> 'Binary64': ...
    @typing.overload
    def copySign(self, binary64: 'Binary64') -> 'Binary64': ...
    def cos(self) -> 'Binary64': ...
    def cosh(self) -> 'Binary64': ...
    @typing.overload
    def divide(self, double: float) -> 'Binary64': ...
    @typing.overload
    def divide(self, binary64: 'Binary64') -> 'Binary64': ...
    def doubleValue(self) -> float: ...
    def equals(self, object: typing.Any) -> bool: ...
    def exp(self) -> 'Binary64': ...
    def expm1(self) -> 'Binary64': ...
    def floatValue(self) -> float: ...
    def floor(self) -> 'Binary64': ...
    def getField(self) -> org.hipparchus.Field['Binary64']: ...
    def getPi(self) -> 'Binary64': ...
    def getReal(self) -> float: ...
    def hashCode(self) -> int: ...
    def hypot(self, binary64: 'Binary64') -> 'Binary64': ...
    def intValue(self) -> int: ...
    def isInfinite(self) -> bool: ...
    def isNaN(self) -> bool: ...
    def isZero(self) -> bool: ...
    @typing.overload
    def linearCombination(self, double: float, binary64: 'Binary64', double2: float, binary642: 'Binary64') -> 'Binary64': ...
    @typing.overload
    def linearCombination(self, double: float, binary64: 'Binary64', double2: float, binary642: 'Binary64', double3: float, binary643: 'Binary64') -> 'Binary64': ...
    @typing.overload
    def linearCombination(self, double: float, binary64: 'Binary64', double2: float, binary642: 'Binary64', double3: float, binary643: 'Binary64', double4: float, binary644: 'Binary64') -> 'Binary64': ...
    @typing.overload
    def linearCombination(self, doubleArray: typing.List[float], binary64Array: typing.List['Binary64']) -> 'Binary64': ...
    @typing.overload
    def linearCombination(self, binary64: 'Binary64', binary642: 'Binary64', binary643: 'Binary64', binary644: 'Binary64') -> 'Binary64': ...
    @typing.overload
    def linearCombination(self, binary64: 'Binary64', binary642: 'Binary64', binary643: 'Binary64', binary644: 'Binary64', binary645: 'Binary64', binary646: 'Binary64') -> 'Binary64': ...
    @typing.overload
    def linearCombination(self, binary64: 'Binary64', binary642: 'Binary64', binary643: 'Binary64', binary644: 'Binary64', binary645: 'Binary64', binary646: 'Binary64', binary647: 'Binary64', binary648: 'Binary64') -> 'Binary64': ...
    @typing.overload
    def linearCombination(self, binary64Array: typing.List['Binary64'], binary64Array2: typing.List['Binary64']) -> 'Binary64': ...
    def log(self) -> 'Binary64': ...
    def log10(self) -> 'Binary64': ...
    def log1p(self) -> 'Binary64': ...
    def longValue(self) -> int: ...
    @typing.overload
    def multiply(self, double: float) -> 'Binary64': ...
    @typing.overload
    def multiply(self, int: int) -> 'Binary64': ...
    @typing.overload
    def multiply(self, binary64: 'Binary64') -> 'Binary64': ...
    def negate(self) -> 'Binary64': ...
    def newInstance(self, double: float) -> 'Binary64': ...
    @typing.overload
    def pow(self, double: float) -> 'Binary64': ...
    @typing.overload
    def pow(self, int: int) -> 'Binary64': ...
    @typing.overload
    def pow(self, binary64: 'Binary64') -> 'Binary64': ...
    def reciprocal(self) -> 'Binary64': ...
    @typing.overload
    def remainder(self, double: float) -> 'Binary64': ...
    @typing.overload
    def remainder(self, binary64: 'Binary64') -> 'Binary64': ...
    def rint(self) -> 'Binary64': ...
    def rootN(self, int: int) -> 'Binary64': ...
    def scalb(self, int: int) -> 'Binary64': ...
    def shortValue(self) -> int: ...
    def sign(self) -> 'Binary64': ...
    def sin(self) -> 'Binary64': ...
    def sinCos(self) -> 'FieldSinCos'['Binary64']: ...
    def sinh(self) -> 'Binary64': ...
    def sinhCosh(self) -> 'FieldSinhCosh'['Binary64']: ...
    def sqrt(self) -> 'Binary64': ...
    def square(self) -> 'Binary64': ...
    @typing.overload
    def subtract(self, double: float) -> 'Binary64': ...
    @typing.overload
    def subtract(self, binary64: 'Binary64') -> 'Binary64': ...
    def tan(self) -> 'Binary64': ...
    def tanh(self) -> 'Binary64': ...
    def toDegrees(self) -> 'Binary64': ...
    def toRadians(self) -> 'Binary64': ...
    def toString(self) -> str: ...
    def ulp(self) -> 'Binary64': ...

class Binary64Field(org.hipparchus.Field[Binary64], java.io.Serializable):
    def equals(self, object: typing.Any) -> bool: ...
    @staticmethod
    def getInstance() -> 'Binary64Field': ...
    def getOne(self) -> Binary64: ...
    def getRuntimeClass(self) -> typing.Type[Binary64]: ...
    def getZero(self) -> Binary64: ...
    def hashCode(self) -> int: ...

_Blendable__B = typing.TypeVar('_Blendable__B')  # <B>
class Blendable(typing.Generic[_Blendable__B]):
    def blendArithmeticallyWith(self, b: _Blendable__B, double: float) -> _Blendable__B: ...

class Combinations(java.lang.Iterable[typing.List[int]]):
    def __init__(self, int: int, int2: int): ...
    def comparator(self) -> java.util.Comparator[typing.List[int]]: ...
    def getK(self) -> int: ...
    def getN(self) -> int: ...
    def iterator(self) -> java.util.Iterator[typing.List[int]]: ...

class CombinatoricsUtils:
    MAX_BELL: typing.ClassVar[int] = ...
    @staticmethod
    def bellNumber(int: int) -> int: ...
    @staticmethod
    def binomialCoefficient(int: int, int2: int) -> int: ...
    @staticmethod
    def binomialCoefficientDouble(int: int, int2: int) -> float: ...
    @staticmethod
    def binomialCoefficientLog(int: int, int2: int) -> float: ...
    @staticmethod
    def checkBinomial(int: int, int2: int) -> None: ...
    @staticmethod
    def combinationsIterator(int: int, int2: int) -> java.util.Iterator[typing.List[int]]: ...
    @staticmethod
    def factorial(int: int) -> int: ...
    @staticmethod
    def factorialDouble(int: int) -> float: ...
    @staticmethod
    def factorialLog(int: int) -> float: ...
    _partitions__T = typing.TypeVar('_partitions__T')  # <T>
    @staticmethod
    def partitions(list: java.util.List[_partitions__T]) -> java.util.stream.Stream[typing.List[java.util.List[_partitions__T]]]: ...
    _permutations__T = typing.TypeVar('_permutations__T')  # <T>
    @staticmethod
    def permutations(list: java.util.List[_permutations__T]) -> java.util.stream.Stream[java.util.List[_permutations__T]]: ...
    @staticmethod
    def stirlingS2(int: int, int2: int) -> int: ...
    class FactorialLog:
        @staticmethod
        def create() -> 'CombinatoricsUtils.FactorialLog': ...
        def value(self, int: int) -> float: ...
        def withCache(self, int: int) -> 'CombinatoricsUtils.FactorialLog': ...

class CompositeFormat:
    @staticmethod
    def formatDouble(double: float, numberFormat: java.text.NumberFormat, stringBuffer: java.lang.StringBuffer, fieldPosition: java.text.FieldPosition) -> java.lang.StringBuffer: ...
    @typing.overload
    @staticmethod
    def getDefaultNumberFormat() -> java.text.NumberFormat: ...
    @typing.overload
    @staticmethod
    def getDefaultNumberFormat(locale: java.util.Locale) -> java.text.NumberFormat: ...
    @staticmethod
    def parseAndIgnoreWhitespace(string: str, parsePosition: java.text.ParsePosition) -> None: ...
    @staticmethod
    def parseFixedstring(string: str, string2: str, parsePosition: java.text.ParsePosition) -> bool: ...
    @staticmethod
    def parseNextCharacter(string: str, parsePosition: java.text.ParsePosition) -> str: ...
    @staticmethod
    def parseNumber(string: str, numberFormat: java.text.NumberFormat, parsePosition: java.text.ParsePosition) -> java.lang.Number: ...

class ContinuedFraction:
    @typing.overload
    def evaluate(self, double: float) -> float: ...
    @typing.overload
    def evaluate(self, double: float, double2: float) -> float: ...
    @typing.overload
    def evaluate(self, double: float, double2: float, int: int) -> float: ...
    @typing.overload
    def evaluate(self, double: float, int: int) -> float: ...

class FastMath:
    PI: typing.ClassVar[float] = ...
    E: typing.ClassVar[float] = ...
    _IEEEremainder_1__T = typing.TypeVar('_IEEEremainder_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _IEEEremainder_2__T = typing.TypeVar('_IEEEremainder_2__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def IEEEremainder(double: float, double2: float) -> float: ...
    @typing.overload
    @staticmethod
    def IEEEremainder(t: _IEEEremainder_1__T, double: float) -> _IEEEremainder_1__T: ...
    @typing.overload
    @staticmethod
    def IEEEremainder(t: _IEEEremainder_2__T, t2: _IEEEremainder_2__T) -> _IEEEremainder_2__T: ...
    _abs_4__T = typing.TypeVar('_abs_4__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def abs(double: float) -> float: ...
    @typing.overload
    @staticmethod
    def abs(float: float) -> float: ...
    @typing.overload
    @staticmethod
    def abs(int: int) -> int: ...
    @typing.overload
    @staticmethod
    def abs(long: int) -> int: ...
    @typing.overload
    @staticmethod
    def abs(t: _abs_4__T) -> _abs_4__T: ...
    @typing.overload
    @staticmethod
    def absExact(int: int) -> int: ...
    @typing.overload
    @staticmethod
    def absExact(long: int) -> int: ...
    _acos_1__T = typing.TypeVar('_acos_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def acos(double: float) -> float: ...
    @typing.overload
    @staticmethod
    def acos(t: _acos_1__T) -> _acos_1__T: ...
    _acosh_1__T = typing.TypeVar('_acosh_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def acosh(double: float) -> float: ...
    @typing.overload
    @staticmethod
    def acosh(t: _acosh_1__T) -> _acosh_1__T: ...
    @typing.overload
    @staticmethod
    def addExact(int: int, int2: int) -> int: ...
    @typing.overload
    @staticmethod
    def addExact(long: int, long2: int) -> int: ...
    _asin_1__T = typing.TypeVar('_asin_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def asin(double: float) -> float: ...
    @typing.overload
    @staticmethod
    def asin(t: _asin_1__T) -> _asin_1__T: ...
    _asinh_1__T = typing.TypeVar('_asinh_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def asinh(double: float) -> float: ...
    @typing.overload
    @staticmethod
    def asinh(t: _asinh_1__T) -> _asinh_1__T: ...
    _atan_1__T = typing.TypeVar('_atan_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def atan(double: float) -> float: ...
    @typing.overload
    @staticmethod
    def atan(t: _atan_1__T) -> _atan_1__T: ...
    _atan2_1__T = typing.TypeVar('_atan2_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def atan2(double: float, double2: float) -> float: ...
    @typing.overload
    @staticmethod
    def atan2(t: _atan2_1__T, t2: _atan2_1__T) -> _atan2_1__T: ...
    _atanh_1__T = typing.TypeVar('_atanh_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def atanh(double: float) -> float: ...
    @typing.overload
    @staticmethod
    def atanh(t: _atanh_1__T) -> _atanh_1__T: ...
    _cbrt_1__T = typing.TypeVar('_cbrt_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def cbrt(double: float) -> float: ...
    @typing.overload
    @staticmethod
    def cbrt(t: _cbrt_1__T) -> _cbrt_1__T: ...
    _ceil_1__T = typing.TypeVar('_ceil_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def ceil(double: float) -> float: ...
    @typing.overload
    @staticmethod
    def ceil(t: _ceil_1__T) -> _ceil_1__T: ...
    @typing.overload
    @staticmethod
    def ceilDiv(int: int, int2: int) -> int: ...
    @typing.overload
    @staticmethod
    def ceilDiv(long: int, int: int) -> int: ...
    @typing.overload
    @staticmethod
    def ceilDiv(long: int, long2: int) -> int: ...
    @typing.overload
    @staticmethod
    def ceilDivExact(int: int, int2: int) -> int: ...
    @typing.overload
    @staticmethod
    def ceilDivExact(long: int, long2: int) -> int: ...
    @typing.overload
    @staticmethod
    def ceilMod(int: int, int2: int) -> int: ...
    @typing.overload
    @staticmethod
    def ceilMod(long: int, int: int) -> int: ...
    @typing.overload
    @staticmethod
    def ceilMod(long: int, long2: int) -> int: ...
    @typing.overload
    @staticmethod
    def clamp(double: float, double2: float, double3: float) -> float: ...
    @typing.overload
    @staticmethod
    def clamp(float: float, float2: float, float3: float) -> float: ...
    @typing.overload
    @staticmethod
    def clamp(int: int, int2: int, int3: int) -> int: ...
    @typing.overload
    @staticmethod
    def clamp(long: int, int: int, int2: int) -> int: ...
    @typing.overload
    @staticmethod
    def clamp(long: int, long2: int, long3: int) -> int: ...
    _copySign_2__T = typing.TypeVar('_copySign_2__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _copySign_3__T = typing.TypeVar('_copySign_3__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def copySign(double: float, double2: float) -> float: ...
    @typing.overload
    @staticmethod
    def copySign(float: float, float2: float) -> float: ...
    @typing.overload
    @staticmethod
    def copySign(t: _copySign_2__T, double: float) -> _copySign_2__T: ...
    @typing.overload
    @staticmethod
    def copySign(t: _copySign_3__T, t2: _copySign_3__T) -> _copySign_3__T: ...
    _cos_1__T = typing.TypeVar('_cos_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def cos(double: float) -> float: ...
    @typing.overload
    @staticmethod
    def cos(t: _cos_1__T) -> _cos_1__T: ...
    _cosh_1__T = typing.TypeVar('_cosh_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def cosh(double: float) -> float: ...
    @typing.overload
    @staticmethod
    def cosh(t: _cosh_1__T) -> _cosh_1__T: ...
    @typing.overload
    @staticmethod
    def decrementExact(int: int) -> int: ...
    @typing.overload
    @staticmethod
    def decrementExact(long: int) -> int: ...
    @typing.overload
    @staticmethod
    def divideExact(int: int, int2: int) -> int: ...
    @typing.overload
    @staticmethod
    def divideExact(long: int, long2: int) -> int: ...
    _exp_1__T = typing.TypeVar('_exp_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def exp(double: float) -> float: ...
    @typing.overload
    @staticmethod
    def exp(t: _exp_1__T) -> _exp_1__T: ...
    _expm1_1__T = typing.TypeVar('_expm1_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def expm1(double: float) -> float: ...
    @typing.overload
    @staticmethod
    def expm1(t: _expm1_1__T) -> _expm1_1__T: ...
    _floor_1__T = typing.TypeVar('_floor_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def floor(double: float) -> float: ...
    @typing.overload
    @staticmethod
    def floor(t: _floor_1__T) -> _floor_1__T: ...
    @typing.overload
    @staticmethod
    def floorDiv(int: int, int2: int) -> int: ...
    @typing.overload
    @staticmethod
    def floorDiv(long: int, int: int) -> int: ...
    @typing.overload
    @staticmethod
    def floorDiv(long: int, long2: int) -> int: ...
    @typing.overload
    @staticmethod
    def floorDivExact(int: int, int2: int) -> int: ...
    @typing.overload
    @staticmethod
    def floorDivExact(long: int, long2: int) -> int: ...
    @typing.overload
    @staticmethod
    def floorMod(int: int, int2: int) -> int: ...
    @typing.overload
    @staticmethod
    def floorMod(long: int, int: int) -> int: ...
    @typing.overload
    @staticmethod
    def floorMod(long: int, long2: int) -> int: ...
    @typing.overload
    @staticmethod
    def fma(double: float, double2: float, double3: float) -> float: ...
    @typing.overload
    @staticmethod
    def fma(float: float, float2: float, float3: float) -> float: ...
    @typing.overload
    @staticmethod
    def getExponent(double: float) -> int: ...
    @typing.overload
    @staticmethod
    def getExponent(float: float) -> int: ...
    _hypot_1__T = typing.TypeVar('_hypot_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def hypot(double: float, double2: float) -> float: ...
    @typing.overload
    @staticmethod
    def hypot(t: _hypot_1__T, t2: _hypot_1__T) -> _hypot_1__T: ...
    @typing.overload
    @staticmethod
    def incrementExact(int: int) -> int: ...
    @typing.overload
    @staticmethod
    def incrementExact(long: int) -> int: ...
    _log_2__T = typing.TypeVar('_log_2__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def log(double: float) -> float: ...
    @typing.overload
    @staticmethod
    def log(double: float, double2: float) -> float: ...
    @typing.overload
    @staticmethod
    def log(t: _log_2__T) -> _log_2__T: ...
    _log10_1__T = typing.TypeVar('_log10_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def log10(double: float) -> float: ...
    @typing.overload
    @staticmethod
    def log10(t: _log10_1__T) -> _log10_1__T: ...
    _log1p_1__T = typing.TypeVar('_log1p_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def log1p(double: float) -> float: ...
    @typing.overload
    @staticmethod
    def log1p(t: _log1p_1__T) -> _log1p_1__T: ...
    _max_4__T = typing.TypeVar('_max_4__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _max_5__T = typing.TypeVar('_max_5__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def max(double: float, double2: float) -> float: ...
    @typing.overload
    @staticmethod
    def max(float: float, float2: float) -> float: ...
    @typing.overload
    @staticmethod
    def max(int: int, int2: int) -> int: ...
    @typing.overload
    @staticmethod
    def max(long: int, long2: int) -> int: ...
    @typing.overload
    @staticmethod
    def max(t: _max_4__T, double: float) -> _max_4__T: ...
    @typing.overload
    @staticmethod
    def max(t: _max_5__T, t2: _max_5__T) -> _max_5__T: ...
    _min_4__T = typing.TypeVar('_min_4__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _min_5__T = typing.TypeVar('_min_5__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def min(double: float, double2: float) -> float: ...
    @typing.overload
    @staticmethod
    def min(float: float, float2: float) -> float: ...
    @typing.overload
    @staticmethod
    def min(int: int, int2: int) -> int: ...
    @typing.overload
    @staticmethod
    def min(long: int, long2: int) -> int: ...
    @typing.overload
    @staticmethod
    def min(t: _min_4__T, double: float) -> _min_4__T: ...
    @typing.overload
    @staticmethod
    def min(t: _min_5__T, t2: _min_5__T) -> _min_5__T: ...
    @typing.overload
    @staticmethod
    def multiplyExact(int: int, int2: int) -> int: ...
    @typing.overload
    @staticmethod
    def multiplyExact(long: int, int: int) -> int: ...
    @typing.overload
    @staticmethod
    def multiplyExact(long: int, long2: int) -> int: ...
    @staticmethod
    def multiplyFull(int: int, int2: int) -> int: ...
    @staticmethod
    def multiplyHigh(long: int, long2: int) -> int: ...
    @typing.overload
    @staticmethod
    def negateExact(int: int) -> int: ...
    @typing.overload
    @staticmethod
    def negateExact(long: int) -> int: ...
    @typing.overload
    @staticmethod
    def nextAfter(double: float, double2: float) -> float: ...
    @typing.overload
    @staticmethod
    def nextAfter(float: float, double: float) -> float: ...
    @typing.overload
    @staticmethod
    def nextDown(double: float) -> float: ...
    @typing.overload
    @staticmethod
    def nextDown(float: float) -> float: ...
    @typing.overload
    @staticmethod
    def nextUp(double: float) -> float: ...
    @typing.overload
    @staticmethod
    def nextUp(float: float) -> float: ...
    _norm__T = typing.TypeVar('_norm__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @staticmethod
    def norm(t: _norm__T) -> float: ...
    _pow_3__T = typing.TypeVar('_pow_3__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _pow_4__T = typing.TypeVar('_pow_4__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _pow_5__T = typing.TypeVar('_pow_5__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def pow(double: float, double2: float) -> float: ...
    @typing.overload
    @staticmethod
    def pow(double: float, int: int) -> float: ...
    @typing.overload
    @staticmethod
    def pow(double: float, long: int) -> float: ...
    @typing.overload
    @staticmethod
    def pow(t: _pow_3__T, double: float) -> _pow_3__T: ...
    @typing.overload
    @staticmethod
    def pow(t: _pow_4__T, int: int) -> _pow_4__T: ...
    @typing.overload
    @staticmethod
    def pow(t: _pow_5__T, t2: _pow_5__T) -> _pow_5__T: ...
    @staticmethod
    def random() -> float: ...
    _rint_1__T = typing.TypeVar('_rint_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def rint(double: float) -> float: ...
    @typing.overload
    @staticmethod
    def rint(t: _rint_1__T) -> _rint_1__T: ...
    _round_2__T = typing.TypeVar('_round_2__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def round(float: float) -> int: ...
    @typing.overload
    @staticmethod
    def round(double: float) -> int: ...
    @typing.overload
    @staticmethod
    def round(t: _round_2__T) -> int: ...
    _scalb_2__T = typing.TypeVar('_scalb_2__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def scalb(double: float, int: int) -> float: ...
    @typing.overload
    @staticmethod
    def scalb(float: float, int: int) -> float: ...
    @typing.overload
    @staticmethod
    def scalb(t: _scalb_2__T, int: int) -> _scalb_2__T: ...
    _sign__T = typing.TypeVar('_sign__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @staticmethod
    def sign(t: _sign__T) -> _sign__T: ...
    @typing.overload
    @staticmethod
    def signum(double: float) -> float: ...
    @typing.overload
    @staticmethod
    def signum(float: float) -> float: ...
    _sin_1__T = typing.TypeVar('_sin_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def sin(double: float) -> float: ...
    @typing.overload
    @staticmethod
    def sin(t: _sin_1__T) -> _sin_1__T: ...
    _sinCos_0__T = typing.TypeVar('_sinCos_0__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def sinCos(t: _sinCos_0__T) -> 'FieldSinCos'[_sinCos_0__T]: ...
    @typing.overload
    @staticmethod
    def sinCos(double: float) -> 'SinCos': ...
    _sinh_1__T = typing.TypeVar('_sinh_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def sinh(double: float) -> float: ...
    @typing.overload
    @staticmethod
    def sinh(t: _sinh_1__T) -> _sinh_1__T: ...
    _sinhCosh_0__T = typing.TypeVar('_sinhCosh_0__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def sinhCosh(t: _sinhCosh_0__T) -> 'FieldSinhCosh'[_sinhCosh_0__T]: ...
    @typing.overload
    @staticmethod
    def sinhCosh(double: float) -> 'SinhCosh': ...
    _sqrt_1__T = typing.TypeVar('_sqrt_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def sqrt(double: float) -> float: ...
    @typing.overload
    @staticmethod
    def sqrt(t: _sqrt_1__T) -> _sqrt_1__T: ...
    @typing.overload
    @staticmethod
    def subtractExact(int: int, int2: int) -> int: ...
    @typing.overload
    @staticmethod
    def subtractExact(long: int, long2: int) -> int: ...
    _tan_1__T = typing.TypeVar('_tan_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def tan(double: float) -> float: ...
    @typing.overload
    @staticmethod
    def tan(t: _tan_1__T) -> _tan_1__T: ...
    _tanh_1__T = typing.TypeVar('_tanh_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def tanh(double: float) -> float: ...
    @typing.overload
    @staticmethod
    def tanh(t: _tanh_1__T) -> _tanh_1__T: ...
    _toDegrees_1__T = typing.TypeVar('_toDegrees_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def toDegrees(double: float) -> float: ...
    @typing.overload
    @staticmethod
    def toDegrees(t: _toDegrees_1__T) -> _toDegrees_1__T: ...
    @staticmethod
    def toIntExact(long: int) -> int: ...
    _toRadians_1__T = typing.TypeVar('_toRadians_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def toRadians(double: float) -> float: ...
    @typing.overload
    @staticmethod
    def toRadians(t: _toRadians_1__T) -> _toRadians_1__T: ...
    _ulp_2__T = typing.TypeVar('_ulp_2__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def ulp(double: float) -> float: ...
    @typing.overload
    @staticmethod
    def ulp(float: float) -> float: ...
    @typing.overload
    @staticmethod
    def ulp(t: _ulp_2__T) -> _ulp_2__T: ...
    @staticmethod
    def unsignedMultiplyHigh(long: int, long2: int) -> int: ...

_FieldBlendable__B = typing.TypeVar('_FieldBlendable__B')  # <B>
_FieldBlendable__T = typing.TypeVar('_FieldBlendable__T', bound=org.hipparchus.FieldElement)  # <T>
class FieldBlendable(typing.Generic[_FieldBlendable__B, _FieldBlendable__T]):
    def blendArithmeticallyWith(self, b: _FieldBlendable__B, t: _FieldBlendable__T) -> _FieldBlendable__B: ...

class FieldContinuedFraction:
    _evaluate_0__T = typing.TypeVar('_evaluate_0__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _evaluate_1__T = typing.TypeVar('_evaluate_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _evaluate_2__T = typing.TypeVar('_evaluate_2__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _evaluate_3__T = typing.TypeVar('_evaluate_3__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def evaluate(self, t: _evaluate_0__T) -> _evaluate_0__T: ...
    @typing.overload
    def evaluate(self, t: _evaluate_1__T, double: float) -> _evaluate_1__T: ...
    @typing.overload
    def evaluate(self, t: _evaluate_2__T, double: float, int: int) -> _evaluate_2__T: ...
    @typing.overload
    def evaluate(self, t: _evaluate_3__T, int: int) -> _evaluate_3__T: ...
    _getA__T = typing.TypeVar('_getA__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    def getA(self, int: int, t: _getA__T) -> _getA__T: ...
    _getB__T = typing.TypeVar('_getB__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    def getB(self, int: int, t: _getB__T) -> _getB__T: ...

_FieldSinCos__T = typing.TypeVar('_FieldSinCos__T')  # <T>
class FieldSinCos(typing.Generic[_FieldSinCos__T]):
    def __init__(self, t: _FieldSinCos__T, t2: _FieldSinCos__T): ...
    def cos(self) -> _FieldSinCos__T: ...
    _difference__S = typing.TypeVar('_difference__S', bound=org.hipparchus.CalculusFieldElement)  # <S>
    @staticmethod
    def difference(fieldSinCos: 'FieldSinCos'[_difference__S], fieldSinCos2: 'FieldSinCos'[_difference__S]) -> 'FieldSinCos'[_difference__S]: ...
    def sin(self) -> _FieldSinCos__T: ...
    _sum__S = typing.TypeVar('_sum__S', bound=org.hipparchus.CalculusFieldElement)  # <S>
    @staticmethod
    def sum(fieldSinCos: 'FieldSinCos'[_sum__S], fieldSinCos2: 'FieldSinCos'[_sum__S]) -> 'FieldSinCos'[_sum__S]: ...

_FieldSinhCosh__T = typing.TypeVar('_FieldSinhCosh__T')  # <T>
class FieldSinhCosh(typing.Generic[_FieldSinhCosh__T]):
    def __init__(self, t: _FieldSinhCosh__T, t2: _FieldSinhCosh__T): ...
    def cosh(self) -> _FieldSinhCosh__T: ...
    _difference__S = typing.TypeVar('_difference__S', bound=org.hipparchus.CalculusFieldElement)  # <S>
    @staticmethod
    def difference(fieldSinhCosh: 'FieldSinhCosh'[_difference__S], fieldSinhCosh2: 'FieldSinhCosh'[_difference__S]) -> 'FieldSinhCosh'[_difference__S]: ...
    def sinh(self) -> _FieldSinhCosh__T: ...
    _sum__S = typing.TypeVar('_sum__S', bound=org.hipparchus.CalculusFieldElement)  # <S>
    @staticmethod
    def sum(fieldSinhCosh: 'FieldSinhCosh'[_sum__S], fieldSinhCosh2: 'FieldSinhCosh'[_sum__S]) -> 'FieldSinhCosh'[_sum__S]: ...

_FieldTuple__T = typing.TypeVar('_FieldTuple__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
class FieldTuple(org.hipparchus.CalculusFieldElement['FieldTuple'[_FieldTuple__T]], typing.Generic[_FieldTuple__T]):
    def __init__(self, tArray: typing.List[_FieldTuple__T]): ...
    def abs(self) -> 'FieldTuple'[_FieldTuple__T]: ...
    def acos(self) -> 'FieldTuple'[_FieldTuple__T]: ...
    def acosh(self) -> 'FieldTuple'[_FieldTuple__T]: ...
    @typing.overload
    def add(self, double: float) -> 'FieldTuple'[_FieldTuple__T]: ...
    @typing.overload
    def add(self, fieldTuple: 'FieldTuple'[_FieldTuple__T]) -> 'FieldTuple'[_FieldTuple__T]: ...
    def asin(self) -> 'FieldTuple'[_FieldTuple__T]: ...
    def asinh(self) -> 'FieldTuple'[_FieldTuple__T]: ...
    def atan(self) -> 'FieldTuple'[_FieldTuple__T]: ...
    def atan2(self, fieldTuple: 'FieldTuple'[_FieldTuple__T]) -> 'FieldTuple'[_FieldTuple__T]: ...
    def atanh(self) -> 'FieldTuple'[_FieldTuple__T]: ...
    def cbrt(self) -> 'FieldTuple'[_FieldTuple__T]: ...
    def ceil(self) -> 'FieldTuple'[_FieldTuple__T]: ...
    @typing.overload
    def copySign(self, double: float) -> 'FieldTuple'[_FieldTuple__T]: ...
    @typing.overload
    def copySign(self, fieldTuple: 'FieldTuple'[_FieldTuple__T]) -> 'FieldTuple'[_FieldTuple__T]: ...
    def cos(self) -> 'FieldTuple'[_FieldTuple__T]: ...
    def cosh(self) -> 'FieldTuple'[_FieldTuple__T]: ...
    @typing.overload
    def divide(self, double: float) -> 'FieldTuple'[_FieldTuple__T]: ...
    @typing.overload
    def divide(self, fieldTuple: 'FieldTuple'[_FieldTuple__T]) -> 'FieldTuple'[_FieldTuple__T]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def exp(self) -> 'FieldTuple'[_FieldTuple__T]: ...
    def expm1(self) -> 'FieldTuple'[_FieldTuple__T]: ...
    def floor(self) -> 'FieldTuple'[_FieldTuple__T]: ...
    def getComponent(self, int: int) -> _FieldTuple__T: ...
    def getComponents(self) -> typing.List[_FieldTuple__T]: ...
    def getDimension(self) -> int: ...
    def getField(self) -> org.hipparchus.Field['FieldTuple'[_FieldTuple__T]]: ...
    def getPi(self) -> 'FieldTuple'[_FieldTuple__T]: ...
    def getReal(self) -> float: ...
    def hashCode(self) -> int: ...
    def hypot(self, fieldTuple: 'FieldTuple'[_FieldTuple__T]) -> 'FieldTuple'[_FieldTuple__T]: ...
    @typing.overload
    def linearCombination(self, double: float, fieldTuple: 'FieldTuple'[_FieldTuple__T], double2: float, fieldTuple2: 'FieldTuple'[_FieldTuple__T]) -> 'FieldTuple'[_FieldTuple__T]: ...
    @typing.overload
    def linearCombination(self, double: float, fieldTuple: 'FieldTuple'[_FieldTuple__T], double2: float, fieldTuple2: 'FieldTuple'[_FieldTuple__T], double3: float, fieldTuple3: 'FieldTuple'[_FieldTuple__T]) -> 'FieldTuple'[_FieldTuple__T]: ...
    @typing.overload
    def linearCombination(self, double: float, fieldTuple: 'FieldTuple'[_FieldTuple__T], double2: float, fieldTuple2: 'FieldTuple'[_FieldTuple__T], double3: float, fieldTuple3: 'FieldTuple'[_FieldTuple__T], double4: float, fieldTuple4: 'FieldTuple'[_FieldTuple__T]) -> 'FieldTuple'[_FieldTuple__T]: ...
    @typing.overload
    def linearCombination(self, doubleArray: typing.List[float], fieldTupleArray: typing.List['FieldTuple'[_FieldTuple__T]]) -> 'FieldTuple'[_FieldTuple__T]: ...
    @typing.overload
    def linearCombination(self, fieldTuple: 'FieldTuple'[_FieldTuple__T], fieldTuple2: 'FieldTuple'[_FieldTuple__T], fieldTuple3: 'FieldTuple'[_FieldTuple__T], fieldTuple4: 'FieldTuple'[_FieldTuple__T]) -> 'FieldTuple'[_FieldTuple__T]: ...
    @typing.overload
    def linearCombination(self, fieldTuple: 'FieldTuple'[_FieldTuple__T], fieldTuple2: 'FieldTuple'[_FieldTuple__T], fieldTuple3: 'FieldTuple'[_FieldTuple__T], fieldTuple4: 'FieldTuple'[_FieldTuple__T], fieldTuple5: 'FieldTuple'[_FieldTuple__T], fieldTuple6: 'FieldTuple'[_FieldTuple__T]) -> 'FieldTuple'[_FieldTuple__T]: ...
    @typing.overload
    def linearCombination(self, fieldTuple: 'FieldTuple'[_FieldTuple__T], fieldTuple2: 'FieldTuple'[_FieldTuple__T], fieldTuple3: 'FieldTuple'[_FieldTuple__T], fieldTuple4: 'FieldTuple'[_FieldTuple__T], fieldTuple5: 'FieldTuple'[_FieldTuple__T], fieldTuple6: 'FieldTuple'[_FieldTuple__T], fieldTuple7: 'FieldTuple'[_FieldTuple__T], fieldTuple8: 'FieldTuple'[_FieldTuple__T]) -> 'FieldTuple'[_FieldTuple__T]: ...
    @typing.overload
    def linearCombination(self, fieldTupleArray: typing.List['FieldTuple'[_FieldTuple__T]], fieldTupleArray2: typing.List['FieldTuple'[_FieldTuple__T]]) -> 'FieldTuple'[_FieldTuple__T]: ...
    def log(self) -> 'FieldTuple'[_FieldTuple__T]: ...
    def log10(self) -> 'FieldTuple'[_FieldTuple__T]: ...
    def log1p(self) -> 'FieldTuple'[_FieldTuple__T]: ...
    @typing.overload
    def multiply(self, double: float) -> 'FieldTuple'[_FieldTuple__T]: ...
    @typing.overload
    def multiply(self, int: int) -> 'FieldTuple'[_FieldTuple__T]: ...
    @typing.overload
    def multiply(self, fieldTuple: 'FieldTuple'[_FieldTuple__T]) -> 'FieldTuple'[_FieldTuple__T]: ...
    def negate(self) -> 'FieldTuple'[_FieldTuple__T]: ...
    def newInstance(self, double: float) -> 'FieldTuple'[_FieldTuple__T]: ...
    @typing.overload
    def pow(self, double: float) -> 'FieldTuple'[_FieldTuple__T]: ...
    @typing.overload
    def pow(self, int: int) -> 'FieldTuple'[_FieldTuple__T]: ...
    @typing.overload
    def pow(self, fieldTuple: 'FieldTuple'[_FieldTuple__T]) -> 'FieldTuple'[_FieldTuple__T]: ...
    def reciprocal(self) -> 'FieldTuple'[_FieldTuple__T]: ...
    @typing.overload
    def remainder(self, double: float) -> 'FieldTuple'[_FieldTuple__T]: ...
    @typing.overload
    def remainder(self, fieldTuple: 'FieldTuple'[_FieldTuple__T]) -> 'FieldTuple'[_FieldTuple__T]: ...
    def rint(self) -> 'FieldTuple'[_FieldTuple__T]: ...
    def rootN(self, int: int) -> 'FieldTuple'[_FieldTuple__T]: ...
    def scalb(self, int: int) -> 'FieldTuple'[_FieldTuple__T]: ...
    def sign(self) -> 'FieldTuple'[_FieldTuple__T]: ...
    def sin(self) -> 'FieldTuple'[_FieldTuple__T]: ...
    def sinCos(self) -> FieldSinCos['FieldTuple'[_FieldTuple__T]]: ...
    def sinh(self) -> 'FieldTuple'[_FieldTuple__T]: ...
    def sinhCosh(self) -> FieldSinhCosh['FieldTuple'[_FieldTuple__T]]: ...
    def sqrt(self) -> 'FieldTuple'[_FieldTuple__T]: ...
    def square(self) -> 'FieldTuple'[_FieldTuple__T]: ...
    @typing.overload
    def subtract(self, double: float) -> 'FieldTuple'[_FieldTuple__T]: ...
    @typing.overload
    def subtract(self, fieldTuple: 'FieldTuple'[_FieldTuple__T]) -> 'FieldTuple'[_FieldTuple__T]: ...
    def tan(self) -> 'FieldTuple'[_FieldTuple__T]: ...
    def tanh(self) -> 'FieldTuple'[_FieldTuple__T]: ...
    def toDegrees(self) -> 'FieldTuple'[_FieldTuple__T]: ...
    def toRadians(self) -> 'FieldTuple'[_FieldTuple__T]: ...
    def ulp(self) -> 'FieldTuple'[_FieldTuple__T]: ...

class Incrementor:
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, maxCountExceededCallback: 'Incrementor.MaxCountExceededCallback'): ...
    @typing.overload
    def canIncrement(self) -> bool: ...
    @typing.overload
    def canIncrement(self, int: int) -> bool: ...
    def getCount(self) -> int: ...
    def getMaximalCount(self) -> int: ...
    @typing.overload
    def increment(self) -> None: ...
    @typing.overload
    def increment(self, int: int) -> None: ...
    def reset(self) -> None: ...
    def withCallback(self, maxCountExceededCallback: 'Incrementor.MaxCountExceededCallback') -> 'Incrementor': ...
    def withCount(self, int: int) -> 'Incrementor': ...
    def withMaximalCount(self, int: int) -> 'Incrementor': ...
    class MaxCountExceededCallback:
        def trigger(self, int: int) -> None: ...

class IterationEvent(java.util.EventObject):
    def __init__(self, object: typing.Any, int: int): ...
    def getIterations(self) -> int: ...

class IterationListener(java.util.EventListener):
    def initializationPerformed(self, iterationEvent: IterationEvent) -> None: ...
    def iterationPerformed(self, iterationEvent: IterationEvent) -> None: ...
    def iterationStarted(self, iterationEvent: IterationEvent) -> None: ...
    def terminationPerformed(self, iterationEvent: IterationEvent) -> None: ...

class IterationManager:
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, maxCountExceededCallback: Incrementor.MaxCountExceededCallback): ...
    def addIterationListener(self, iterationListener: IterationListener) -> None: ...
    def fireInitializationEvent(self, iterationEvent: IterationEvent) -> None: ...
    def fireIterationPerformedEvent(self, iterationEvent: IterationEvent) -> None: ...
    def fireIterationStartedEvent(self, iterationEvent: IterationEvent) -> None: ...
    def fireTerminationEvent(self, iterationEvent: IterationEvent) -> None: ...
    def getIterations(self) -> int: ...
    def getMaxIterations(self) -> int: ...
    def incrementIterationCount(self) -> None: ...
    def removeIterationListener(self, iterationListener: IterationListener) -> None: ...
    def resetIterationCount(self) -> None: ...

class KthSelector(java.io.Serializable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, pivotingStrategy: 'PivotingStrategy'): ...
    def getPivotingStrategy(self) -> 'PivotingStrategy': ...
    def select(self, doubleArray: typing.List[float], intArray: typing.List[int], int2: int) -> float: ...

class MathArrays:
    _buildArray_0__T = typing.TypeVar('_buildArray_0__T', bound=org.hipparchus.FieldElement)  # <T>
    _buildArray_1__T = typing.TypeVar('_buildArray_1__T', bound=org.hipparchus.FieldElement)  # <T>
    _buildArray_2__T = typing.TypeVar('_buildArray_2__T', bound=org.hipparchus.FieldElement)  # <T>
    @typing.overload
    @staticmethod
    def buildArray(field: org.hipparchus.Field[_buildArray_0__T], int: int) -> typing.List[_buildArray_0__T]: ...
    @typing.overload
    @staticmethod
    def buildArray(field: org.hipparchus.Field[_buildArray_1__T], int: int, int2: int) -> typing.List[typing.List[_buildArray_1__T]]: ...
    @typing.overload
    @staticmethod
    def buildArray(field: org.hipparchus.Field[_buildArray_2__T], int: int, int2: int, int3: int) -> typing.List[typing.List[typing.List[_buildArray_2__T]]]: ...
    _checkEqualLength_2__T = typing.TypeVar('_checkEqualLength_2__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _checkEqualLength_5__T = typing.TypeVar('_checkEqualLength_5__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def checkEqualLength(doubleArray: typing.List[float], doubleArray2: typing.List[float], boolean: bool) -> bool: ...
    @typing.overload
    @staticmethod
    def checkEqualLength(intArray: typing.List[int], intArray2: typing.List[int], boolean: bool) -> bool: ...
    @typing.overload
    @staticmethod
    def checkEqualLength(tArray: typing.List[_checkEqualLength_2__T], tArray2: typing.List[_checkEqualLength_2__T], boolean: bool) -> bool: ...
    @typing.overload
    @staticmethod
    def checkEqualLength(doubleArray: typing.List[float], doubleArray2: typing.List[float]) -> None: ...
    @typing.overload
    @staticmethod
    def checkEqualLength(intArray: typing.List[int], intArray2: typing.List[int]) -> None: ...
    @typing.overload
    @staticmethod
    def checkEqualLength(tArray: typing.List[_checkEqualLength_5__T], tArray2: typing.List[_checkEqualLength_5__T]) -> None: ...
    @typing.overload
    @staticmethod
    def checkNonNegative(longArray: typing.List[int]) -> None: ...
    @typing.overload
    @staticmethod
    def checkNonNegative(longArray: typing.List[typing.List[int]]) -> None: ...
    @staticmethod
    def checkNotNaN(doubleArray: typing.List[float]) -> None: ...
    _checkOrder_1__T = typing.TypeVar('_checkOrder_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _checkOrder_4__T = typing.TypeVar('_checkOrder_4__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _checkOrder_5__T = typing.TypeVar('_checkOrder_5__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def checkOrder(doubleArray: typing.List[float], orderDirection: 'MathArrays.OrderDirection', boolean: bool, boolean2: bool) -> bool: ...
    @typing.overload
    @staticmethod
    def checkOrder(tArray: typing.List[_checkOrder_1__T], orderDirection: 'MathArrays.OrderDirection', boolean: bool, boolean2: bool) -> bool: ...
    @typing.overload
    @staticmethod
    def checkOrder(doubleArray: typing.List[float]) -> None: ...
    @typing.overload
    @staticmethod
    def checkOrder(doubleArray: typing.List[float], orderDirection: 'MathArrays.OrderDirection', boolean: bool) -> None: ...
    @typing.overload
    @staticmethod
    def checkOrder(tArray: typing.List[_checkOrder_4__T]) -> None: ...
    @typing.overload
    @staticmethod
    def checkOrder(tArray: typing.List[_checkOrder_5__T], orderDirection: 'MathArrays.OrderDirection', boolean: bool) -> None: ...
    @staticmethod
    def checkPositive(doubleArray: typing.List[float]) -> None: ...
    @staticmethod
    def checkRectangular(longArray: typing.List[typing.List[int]]) -> None: ...
    @staticmethod
    def concatenate(doubleArray: typing.List[typing.List[float]]) -> typing.List[float]: ...
    @staticmethod
    def convolve(doubleArray: typing.List[float], doubleArray2: typing.List[float]) -> typing.List[float]: ...
    @staticmethod
    def cosAngle(doubleArray: typing.List[float], doubleArray2: typing.List[float]) -> float: ...
    @typing.overload
    @staticmethod
    def distance(doubleArray: typing.List[float], doubleArray2: typing.List[float]) -> float: ...
    @typing.overload
    @staticmethod
    def distance(intArray: typing.List[int], intArray2: typing.List[int]) -> float: ...
    @typing.overload
    @staticmethod
    def distance1(doubleArray: typing.List[float], doubleArray2: typing.List[float]) -> float: ...
    @typing.overload
    @staticmethod
    def distance1(intArray: typing.List[int], intArray2: typing.List[int]) -> int: ...
    @typing.overload
    @staticmethod
    def distanceInf(doubleArray: typing.List[float], doubleArray2: typing.List[float]) -> float: ...
    @typing.overload
    @staticmethod
    def distanceInf(intArray: typing.List[int], intArray2: typing.List[int]) -> int: ...
    @staticmethod
    def ebeAdd(doubleArray: typing.List[float], doubleArray2: typing.List[float]) -> typing.List[float]: ...
    @staticmethod
    def ebeDivide(doubleArray: typing.List[float], doubleArray2: typing.List[float]) -> typing.List[float]: ...
    @staticmethod
    def ebeMultiply(doubleArray: typing.List[float], doubleArray2: typing.List[float]) -> typing.List[float]: ...
    @staticmethod
    def ebeSubtract(doubleArray: typing.List[float], doubleArray2: typing.List[float]) -> typing.List[float]: ...
    @typing.overload
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(byteArray: typing.List[int], byteArray2: typing.List[int]) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(doubleArray: typing.List[float], doubleArray2: typing.List[float]) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(floatArray: typing.List[float], floatArray2: typing.List[float]) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(intArray: typing.List[int], intArray2: typing.List[int]) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(longArray: typing.List[int], longArray2: typing.List[int]) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(shortArray: typing.List[int], shortArray2: typing.List[int]) -> bool: ...
    @typing.overload
    @staticmethod
    def equalsIncludingNaN(doubleArray: typing.List[float], doubleArray2: typing.List[float]) -> bool: ...
    @typing.overload
    @staticmethod
    def equalsIncludingNaN(floatArray: typing.List[float], floatArray2: typing.List[float]) -> bool: ...
    _isMonotonic_1__T = typing.TypeVar('_isMonotonic_1__T', bound=java.lang.Comparable)  # <T>
    @typing.overload
    @staticmethod
    def isMonotonic(doubleArray: typing.List[float], orderDirection: 'MathArrays.OrderDirection', boolean: bool) -> bool: ...
    @typing.overload
    @staticmethod
    def isMonotonic(tArray: typing.List[_isMonotonic_1__T], orderDirection: 'MathArrays.OrderDirection', boolean: bool) -> bool: ...
    @typing.overload
    @staticmethod
    def linearCombination(double: float, double2: float, double3: float, double4: float) -> float: ...
    @typing.overload
    @staticmethod
    def linearCombination(double: float, double2: float, double3: float, double4: float, double5: float, double6: float) -> float: ...
    @typing.overload
    @staticmethod
    def linearCombination(double: float, double2: float, double3: float, double4: float, double5: float, double6: float, double7: float, double8: float) -> float: ...
    @typing.overload
    @staticmethod
    def linearCombination(doubleArray: typing.List[float], doubleArray2: typing.List[float]) -> float: ...
    @staticmethod
    def natural(int: int) -> typing.List[int]: ...
    @staticmethod
    def normalizeArray(doubleArray: typing.List[float], double2: float) -> typing.List[float]: ...
    @staticmethod
    def safeNorm(doubleArray: typing.List[float]) -> float: ...
    @staticmethod
    def scale(double: float, doubleArray: typing.List[float]) -> typing.List[float]: ...
    @staticmethod
    def scaleInPlace(double: float, doubleArray: typing.List[float]) -> None: ...
    @staticmethod
    def sequence(int: int, int2: int, int3: int) -> typing.List[int]: ...
    @typing.overload
    @staticmethod
    def shuffle(intArray: typing.List[int]) -> None: ...
    @typing.overload
    @staticmethod
    def shuffle(intArray: typing.List[int], int2: int, position: 'MathArrays.Position') -> None: ...
    @typing.overload
    @staticmethod
    def shuffle(intArray: typing.List[int], int2: int, position: 'MathArrays.Position', randomGenerator: org.hipparchus.random.RandomGenerator) -> None: ...
    @typing.overload
    @staticmethod
    def shuffle(intArray: typing.List[int], randomGenerator: org.hipparchus.random.RandomGenerator) -> None: ...
    @typing.overload
    @staticmethod
    def sortInPlace(doubleArray: typing.List[float], doubleArray2: typing.List[typing.List[float]]) -> None: ...
    @typing.overload
    @staticmethod
    def sortInPlace(doubleArray: typing.List[float], orderDirection: 'MathArrays.OrderDirection', doubleArray2: typing.List[typing.List[float]]) -> None: ...
    @staticmethod
    def unique(doubleArray: typing.List[float]) -> typing.List[float]: ...
    @typing.overload
    @staticmethod
    def verifyValues(doubleArray: typing.List[float], doubleArray2: typing.List[float], int: int, int2: int) -> bool: ...
    @typing.overload
    @staticmethod
    def verifyValues(doubleArray: typing.List[float], doubleArray2: typing.List[float], int: int, int2: int, boolean: bool) -> bool: ...
    @typing.overload
    @staticmethod
    def verifyValues(doubleArray: typing.List[float], int: int, int2: int) -> bool: ...
    @typing.overload
    @staticmethod
    def verifyValues(doubleArray: typing.List[float], int: int, int2: int, boolean: bool) -> bool: ...
    class Function:
        @typing.overload
        def evaluate(self, doubleArray: typing.List[float]) -> float: ...
        @typing.overload
        def evaluate(self, doubleArray: typing.List[float], int: int, int2: int) -> float: ...
    class OrderDirection(java.lang.Enum['MathArrays.OrderDirection']):
        INCREASING: typing.ClassVar['MathArrays.OrderDirection'] = ...
        DECREASING: typing.ClassVar['MathArrays.OrderDirection'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'MathArrays.OrderDirection': ...
        @staticmethod
        def values() -> typing.List['MathArrays.OrderDirection']: ...
    class Position(java.lang.Enum['MathArrays.Position']):
        HEAD: typing.ClassVar['MathArrays.Position'] = ...
        TAIL: typing.ClassVar['MathArrays.Position'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'MathArrays.Position': ...
        @staticmethod
        def values() -> typing.List['MathArrays.Position']: ...

_MathUtils__FieldSumAndResidual__T = typing.TypeVar('_MathUtils__FieldSumAndResidual__T', bound=org.hipparchus.FieldElement)  # <T>
class MathUtils:
    TWO_PI: typing.ClassVar[float] = ...
    PI_SQUARED: typing.ClassVar[float] = ...
    SEMI_PI: typing.ClassVar[float] = ...
    @staticmethod
    def checkDimension(int: int, int2: int) -> None: ...
    @typing.overload
    @staticmethod
    def checkFinite(double: float) -> None: ...
    @typing.overload
    @staticmethod
    def checkFinite(doubleArray: typing.List[float]) -> None: ...
    @typing.overload
    @staticmethod
    def checkNotNull(object: typing.Any) -> None: ...
    @typing.overload
    @staticmethod
    def checkNotNull(object: typing.Any, localizable: org.hipparchus.exception.Localizable, objectArray: typing.List[typing.Any]) -> None: ...
    @typing.overload
    @staticmethod
    def checkRangeInclusive(double: float, double2: float, double3: float) -> None: ...
    @typing.overload
    @staticmethod
    def checkRangeInclusive(long: int, long2: int, long3: int) -> None: ...
    @typing.overload
    @staticmethod
    def copySign(byte: int, byte2: int) -> int: ...
    @typing.overload
    @staticmethod
    def copySign(int: int, int2: int) -> int: ...
    @typing.overload
    @staticmethod
    def copySign(long: int, long2: int) -> int: ...
    @typing.overload
    @staticmethod
    def copySign(short: int, short2: int) -> int: ...
    @typing.overload
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(double: float, double2: float) -> bool: ...
    @typing.overload
    @staticmethod
    def hash(double: float) -> int: ...
    @typing.overload
    @staticmethod
    def hash(doubleArray: typing.List[float]) -> int: ...
    _max__T = typing.TypeVar('_max__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @staticmethod
    def max(t: _max__T, t2: _max__T) -> _max__T: ...
    _min__T = typing.TypeVar('_min__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @staticmethod
    def min(t: _min__T, t2: _min__T) -> _min__T: ...
    _normalizeAngle_1__T = typing.TypeVar('_normalizeAngle_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def normalizeAngle(double: float, double2: float) -> float: ...
    @typing.overload
    @staticmethod
    def normalizeAngle(t: _normalizeAngle_1__T, t2: _normalizeAngle_1__T) -> _normalizeAngle_1__T: ...
    @staticmethod
    def reduce(double: float, double2: float, double3: float) -> float: ...
    _twoSum_0__T = typing.TypeVar('_twoSum_0__T', bound=org.hipparchus.FieldElement)  # <T>
    @typing.overload
    @staticmethod
    def twoSum(t: _twoSum_0__T, t2: _twoSum_0__T) -> 'MathUtils.FieldSumAndResidual'[_twoSum_0__T]: ...
    @typing.overload
    @staticmethod
    def twoSum(double: float, double2: float) -> 'MathUtils.SumAndResidual': ...
    class FieldSumAndResidual(typing.Generic[_MathUtils__FieldSumAndResidual__T]):
        def getResidual(self) -> _MathUtils__FieldSumAndResidual__T: ...
        def getSum(self) -> _MathUtils__FieldSumAndResidual__T: ...
    class SumAndResidual:
        def getResidual(self) -> float: ...
        def getSum(self) -> float: ...

class MultidimensionalCounter(java.lang.Iterable[int]):
    def __init__(self, intArray: typing.List[int]): ...
    def getCount(self, intArray: typing.List[int]) -> int: ...
    def getCounts(self, int: int) -> typing.List[int]: ...
    def getDimension(self) -> int: ...
    def getSize(self) -> int: ...
    def getSizes(self) -> typing.List[int]: ...
    def iterator(self) -> 'MultidimensionalCounter.Iterator': ...
    def toString(self) -> str: ...
    class Iterator(java.util.Iterator[int]):
        @typing.overload
        def getCount(self) -> int: ...
        @typing.overload
        def getCount(self, int: int) -> int: ...
        def getCounts(self) -> typing.List[int]: ...
        def hasNext(self) -> bool: ...
        def next(self) -> int: ...
        def remove(self) -> None: ...

_Pair__K = typing.TypeVar('_Pair__K')  # <K>
_Pair__V = typing.TypeVar('_Pair__V')  # <V>
class Pair(typing.Generic[_Pair__K, _Pair__V]):
    @typing.overload
    def __init__(self, k: _Pair__K, v: _Pair__V): ...
    @typing.overload
    def __init__(self, pair: 'Pair'[_Pair__K, _Pair__V]): ...
    _create__K = typing.TypeVar('_create__K')  # <K>
    _create__V = typing.TypeVar('_create__V')  # <V>
    @staticmethod
    def create(k: _create__K, v: _create__V) -> 'Pair'[_create__K, _create__V]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getFirst(self) -> _Pair__K: ...
    def getKey(self) -> _Pair__K: ...
    def getSecond(self) -> _Pair__V: ...
    def getValue(self) -> _Pair__V: ...
    def hashCode(self) -> int: ...
    def toString(self) -> str: ...

class PivotingStrategy(java.lang.Enum['PivotingStrategy']):
    CENTRAL: typing.ClassVar['PivotingStrategy'] = ...
    MEDIAN_OF_3: typing.ClassVar['PivotingStrategy'] = ...
    def pivotIndex(self, doubleArray: typing.List[float], int: int, int2: int) -> int: ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'PivotingStrategy': ...
    @staticmethod
    def values() -> typing.List['PivotingStrategy']: ...

class Precision:
    EPSILON: typing.ClassVar[float] = ...
    SAFE_MIN: typing.ClassVar[float] = ...
    @typing.overload
    @staticmethod
    def compareTo(double: float, double2: float, double3: float) -> int: ...
    @typing.overload
    @staticmethod
    def compareTo(double: float, double2: float, int: int) -> int: ...
    @typing.overload
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(double: float, double2: float) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(double: float, double2: float, double3: float) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(double: float, double2: float, int: int) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(float: float, float2: float) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(float: float, float2: float, float3: float) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(float: float, float2: float, int: int) -> bool: ...
    @typing.overload
    @staticmethod
    def equalsIncludingNaN(double: float, double2: float) -> bool: ...
    @typing.overload
    @staticmethod
    def equalsIncludingNaN(double: float, double2: float, double3: float) -> bool: ...
    @typing.overload
    @staticmethod
    def equalsIncludingNaN(double: float, double2: float, int: int) -> bool: ...
    @typing.overload
    @staticmethod
    def equalsIncludingNaN(float: float, float2: float) -> bool: ...
    @typing.overload
    @staticmethod
    def equalsIncludingNaN(float: float, float2: float, float3: float) -> bool: ...
    @typing.overload
    @staticmethod
    def equalsIncludingNaN(float: float, float2: float, int: int) -> bool: ...
    @staticmethod
    def equalsWithRelativeTolerance(double: float, double2: float, double3: float) -> bool: ...
    @typing.overload
    @staticmethod
    def isMathematicalInteger(double: float) -> bool: ...
    @typing.overload
    @staticmethod
    def isMathematicalInteger(float: float) -> bool: ...
    @staticmethod
    def representableDelta(double: float, double2: float) -> float: ...
    @typing.overload
    @staticmethod
    def round(double: float, int: int) -> float: ...
    @typing.overload
    @staticmethod
    def round(double: float, int: int, roundingMode: java.math.RoundingMode) -> float: ...
    @typing.overload
    @staticmethod
    def round(float: float, int: int) -> float: ...
    @typing.overload
    @staticmethod
    def round(float: float, int: int, roundingMode: java.math.RoundingMode) -> float: ...

class ResizableDoubleArray(java.io.Serializable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, doubleArray: typing.List[float]): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, double: float): ...
    @typing.overload
    def __init__(self, int: int, double: float, double2: float): ...
    @typing.overload
    def __init__(self, int: int, double: float, double2: float, expansionMode: 'ResizableDoubleArray.ExpansionMode', doubleArray: typing.List[float]): ...
    @typing.overload
    def __init__(self, resizableDoubleArray: 'ResizableDoubleArray'): ...
    def addElement(self, double: float) -> None: ...
    def addElementRolling(self, double: float) -> float: ...
    def addElements(self, doubleArray: typing.List[float]) -> None: ...
    def clear(self) -> None: ...
    def compute(self, function: MathArrays.Function) -> float: ...
    def contract(self) -> None: ...
    def copy(self) -> 'ResizableDoubleArray': ...
    def discardFrontElements(self, int: int) -> None: ...
    def discardMostRecentElements(self, int: int) -> None: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getCapacity(self) -> int: ...
    def getContractionCriterion(self) -> float: ...
    def getElement(self, int: int) -> float: ...
    def getElements(self) -> typing.List[float]: ...
    def getExpansionFactor(self) -> float: ...
    def getExpansionMode(self) -> 'ResizableDoubleArray.ExpansionMode': ...
    def getNumElements(self) -> int: ...
    def hashCode(self) -> int: ...
    def setElement(self, int: int, double: float) -> None: ...
    def setNumElements(self, int: int) -> None: ...
    def substituteMostRecentElement(self, double: float) -> float: ...
    class ExpansionMode(java.lang.Enum['ResizableDoubleArray.ExpansionMode']):
        MULTIPLICATIVE: typing.ClassVar['ResizableDoubleArray.ExpansionMode'] = ...
        ADDITIVE: typing.ClassVar['ResizableDoubleArray.ExpansionMode'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'ResizableDoubleArray.ExpansionMode': ...
        @staticmethod
        def values() -> typing.List['ResizableDoubleArray.ExpansionMode']: ...

class RosenNumberPartitionIterator(java.util.Iterator[typing.List[int]]):
    def __init__(self, int: int, int2: int): ...
    def hasNext(self) -> bool: ...
    def next(self) -> typing.List[int]: ...
    def reset(self) -> None: ...

class RyuDouble:
    DEFAULT_LOW_EXP: typing.ClassVar[int] = ...
    DEFAULT_HIGH_EXP: typing.ClassVar[int] = ...
    @typing.overload
    @staticmethod
    def doubleToString(double: float) -> str: ...
    @typing.overload
    @staticmethod
    def doubleToString(double: float, int: int, int2: int) -> str: ...

class SinCos:
    def cos(self) -> float: ...
    @staticmethod
    def difference(sinCos: 'SinCos', sinCos2: 'SinCos') -> 'SinCos': ...
    def sin(self) -> float: ...
    @staticmethod
    def sum(sinCos: 'SinCos', sinCos2: 'SinCos') -> 'SinCos': ...

class SinhCosh:
    def cosh(self) -> float: ...
    @staticmethod
    def difference(sinhCosh: 'SinhCosh', sinhCosh2: 'SinhCosh') -> 'SinhCosh': ...
    def sinh(self) -> float: ...
    @staticmethod
    def sum(sinhCosh: 'SinhCosh', sinhCosh2: 'SinhCosh') -> 'SinhCosh': ...

class Tuple(org.hipparchus.CalculusFieldElement['Tuple']):
    def __init__(self, doubleArray: typing.List[float]): ...
    def abs(self) -> 'Tuple': ...
    def acos(self) -> 'Tuple': ...
    def acosh(self) -> 'Tuple': ...
    @typing.overload
    def add(self, double: float) -> 'Tuple': ...
    @typing.overload
    def add(self, tuple: 'Tuple') -> 'Tuple': ...
    def asin(self) -> 'Tuple': ...
    def asinh(self) -> 'Tuple': ...
    def atan(self) -> 'Tuple': ...
    def atan2(self, tuple: 'Tuple') -> 'Tuple': ...
    def atanh(self) -> 'Tuple': ...
    def cbrt(self) -> 'Tuple': ...
    def ceil(self) -> 'Tuple': ...
    @typing.overload
    def copySign(self, double: float) -> 'Tuple': ...
    @typing.overload
    def copySign(self, tuple: 'Tuple') -> 'Tuple': ...
    def cos(self) -> 'Tuple': ...
    def cosh(self) -> 'Tuple': ...
    @typing.overload
    def divide(self, double: float) -> 'Tuple': ...
    @typing.overload
    def divide(self, tuple: 'Tuple') -> 'Tuple': ...
    def equals(self, object: typing.Any) -> bool: ...
    def exp(self) -> 'Tuple': ...
    def expm1(self) -> 'Tuple': ...
    def floor(self) -> 'Tuple': ...
    def getComponent(self, int: int) -> float: ...
    def getComponents(self) -> typing.List[float]: ...
    def getDimension(self) -> int: ...
    def getField(self) -> org.hipparchus.Field['Tuple']: ...
    def getPi(self) -> 'Tuple': ...
    def getReal(self) -> float: ...
    def hashCode(self) -> int: ...
    def hypot(self, tuple: 'Tuple') -> 'Tuple': ...
    @typing.overload
    def linearCombination(self, double: float, tuple: 'Tuple', double2: float, tuple2: 'Tuple') -> 'Tuple': ...
    @typing.overload
    def linearCombination(self, double: float, tuple: 'Tuple', double2: float, tuple2: 'Tuple', double3: float, tuple3: 'Tuple') -> 'Tuple': ...
    @typing.overload
    def linearCombination(self, double: float, tuple: 'Tuple', double2: float, tuple2: 'Tuple', double3: float, tuple3: 'Tuple', double4: float, tuple4: 'Tuple') -> 'Tuple': ...
    @typing.overload
    def linearCombination(self, doubleArray: typing.List[float], tupleArray: typing.List['Tuple']) -> 'Tuple': ...
    @typing.overload
    def linearCombination(self, tuple: 'Tuple', tuple2: 'Tuple', tuple3: 'Tuple', tuple4: 'Tuple') -> 'Tuple': ...
    @typing.overload
    def linearCombination(self, tuple: 'Tuple', tuple2: 'Tuple', tuple3: 'Tuple', tuple4: 'Tuple', tuple5: 'Tuple', tuple6: 'Tuple') -> 'Tuple': ...
    @typing.overload
    def linearCombination(self, tuple: 'Tuple', tuple2: 'Tuple', tuple3: 'Tuple', tuple4: 'Tuple', tuple5: 'Tuple', tuple6: 'Tuple', tuple7: 'Tuple', tuple8: 'Tuple') -> 'Tuple': ...
    @typing.overload
    def linearCombination(self, tupleArray: typing.List['Tuple'], tupleArray2: typing.List['Tuple']) -> 'Tuple': ...
    def log(self) -> 'Tuple': ...
    def log10(self) -> 'Tuple': ...
    def log1p(self) -> 'Tuple': ...
    @typing.overload
    def multiply(self, double: float) -> 'Tuple': ...
    @typing.overload
    def multiply(self, int: int) -> 'Tuple': ...
    @typing.overload
    def multiply(self, tuple: 'Tuple') -> 'Tuple': ...
    def negate(self) -> 'Tuple': ...
    def newInstance(self, double: float) -> 'Tuple': ...
    @typing.overload
    def pow(self, double: float) -> 'Tuple': ...
    @typing.overload
    def pow(self, int: int) -> 'Tuple': ...
    @typing.overload
    def pow(self, tuple: 'Tuple') -> 'Tuple': ...
    def reciprocal(self) -> 'Tuple': ...
    @typing.overload
    def remainder(self, double: float) -> 'Tuple': ...
    @typing.overload
    def remainder(self, tuple: 'Tuple') -> 'Tuple': ...
    def rint(self) -> 'Tuple': ...
    def rootN(self, int: int) -> 'Tuple': ...
    def scalb(self, int: int) -> 'Tuple': ...
    def sign(self) -> 'Tuple': ...
    def sin(self) -> 'Tuple': ...
    def sinCos(self) -> FieldSinCos['Tuple']: ...
    def sinh(self) -> 'Tuple': ...
    def sinhCosh(self) -> FieldSinhCosh['Tuple']: ...
    def sqrt(self) -> 'Tuple': ...
    def square(self) -> 'Tuple': ...
    @typing.overload
    def subtract(self, double: float) -> 'Tuple': ...
    @typing.overload
    def subtract(self, tuple: 'Tuple') -> 'Tuple': ...
    def tan(self) -> 'Tuple': ...
    def tanh(self) -> 'Tuple': ...
    def toDegrees(self) -> 'Tuple': ...
    def toRadians(self) -> 'Tuple': ...
    def ulp(self) -> 'Tuple': ...

class UnscentedTransformProvider:
    def getUnscentedCovariance(self, realVectorArray: typing.List[org.hipparchus.linear.RealVector], realVector2: org.hipparchus.linear.RealVector) -> org.hipparchus.linear.RealMatrix: ...
    def getUnscentedMeanState(self, realVectorArray: typing.List[org.hipparchus.linear.RealVector]) -> org.hipparchus.linear.RealVector: ...
    def getWc(self) -> org.hipparchus.linear.RealVector: ...
    def getWm(self) -> org.hipparchus.linear.RealVector: ...
    def inverseUnscentedTransform(self, realVectorArray: typing.List[org.hipparchus.linear.RealVector]) -> Pair[org.hipparchus.linear.RealVector, org.hipparchus.linear.RealMatrix]: ...
    def unscentedTransform(self, realVector: org.hipparchus.linear.RealVector, realMatrix: org.hipparchus.linear.RealMatrix) -> typing.List[org.hipparchus.linear.RealVector]: ...

class AbstractUnscentedTransform(UnscentedTransformProvider):
    def __init__(self, int: int): ...
    def unscentedTransform(self, realVector: org.hipparchus.linear.RealVector, realMatrix: org.hipparchus.linear.RealMatrix) -> typing.List[org.hipparchus.linear.RealVector]: ...

class JulierUnscentedTransform(AbstractUnscentedTransform):
    DEFAULT_KAPPA: typing.ClassVar[float] = ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, double: float): ...
    def getWc(self) -> org.hipparchus.linear.RealVector: ...
    def getWm(self) -> org.hipparchus.linear.RealVector: ...

class MerweUnscentedTransform(AbstractUnscentedTransform):
    DEFAULT_ALPHA: typing.ClassVar[float] = ...
    DEFAULT_BETA: typing.ClassVar[float] = ...
    DEFAULT_KAPPA: typing.ClassVar[float] = ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, double: float, double2: float, double3: float): ...
    def getWc(self) -> org.hipparchus.linear.RealVector: ...
    def getWm(self) -> org.hipparchus.linear.RealVector: ...

class OpenIntToDoubleHashMap(AbstractOpenIntHashMap, java.io.Serializable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, double: float): ...
    @typing.overload
    def __init__(self, openIntToDoubleHashMap: 'OpenIntToDoubleHashMap'): ...
    def equals(self, object: typing.Any) -> bool: ...
    def get(self, int: int) -> float: ...
    def hashCode(self) -> int: ...
    def iterator(self) -> 'OpenIntToDoubleHashMap.Iterator': ...
    def put(self, int: int, double: float) -> float: ...
    def remove(self, int: int) -> float: ...
    class Iterator(org.hipparchus.util.AbstractOpenIntHashMap.BaseIterator):
        def __init__(self, openIntToDoubleHashMap: 'OpenIntToDoubleHashMap'): ...
        def value(self) -> float: ...

_OpenIntToFieldHashMap__T = typing.TypeVar('_OpenIntToFieldHashMap__T', bound=org.hipparchus.FieldElement)  # <T>
class OpenIntToFieldHashMap(AbstractOpenIntHashMap, java.io.Serializable, typing.Generic[_OpenIntToFieldHashMap__T]):
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_OpenIntToFieldHashMap__T]): ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_OpenIntToFieldHashMap__T], int: int): ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_OpenIntToFieldHashMap__T], int: int, t: _OpenIntToFieldHashMap__T): ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_OpenIntToFieldHashMap__T], t: _OpenIntToFieldHashMap__T): ...
    @typing.overload
    def __init__(self, openIntToFieldHashMap: 'OpenIntToFieldHashMap'[_OpenIntToFieldHashMap__T]): ...
    def equals(self, object: typing.Any) -> bool: ...
    def get(self, int: int) -> _OpenIntToFieldHashMap__T: ...
    def hashCode(self) -> int: ...
    def iterator(self) -> 'OpenIntToFieldHashMap.Iterator': ...
    def put(self, int: int, t: _OpenIntToFieldHashMap__T) -> _OpenIntToFieldHashMap__T: ...
    def remove(self, int: int) -> _OpenIntToFieldHashMap__T: ...
    class Iterator(org.hipparchus.util.AbstractOpenIntHashMap.BaseIterator):
        def __init__(self, openIntToFieldHashMap: 'OpenIntToFieldHashMap'): ...
        def value(self) -> _OpenIntToFieldHashMap__T: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.hipparchus.util")``.

    AbstractOpenIntHashMap: typing.Type[AbstractOpenIntHashMap]
    AbstractUnscentedTransform: typing.Type[AbstractUnscentedTransform]
    ArithmeticUtils: typing.Type[ArithmeticUtils]
    BigReal: typing.Type[BigReal]
    BigRealField: typing.Type[BigRealField]
    Binary64: typing.Type[Binary64]
    Binary64Field: typing.Type[Binary64Field]
    Blendable: typing.Type[Blendable]
    Combinations: typing.Type[Combinations]
    CombinatoricsUtils: typing.Type[CombinatoricsUtils]
    CompositeFormat: typing.Type[CompositeFormat]
    ContinuedFraction: typing.Type[ContinuedFraction]
    FastMath: typing.Type[FastMath]
    FieldBlendable: typing.Type[FieldBlendable]
    FieldContinuedFraction: typing.Type[FieldContinuedFraction]
    FieldSinCos: typing.Type[FieldSinCos]
    FieldSinhCosh: typing.Type[FieldSinhCosh]
    FieldTuple: typing.Type[FieldTuple]
    Incrementor: typing.Type[Incrementor]
    IterationEvent: typing.Type[IterationEvent]
    IterationListener: typing.Type[IterationListener]
    IterationManager: typing.Type[IterationManager]
    JulierUnscentedTransform: typing.Type[JulierUnscentedTransform]
    KthSelector: typing.Type[KthSelector]
    MathArrays: typing.Type[MathArrays]
    MathUtils: typing.Type[MathUtils]
    MerweUnscentedTransform: typing.Type[MerweUnscentedTransform]
    MultidimensionalCounter: typing.Type[MultidimensionalCounter]
    OpenIntToDoubleHashMap: typing.Type[OpenIntToDoubleHashMap]
    OpenIntToFieldHashMap: typing.Type[OpenIntToFieldHashMap]
    Pair: typing.Type[Pair]
    PivotingStrategy: typing.Type[PivotingStrategy]
    Precision: typing.Type[Precision]
    ResizableDoubleArray: typing.Type[ResizableDoubleArray]
    RosenNumberPartitionIterator: typing.Type[RosenNumberPartitionIterator]
    RyuDouble: typing.Type[RyuDouble]
    SinCos: typing.Type[SinCos]
    SinhCosh: typing.Type[SinhCosh]
    Tuple: typing.Type[Tuple]
    UnscentedTransformProvider: typing.Type[UnscentedTransformProvider]
    class-use: org.hipparchus.util.class-use.__module_protocol__
