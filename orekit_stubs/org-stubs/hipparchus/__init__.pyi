import org.hipparchus.analysis
import org.hipparchus.complex
import org.hipparchus.dfp
import org.hipparchus.distribution
import org.hipparchus.exception
import org.hipparchus.filtering
import org.hipparchus.fitting
import org.hipparchus.fraction
import org.hipparchus.geometry
import org.hipparchus.linear
import org.hipparchus.ode
import org.hipparchus.optim
import org.hipparchus.random
import org.hipparchus.special
import org.hipparchus.stat
import org.hipparchus.util
import typing



_Field__T = typing.TypeVar('_Field__T', bound='FieldElement')  # <T>
class Field(typing.Generic[_Field__T]):
    def getOne(self) -> _Field__T: ...
    def getRuntimeClass(self) -> typing.Type[_Field__T]: ...
    def getZero(self) -> _Field__T: ...

_FieldElement__T = typing.TypeVar('_FieldElement__T', bound='FieldElement')  # <T>
class FieldElement(typing.Generic[_FieldElement__T]):
    def add(self, t: _FieldElement__T) -> _FieldElement__T: ...
    def divide(self, t: _FieldElement__T) -> _FieldElement__T: ...
    def getField(self) -> Field[_FieldElement__T]: ...
    def getReal(self) -> float: ...
    def isZero(self) -> bool: ...
    @typing.overload
    def multiply(self, int: int) -> _FieldElement__T: ...
    @typing.overload
    def multiply(self, t: _FieldElement__T) -> _FieldElement__T: ...
    def negate(self) -> _FieldElement__T: ...
    def reciprocal(self) -> _FieldElement__T: ...
    def subtract(self, t: _FieldElement__T) -> _FieldElement__T: ...

_CalculusFieldElement__T = typing.TypeVar('_CalculusFieldElement__T', bound=FieldElement)  # <T>
class CalculusFieldElement(FieldElement[_CalculusFieldElement__T], typing.Generic[_CalculusFieldElement__T]):
    def abs(self) -> _CalculusFieldElement__T: ...
    def acos(self) -> _CalculusFieldElement__T: ...
    def acosh(self) -> _CalculusFieldElement__T: ...
    @typing.overload
    def add(self, t: _CalculusFieldElement__T) -> _CalculusFieldElement__T: ...
    @typing.overload
    def add(self, double: float) -> _CalculusFieldElement__T: ...
    def asin(self) -> _CalculusFieldElement__T: ...
    def asinh(self) -> _CalculusFieldElement__T: ...
    def atan(self) -> _CalculusFieldElement__T: ...
    def atan2(self, t: _CalculusFieldElement__T) -> _CalculusFieldElement__T: ...
    def atanh(self) -> _CalculusFieldElement__T: ...
    def cbrt(self) -> _CalculusFieldElement__T: ...
    def ceil(self) -> _CalculusFieldElement__T: ...
    @typing.overload
    def copySign(self, t: _CalculusFieldElement__T) -> _CalculusFieldElement__T: ...
    @typing.overload
    def copySign(self, double: float) -> _CalculusFieldElement__T: ...
    def cos(self) -> _CalculusFieldElement__T: ...
    def cosh(self) -> _CalculusFieldElement__T: ...
    @typing.overload
    def divide(self, double: float) -> _CalculusFieldElement__T: ...
    @typing.overload
    def divide(self, t: _CalculusFieldElement__T) -> _CalculusFieldElement__T: ...
    def exp(self) -> _CalculusFieldElement__T: ...
    def expm1(self) -> _CalculusFieldElement__T: ...
    def floor(self) -> _CalculusFieldElement__T: ...
    def getExponent(self) -> int: ...
    def getPi(self) -> _CalculusFieldElement__T: ...
    def hypot(self, t: _CalculusFieldElement__T) -> _CalculusFieldElement__T: ...
    def isFinite(self) -> bool: ...
    def isInfinite(self) -> bool: ...
    def isNaN(self) -> bool: ...
    @typing.overload
    def linearCombination(self, t: _CalculusFieldElement__T, t2: _CalculusFieldElement__T, t3: _CalculusFieldElement__T, t4: _CalculusFieldElement__T) -> _CalculusFieldElement__T: ...
    @typing.overload
    def linearCombination(self, t: _CalculusFieldElement__T, t2: _CalculusFieldElement__T, t3: _CalculusFieldElement__T, t4: _CalculusFieldElement__T, t5: _CalculusFieldElement__T, t6: _CalculusFieldElement__T) -> _CalculusFieldElement__T: ...
    @typing.overload
    def linearCombination(self, t: _CalculusFieldElement__T, t2: _CalculusFieldElement__T, t3: _CalculusFieldElement__T, t4: _CalculusFieldElement__T, t5: _CalculusFieldElement__T, t6: _CalculusFieldElement__T, t7: _CalculusFieldElement__T, t8: _CalculusFieldElement__T) -> _CalculusFieldElement__T: ...
    @typing.overload
    def linearCombination(self, tArray: typing.List[_CalculusFieldElement__T], tArray2: typing.List[_CalculusFieldElement__T]) -> _CalculusFieldElement__T: ...
    @typing.overload
    def linearCombination(self, double: float, t: _CalculusFieldElement__T, double2: float, t2: _CalculusFieldElement__T) -> _CalculusFieldElement__T: ...
    @typing.overload
    def linearCombination(self, double: float, t: _CalculusFieldElement__T, double2: float, t2: _CalculusFieldElement__T, double3: float, t3: _CalculusFieldElement__T) -> _CalculusFieldElement__T: ...
    @typing.overload
    def linearCombination(self, double: float, t: _CalculusFieldElement__T, double2: float, t2: _CalculusFieldElement__T, double3: float, t3: _CalculusFieldElement__T, double4: float, t4: _CalculusFieldElement__T) -> _CalculusFieldElement__T: ...
    @typing.overload
    def linearCombination(self, doubleArray: typing.List[float], tArray: typing.List[_CalculusFieldElement__T]) -> _CalculusFieldElement__T: ...
    def log(self) -> _CalculusFieldElement__T: ...
    def log10(self) -> _CalculusFieldElement__T: ...
    def log1p(self) -> _CalculusFieldElement__T: ...
    @typing.overload
    def multiply(self, t: _CalculusFieldElement__T) -> _CalculusFieldElement__T: ...
    @typing.overload
    def multiply(self, double: float) -> _CalculusFieldElement__T: ...
    @typing.overload
    def multiply(self, int: int) -> _CalculusFieldElement__T: ...
    def newInstance(self, double: float) -> _CalculusFieldElement__T: ...
    def norm(self) -> float: ...
    @typing.overload
    def pow(self, t: _CalculusFieldElement__T) -> _CalculusFieldElement__T: ...
    @typing.overload
    def pow(self, double: float) -> _CalculusFieldElement__T: ...
    @typing.overload
    def pow(self, int: int) -> _CalculusFieldElement__T: ...
    @typing.overload
    def remainder(self, double: float) -> _CalculusFieldElement__T: ...
    @typing.overload
    def remainder(self, t: _CalculusFieldElement__T) -> _CalculusFieldElement__T: ...
    def rint(self) -> _CalculusFieldElement__T: ...
    def rootN(self, int: int) -> _CalculusFieldElement__T: ...
    def round(self) -> int: ...
    def scalb(self, int: int) -> _CalculusFieldElement__T: ...
    def sign(self) -> _CalculusFieldElement__T: ...
    def sin(self) -> _CalculusFieldElement__T: ...
    def sinCos(self) -> org.hipparchus.util.FieldSinCos[_CalculusFieldElement__T]: ...
    def sinh(self) -> _CalculusFieldElement__T: ...
    def sinhCosh(self) -> org.hipparchus.util.FieldSinhCosh[_CalculusFieldElement__T]: ...
    def sqrt(self) -> _CalculusFieldElement__T: ...
    def square(self) -> _CalculusFieldElement__T: ...
    @typing.overload
    def subtract(self, double: float) -> _CalculusFieldElement__T: ...
    @typing.overload
    def subtract(self, t: _CalculusFieldElement__T) -> _CalculusFieldElement__T: ...
    def tan(self) -> _CalculusFieldElement__T: ...
    def tanh(self) -> _CalculusFieldElement__T: ...
    def toDegrees(self) -> _CalculusFieldElement__T: ...
    def toRadians(self) -> _CalculusFieldElement__T: ...
    def ulp(self) -> _CalculusFieldElement__T: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.hipparchus")``.

    CalculusFieldElement: typing.Type[CalculusFieldElement]
    Field: typing.Type[Field]
    FieldElement: typing.Type[FieldElement]
    analysis: org.hipparchus.analysis.__module_protocol__
    complex: org.hipparchus.complex.__module_protocol__
    dfp: org.hipparchus.dfp.__module_protocol__
    distribution: org.hipparchus.distribution.__module_protocol__
    exception: org.hipparchus.exception.__module_protocol__
    filtering: org.hipparchus.filtering.__module_protocol__
    fitting: org.hipparchus.fitting.__module_protocol__
    fraction: org.hipparchus.fraction.__module_protocol__
    geometry: org.hipparchus.geometry.__module_protocol__
    linear: org.hipparchus.linear.__module_protocol__
    ode: org.hipparchus.ode.__module_protocol__
    optim: org.hipparchus.optim.__module_protocol__
    random: org.hipparchus.random.__module_protocol__
    special: org.hipparchus.special.__module_protocol__
    stat: org.hipparchus.stat.__module_protocol__
    util: org.hipparchus.util.__module_protocol__
