import java.io
import java.lang
import java.util
import org.hipparchus.exception
import org.hipparchus.stat.class-use
import org.hipparchus.stat.correlation
import org.hipparchus.stat.descriptive
import org.hipparchus.stat.fitting
import org.hipparchus.stat.inference
import org.hipparchus.stat.interval
import org.hipparchus.stat.projection
import org.hipparchus.stat.ranking
import org.hipparchus.stat.regression
import typing



_Frequency__T = typing.TypeVar('_Frequency__T', bound=java.lang.Comparable)  # <T>
class Frequency(java.io.Serializable, typing.Generic[_Frequency__T]):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, comparator: typing.Union[java.util.Comparator[_Frequency__T], typing.Callable[[_Frequency__T, _Frequency__T], int]]): ...
    def addValue(self, t: _Frequency__T) -> None: ...
    def clear(self) -> None: ...
    def entrySetIterator(self) -> java.util.Iterator[java.util.Map.Entry[_Frequency__T, int]]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getCount(self, t: _Frequency__T) -> int: ...
    def getCumFreq(self, t: _Frequency__T) -> int: ...
    def getCumPct(self, t: _Frequency__T) -> float: ...
    def getMode(self) -> java.util.List[_Frequency__T]: ...
    def getPct(self, t: _Frequency__T) -> float: ...
    def getSumFreq(self) -> int: ...
    def getUniqueCount(self) -> int: ...
    def hashCode(self) -> int: ...
    def incrementValue(self, t: _Frequency__T, long: int) -> None: ...
    @typing.overload
    def merge(self, collection: typing.Union[java.util.Collection['Frequency'[_Frequency__T]], typing.Sequence['Frequency'[_Frequency__T]]]) -> None: ...
    @typing.overload
    def merge(self, frequency: 'Frequency'[_Frequency__T]) -> None: ...
    def toString(self) -> str: ...
    def valuesIterator(self) -> java.util.Iterator[_Frequency__T]: ...

class LocalizedStatFormats(java.lang.Enum['LocalizedStatFormats'], org.hipparchus.exception.Localizable):
    TIES_ARE_NOT_ALLOWED: typing.ClassVar['LocalizedStatFormats'] = ...
    INSUFFICIENT_DATA_FOR_T_STATISTIC: typing.ClassVar['LocalizedStatFormats'] = ...
    NOT_ENOUGH_DATA_REGRESSION: typing.ClassVar['LocalizedStatFormats'] = ...
    INVALID_REGRESSION_OBSERVATION: typing.ClassVar['LocalizedStatFormats'] = ...
    NOT_ENOUGH_DATA_FOR_NUMBER_OF_PREDICTORS: typing.ClassVar['LocalizedStatFormats'] = ...
    NOT_SUPPORTED_NAN_STRATEGY: typing.ClassVar['LocalizedStatFormats'] = ...
    NO_REGRESSORS: typing.ClassVar['LocalizedStatFormats'] = ...
    COVARIANCE_MATRIX: typing.ClassVar['LocalizedStatFormats'] = ...
    OUT_OF_BOUNDS_QUANTILE_VALUE: typing.ClassVar['LocalizedStatFormats'] = ...
    OUT_OF_BOUNDS_CONFIDENCE_LEVEL: typing.ClassVar['LocalizedStatFormats'] = ...
    OUT_OF_BOUND_SIGNIFICANCE_LEVEL: typing.ClassVar['LocalizedStatFormats'] = ...
    SIGNIFICANCE_LEVEL: typing.ClassVar['LocalizedStatFormats'] = ...
    TOO_MANY_REGRESSORS: typing.ClassVar['LocalizedStatFormats'] = ...
    TWO_OR_MORE_CATEGORIES_REQUIRED: typing.ClassVar['LocalizedStatFormats'] = ...
    TWO_OR_MORE_VALUES_IN_CATEGORY_REQUIRED: typing.ClassVar['LocalizedStatFormats'] = ...
    ILLEGAL_STATE_PCA: typing.ClassVar['LocalizedStatFormats'] = ...
    def getLocalizedString(self, locale: java.util.Locale) -> str: ...
    def getSourceString(self) -> str: ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'LocalizedStatFormats': ...
    @staticmethod
    def values() -> typing.List['LocalizedStatFormats']: ...

class StatUtils:
    @typing.overload
    @staticmethod
    def geometricMean(doubleArray: typing.List[float]) -> float: ...
    @typing.overload
    @staticmethod
    def geometricMean(doubleArray: typing.List[float], int: int, int2: int) -> float: ...
    @typing.overload
    @staticmethod
    def max(doubleArray: typing.List[float]) -> float: ...
    @typing.overload
    @staticmethod
    def max(doubleArray: typing.List[float], int: int, int2: int) -> float: ...
    @typing.overload
    @staticmethod
    def mean(doubleArray: typing.List[float]) -> float: ...
    @typing.overload
    @staticmethod
    def mean(doubleArray: typing.List[float], int: int, int2: int) -> float: ...
    @staticmethod
    def meanDifference(doubleArray: typing.List[float], doubleArray2: typing.List[float]) -> float: ...
    @typing.overload
    @staticmethod
    def min(doubleArray: typing.List[float]) -> float: ...
    @typing.overload
    @staticmethod
    def min(doubleArray: typing.List[float], int: int, int2: int) -> float: ...
    @typing.overload
    @staticmethod
    def mode(doubleArray: typing.List[float]) -> typing.List[float]: ...
    @typing.overload
    @staticmethod
    def mode(doubleArray: typing.List[float], int: int, int2: int) -> typing.List[float]: ...
    @staticmethod
    def normalize(doubleArray: typing.List[float]) -> typing.List[float]: ...
    @typing.overload
    @staticmethod
    def percentile(doubleArray: typing.List[float], double2: float) -> float: ...
    @typing.overload
    @staticmethod
    def percentile(doubleArray: typing.List[float], int: int, int2: int, double2: float) -> float: ...
    @typing.overload
    @staticmethod
    def populationVariance(doubleArray: typing.List[float]) -> float: ...
    @typing.overload
    @staticmethod
    def populationVariance(doubleArray: typing.List[float], double2: float) -> float: ...
    @typing.overload
    @staticmethod
    def populationVariance(doubleArray: typing.List[float], double2: float, int: int, int2: int) -> float: ...
    @typing.overload
    @staticmethod
    def populationVariance(doubleArray: typing.List[float], int: int, int2: int) -> float: ...
    @typing.overload
    @staticmethod
    def product(doubleArray: typing.List[float]) -> float: ...
    @typing.overload
    @staticmethod
    def product(doubleArray: typing.List[float], int: int, int2: int) -> float: ...
    @typing.overload
    @staticmethod
    def sum(doubleArray: typing.List[float]) -> float: ...
    @typing.overload
    @staticmethod
    def sum(doubleArray: typing.List[float], int: int, int2: int) -> float: ...
    @staticmethod
    def sumDifference(doubleArray: typing.List[float], doubleArray2: typing.List[float]) -> float: ...
    @typing.overload
    @staticmethod
    def sumLog(doubleArray: typing.List[float]) -> float: ...
    @typing.overload
    @staticmethod
    def sumLog(doubleArray: typing.List[float], int: int, int2: int) -> float: ...
    @typing.overload
    @staticmethod
    def sumSq(doubleArray: typing.List[float]) -> float: ...
    @typing.overload
    @staticmethod
    def sumSq(doubleArray: typing.List[float], int: int, int2: int) -> float: ...
    @typing.overload
    @staticmethod
    def variance(doubleArray: typing.List[float]) -> float: ...
    @typing.overload
    @staticmethod
    def variance(doubleArray: typing.List[float], double2: float) -> float: ...
    @typing.overload
    @staticmethod
    def variance(doubleArray: typing.List[float], double2: float, int: int, int2: int) -> float: ...
    @typing.overload
    @staticmethod
    def variance(doubleArray: typing.List[float], int: int, int2: int) -> float: ...
    @staticmethod
    def varianceDifference(doubleArray: typing.List[float], doubleArray2: typing.List[float], double3: float) -> float: ...

class LongFrequency(Frequency[int]):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, comparator: typing.Union[java.util.Comparator[int], typing.Callable[[int, int], int]]): ...
    @typing.overload
    def addValue(self, t: java.lang.Comparable) -> None: ...
    @typing.overload
    def addValue(self, int: int) -> None: ...
    @typing.overload
    def getCount(self, t: java.lang.Comparable) -> int: ...
    @typing.overload
    def getCount(self, int: int) -> int: ...
    @typing.overload
    def getCumFreq(self, t: java.lang.Comparable) -> int: ...
    @typing.overload
    def getCumFreq(self, int: int) -> int: ...
    @typing.overload
    def getCumPct(self, t: java.lang.Comparable) -> float: ...
    @typing.overload
    def getCumPct(self, int: int) -> float: ...
    @typing.overload
    def getPct(self, t: java.lang.Comparable) -> float: ...
    @typing.overload
    def getPct(self, int: int) -> float: ...
    @typing.overload
    def incrementValue(self, t: java.lang.Comparable, long: int) -> None: ...
    @typing.overload
    def incrementValue(self, int: int, long: int) -> None: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.hipparchus.stat")``.

    Frequency: typing.Type[Frequency]
    LocalizedStatFormats: typing.Type[LocalizedStatFormats]
    LongFrequency: typing.Type[LongFrequency]
    StatUtils: typing.Type[StatUtils]
    class-use: org.hipparchus.stat.class-use.__module_protocol__
    correlation: org.hipparchus.stat.correlation.__module_protocol__
    descriptive: org.hipparchus.stat.descriptive.__module_protocol__
    fitting: org.hipparchus.stat.fitting.__module_protocol__
    inference: org.hipparchus.stat.inference.__module_protocol__
    interval: org.hipparchus.stat.interval.__module_protocol__
    projection: org.hipparchus.stat.projection.__module_protocol__
    ranking: org.hipparchus.stat.ranking.__module_protocol__
    regression: org.hipparchus.stat.regression.__module_protocol__
