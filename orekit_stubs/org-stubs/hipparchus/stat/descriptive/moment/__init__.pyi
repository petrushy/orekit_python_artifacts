import java.io
import java.lang
import org.hipparchus.stat.descriptive
import org.hipparchus.stat.descriptive.summary
import typing



class GeometricMean(org.hipparchus.stat.descriptive.AbstractStorelessUnivariateStatistic, org.hipparchus.stat.descriptive.AggregatableStatistic['GeometricMean'], java.io.Serializable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, geometricMean: 'GeometricMean'): ...
    @typing.overload
    def __init__(self, sumOfLogs: org.hipparchus.stat.descriptive.summary.SumOfLogs): ...
    @typing.overload
    def aggregate(self, iterable: typing.Union[java.lang.Iterable[typing.Any], typing.Sequence[typing.Any], typing.Set[typing.Any]]) -> None: ...
    @typing.overload
    def aggregate(self, *t: typing.Any) -> None: ...
    @typing.overload
    def aggregate(self, geometricMean: 'GeometricMean') -> None: ...
    def clear(self) -> None: ...
    def copy(self) -> 'GeometricMean': ...
    @typing.overload
    def evaluate(self, doubleArray: typing.List[float]) -> float: ...
    @typing.overload
    def evaluate(self, doubleArray: typing.List[float], int: int, int2: int) -> float: ...
    def getN(self) -> int: ...
    def getResult(self) -> float: ...
    def increment(self, double: float) -> None: ...

class Kurtosis(org.hipparchus.stat.descriptive.AbstractStorelessUnivariateStatistic, java.io.Serializable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, fourthMoment: 'FourthMoment'): ...
    @typing.overload
    def __init__(self, kurtosis: 'Kurtosis'): ...
    def clear(self) -> None: ...
    def copy(self) -> 'Kurtosis': ...
    @typing.overload
    def evaluate(self, doubleArray: typing.List[float]) -> float: ...
    @typing.overload
    def evaluate(self, doubleArray: typing.List[float], int: int, int2: int) -> float: ...
    def getN(self) -> int: ...
    def getResult(self) -> float: ...
    def increment(self, double: float) -> None: ...

class Mean(org.hipparchus.stat.descriptive.AbstractStorelessUnivariateStatistic, org.hipparchus.stat.descriptive.AggregatableStatistic['Mean'], org.hipparchus.stat.descriptive.WeightedEvaluation, java.io.Serializable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, firstMoment: 'FirstMoment'): ...
    @typing.overload
    def __init__(self, mean: 'Mean'): ...
    @typing.overload
    def aggregate(self, iterable: typing.Union[java.lang.Iterable[typing.Any], typing.Sequence[typing.Any], typing.Set[typing.Any]]) -> None: ...
    @typing.overload
    def aggregate(self, *t: typing.Any) -> None: ...
    @typing.overload
    def aggregate(self, mean: 'Mean') -> None: ...
    def clear(self) -> None: ...
    def copy(self) -> 'Mean': ...
    @typing.overload
    def evaluate(self, doubleArray: typing.List[float]) -> float: ...
    @typing.overload
    def evaluate(self, doubleArray: typing.List[float], doubleArray2: typing.List[float]) -> float: ...
    @typing.overload
    def evaluate(self, doubleArray: typing.List[float], doubleArray2: typing.List[float], int: int, int2: int) -> float: ...
    @typing.overload
    def evaluate(self, doubleArray: typing.List[float], int: int, int2: int) -> float: ...
    def getN(self) -> int: ...
    def getResult(self) -> float: ...
    def increment(self, double: float) -> None: ...

class SemiVariance(org.hipparchus.stat.descriptive.AbstractUnivariateStatistic, java.io.Serializable):
    UPSIDE_VARIANCE: typing.ClassVar['SemiVariance.Direction'] = ...
    DOWNSIDE_VARIANCE: typing.ClassVar['SemiVariance.Direction'] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, boolean: bool): ...
    @typing.overload
    def __init__(self, boolean: bool, direction: 'SemiVariance.Direction'): ...
    @typing.overload
    def __init__(self, direction: 'SemiVariance.Direction'): ...
    @typing.overload
    def __init__(self, semiVariance: 'SemiVariance'): ...
    def copy(self) -> 'SemiVariance': ...
    @typing.overload
    def evaluate(self, doubleArray: typing.List[float]) -> float: ...
    @typing.overload
    def evaluate(self) -> float: ...
    @typing.overload
    def evaluate(self, doubleArray: typing.List[float], double2: float) -> float: ...
    @typing.overload
    def evaluate(self, doubleArray: typing.List[float], double2: float, direction: 'SemiVariance.Direction') -> float: ...
    @typing.overload
    def evaluate(self, doubleArray: typing.List[float], double2: float, direction: 'SemiVariance.Direction', boolean: bool, int: int, int2: int) -> float: ...
    @typing.overload
    def evaluate(self, doubleArray: typing.List[float], int: int, int2: int) -> float: ...
    @typing.overload
    def evaluate(self, doubleArray: typing.List[float], direction: 'SemiVariance.Direction') -> float: ...
    def getVarianceDirection(self) -> 'SemiVariance.Direction': ...
    def isBiasCorrected(self) -> bool: ...
    def withBiasCorrected(self, boolean: bool) -> 'SemiVariance': ...
    def withVarianceDirection(self, direction: 'SemiVariance.Direction') -> 'SemiVariance': ...
    class Direction(java.lang.Enum['SemiVariance.Direction']):
        UPSIDE: typing.ClassVar['SemiVariance.Direction'] = ...
        DOWNSIDE: typing.ClassVar['SemiVariance.Direction'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'SemiVariance.Direction': ...
        @staticmethod
        def values() -> typing.List['SemiVariance.Direction']: ...

class Skewness(org.hipparchus.stat.descriptive.AbstractStorelessUnivariateStatistic, java.io.Serializable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, skewness: 'Skewness'): ...
    @typing.overload
    def __init__(self, thirdMoment: 'ThirdMoment'): ...
    def clear(self) -> None: ...
    def copy(self) -> 'Skewness': ...
    @typing.overload
    def evaluate(self, doubleArray: typing.List[float]) -> float: ...
    @typing.overload
    def evaluate(self, doubleArray: typing.List[float], int: int, int2: int) -> float: ...
    def getN(self) -> int: ...
    def getResult(self) -> float: ...
    def increment(self, double: float) -> None: ...

class StandardDeviation(org.hipparchus.stat.descriptive.AbstractStorelessUnivariateStatistic, java.io.Serializable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, boolean: bool): ...
    @typing.overload
    def __init__(self, boolean: bool, secondMoment: 'SecondMoment'): ...
    @typing.overload
    def __init__(self, secondMoment: 'SecondMoment'): ...
    @typing.overload
    def __init__(self, standardDeviation: 'StandardDeviation'): ...
    def clear(self) -> None: ...
    def copy(self) -> 'StandardDeviation': ...
    @typing.overload
    def evaluate(self, doubleArray: typing.List[float]) -> float: ...
    @typing.overload
    def evaluate(self, doubleArray: typing.List[float], double2: float) -> float: ...
    @typing.overload
    def evaluate(self, doubleArray: typing.List[float], double2: float, int: int, int2: int) -> float: ...
    @typing.overload
    def evaluate(self, doubleArray: typing.List[float], int: int, int2: int) -> float: ...
    def getN(self) -> int: ...
    def getResult(self) -> float: ...
    def increment(self, double: float) -> None: ...
    def isBiasCorrected(self) -> bool: ...
    def withBiasCorrection(self, boolean: bool) -> 'StandardDeviation': ...

class Variance(org.hipparchus.stat.descriptive.AbstractStorelessUnivariateStatistic, org.hipparchus.stat.descriptive.AggregatableStatistic['Variance'], org.hipparchus.stat.descriptive.WeightedEvaluation, java.io.Serializable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, boolean: bool): ...
    @typing.overload
    def __init__(self, boolean: bool, secondMoment: 'SecondMoment'): ...
    @typing.overload
    def __init__(self, secondMoment: 'SecondMoment'): ...
    @typing.overload
    def __init__(self, variance: 'Variance'): ...
    @typing.overload
    def aggregate(self, iterable: typing.Union[java.lang.Iterable[typing.Any], typing.Sequence[typing.Any], typing.Set[typing.Any]]) -> None: ...
    @typing.overload
    def aggregate(self, *t: typing.Any) -> None: ...
    @typing.overload
    def aggregate(self, variance: 'Variance') -> None: ...
    def clear(self) -> None: ...
    def copy(self) -> 'Variance': ...
    @typing.overload
    def evaluate(self, doubleArray: typing.List[float]) -> float: ...
    @typing.overload
    def evaluate(self, doubleArray: typing.List[float], doubleArray2: typing.List[float]) -> float: ...
    @typing.overload
    def evaluate(self, doubleArray: typing.List[float], double2: float) -> float: ...
    @typing.overload
    def evaluate(self, doubleArray: typing.List[float], double2: float, int: int, int2: int) -> float: ...
    @typing.overload
    def evaluate(self, doubleArray: typing.List[float], doubleArray2: typing.List[float], double3: float) -> float: ...
    @typing.overload
    def evaluate(self, doubleArray: typing.List[float], doubleArray2: typing.List[float], double3: float, int: int, int2: int) -> float: ...
    @typing.overload
    def evaluate(self, doubleArray: typing.List[float], doubleArray2: typing.List[float], int: int, int2: int) -> float: ...
    @typing.overload
    def evaluate(self, doubleArray: typing.List[float], int: int, int2: int) -> float: ...
    def getN(self) -> int: ...
    def getResult(self) -> float: ...
    def increment(self, double: float) -> None: ...
    def isBiasCorrected(self) -> bool: ...
    def withBiasCorrection(self, boolean: bool) -> 'Variance': ...

class FirstMoment: ...

class FourthMoment: ...

class ThirdMoment: ...

class SecondMoment(FirstMoment, org.hipparchus.stat.descriptive.AggregatableStatistic['SecondMoment'], java.io.Serializable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, secondMoment: 'SecondMoment'): ...
    @typing.overload
    def aggregate(self, iterable: typing.Union[java.lang.Iterable[typing.Any], typing.Sequence[typing.Any], typing.Set[typing.Any]]) -> None: ...
    @typing.overload
    def aggregate(self, *t: typing.Any) -> None: ...
    @typing.overload
    def aggregate(self, secondMoment: 'SecondMoment') -> None: ...
    def clear(self) -> None: ...
    def copy(self) -> 'SecondMoment': ...
    def getResult(self) -> float: ...
    def increment(self, double: float) -> None: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.hipparchus.stat.descriptive.moment")``.

    FirstMoment: typing.Type[FirstMoment]
    FourthMoment: typing.Type[FourthMoment]
    GeometricMean: typing.Type[GeometricMean]
    Kurtosis: typing.Type[Kurtosis]
    Mean: typing.Type[Mean]
    SecondMoment: typing.Type[SecondMoment]
    SemiVariance: typing.Type[SemiVariance]
    Skewness: typing.Type[Skewness]
    StandardDeviation: typing.Type[StandardDeviation]
    ThirdMoment: typing.Type[ThirdMoment]
    Variance: typing.Type[Variance]
