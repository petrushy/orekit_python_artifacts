import datetime
import java.io
import java.lang
import java.time
import java.util
import java.util.concurrent
import java.util.function
import java.util.stream
import org.hipparchus
import org.orekit.data
import org.orekit.frames
import org.orekit.gnss
import org.orekit.utils
import typing



class ChronologicalComparator(java.util.Comparator['TimeStamped'], java.io.Serializable):
    def __init__(self): ...
    def compare(self, timeStamped: 'TimeStamped', timeStamped2: 'TimeStamped') -> int: ...

class ClockModel:
    _getOffset_1__T = typing.TypeVar('_getOffset_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def getOffset(self, absoluteDate: 'AbsoluteDate') -> 'ClockOffset': ...
    @typing.overload
    def getOffset(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_getOffset_1__T]) -> 'FieldClockOffset'[_getOffset_1__T]: ...
    def getValidityEnd(self) -> 'AbsoluteDate': ...
    def getValidityStart(self) -> 'AbsoluteDate': ...

class DateComponents(java.io.Serializable, java.lang.Comparable['DateComponents']):
    JULIAN_EPOCH: typing.ClassVar['DateComponents'] = ...
    MODIFIED_JULIAN_EPOCH: typing.ClassVar['DateComponents'] = ...
    FIFTIES_EPOCH: typing.ClassVar['DateComponents'] = ...
    CCSDS_EPOCH: typing.ClassVar['DateComponents'] = ...
    GALILEO_EPOCH: typing.ClassVar['DateComponents'] = ...
    GPS_EPOCH: typing.ClassVar['DateComponents'] = ...
    QZSS_EPOCH: typing.ClassVar['DateComponents'] = ...
    IRNSS_EPOCH: typing.ClassVar['DateComponents'] = ...
    BEIDOU_EPOCH: typing.ClassVar['DateComponents'] = ...
    GLONASS_EPOCH: typing.ClassVar['DateComponents'] = ...
    J2000_EPOCH: typing.ClassVar['DateComponents'] = ...
    JAVA_EPOCH: typing.ClassVar['DateComponents'] = ...
    MAX_EPOCH: typing.ClassVar['DateComponents'] = ...
    MIN_EPOCH: typing.ClassVar['DateComponents'] = ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, int2: int): ...
    @typing.overload
    def __init__(self, int: int, int2: int, int3: int): ...
    @typing.overload
    def __init__(self, int: int, month: 'Month', int2: int): ...
    @typing.overload
    def __init__(self, dateComponents: 'DateComponents', int: int): ...
    def compareTo(self, dateComponents: 'DateComponents') -> int: ...
    @staticmethod
    def createFromWeekComponents(int: int, int2: int, int3: int) -> 'DateComponents': ...
    def equals(self, object: typing.Any) -> bool: ...
    def getCalendarWeek(self) -> int: ...
    def getDay(self) -> int: ...
    def getDayOfWeek(self) -> int: ...
    def getDayOfYear(self) -> int: ...
    def getJ2000Day(self) -> int: ...
    def getMJD(self) -> int: ...
    def getMonth(self) -> int: ...
    def getMonthEnum(self) -> 'Month': ...
    def getYear(self) -> int: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def parseDate(string: str) -> 'DateComponents': ...
    def toString(self) -> str: ...

class DateTimeComponents(java.io.Serializable, java.lang.Comparable['DateTimeComponents']):
    JULIAN_EPOCH: typing.ClassVar['DateTimeComponents'] = ...
    @typing.overload
    def __init__(self, int: int, int2: int, int3: int): ...
    @typing.overload
    def __init__(self, int: int, int2: int, int3: int, int4: int, int5: int, double: float): ...
    @typing.overload
    def __init__(self, int: int, month: 'Month', int2: int): ...
    @typing.overload
    def __init__(self, int: int, month: 'Month', int2: int, int3: int, int4: int, double: float): ...
    @typing.overload
    def __init__(self, dateComponents: DateComponents, timeComponents: 'TimeComponents'): ...
    @typing.overload
    def __init__(self, dateTimeComponents: 'DateTimeComponents', double: float): ...
    @typing.overload
    def __init__(self, dateTimeComponents: 'DateTimeComponents', long: int, timeUnit: java.util.concurrent.TimeUnit): ...
    def compareTo(self, dateTimeComponents: 'DateTimeComponents') -> int: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getDate(self) -> DateComponents: ...
    def getTime(self) -> 'TimeComponents': ...
    def hashCode(self) -> int: ...
    @typing.overload
    def offsetFrom(self, dateTimeComponents: 'DateTimeComponents') -> float: ...
    @typing.overload
    def offsetFrom(self, dateTimeComponents: 'DateTimeComponents', timeUnit: java.util.concurrent.TimeUnit) -> int: ...
    @staticmethod
    def parseDateTime(string: str) -> 'DateTimeComponents': ...
    def roundIfNeeded(self, int: int, int2: int) -> 'DateTimeComponents': ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    def toString(self, int: int) -> str: ...
    @typing.overload
    def toString(self, int: int, int2: int) -> str: ...
    def toStringRfc3339(self) -> str: ...
    @typing.overload
    def toStringWithoutUtcOffset(self) -> str: ...
    @typing.overload
    def toStringWithoutUtcOffset(self, int: int, int2: int) -> str: ...

class DatesSelector:
    def selectDates(self, absoluteDate: 'AbsoluteDate', absoluteDate2: 'AbsoluteDate') -> java.util.List['AbsoluteDate']: ...

_FieldChronologicalComparator__KK = typing.TypeVar('_FieldChronologicalComparator__KK', bound=org.hipparchus.CalculusFieldElement)  # <KK>
class FieldChronologicalComparator(java.util.Comparator['FieldTimeStamped'[_FieldChronologicalComparator__KK]], java.io.Serializable, typing.Generic[_FieldChronologicalComparator__KK]):
    def __init__(self): ...
    def compare(self, fieldTimeStamped: 'FieldTimeStamped'[_FieldChronologicalComparator__KK], fieldTimeStamped2: 'FieldTimeStamped'[_FieldChronologicalComparator__KK]) -> int: ...

_FieldTimeInterpolator__T = typing.TypeVar('_FieldTimeInterpolator__T', bound='FieldTimeStamped')  # <T>
_FieldTimeInterpolator__KK = typing.TypeVar('_FieldTimeInterpolator__KK', bound=org.hipparchus.CalculusFieldElement)  # <KK>
class FieldTimeInterpolator(typing.Generic[_FieldTimeInterpolator__T, _FieldTimeInterpolator__KK]):
    def getExtrapolationThreshold(self) -> float: ...
    def getNbInterpolationPoints(self) -> int: ...
    def getSubInterpolators(self) -> java.util.List['FieldTimeInterpolator'['FieldTimeStamped'[_FieldTimeInterpolator__KK], _FieldTimeInterpolator__KK]]: ...
    @typing.overload
    def interpolate(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_FieldTimeInterpolator__KK], collection: typing.Union[java.util.Collection[_FieldTimeInterpolator__T], typing.Sequence[_FieldTimeInterpolator__T], typing.Set[_FieldTimeInterpolator__T]]) -> _FieldTimeInterpolator__T: ...
    @typing.overload
    def interpolate(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_FieldTimeInterpolator__KK], stream: java.util.stream.Stream[_FieldTimeInterpolator__T]) -> _FieldTimeInterpolator__T: ...
    @typing.overload
    def interpolate(self, absoluteDate: 'AbsoluteDate', collection: typing.Union[java.util.Collection[_FieldTimeInterpolator__T], typing.Sequence[_FieldTimeInterpolator__T], typing.Set[_FieldTimeInterpolator__T]]) -> _FieldTimeInterpolator__T: ...
    @typing.overload
    def interpolate(self, absoluteDate: 'AbsoluteDate', stream: java.util.stream.Stream[_FieldTimeInterpolator__T]) -> _FieldTimeInterpolator__T: ...

_FieldTimeStamped__T = typing.TypeVar('_FieldTimeStamped__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
class FieldTimeStamped(typing.Generic[_FieldTimeStamped__T]):
    def durationFrom(self, fieldTimeStamped: 'FieldTimeStamped'[_FieldTimeStamped__T]) -> _FieldTimeStamped__T: ...
    def getDate(self) -> 'FieldAbsoluteDate'[_FieldTimeStamped__T]: ...

class Month(java.lang.Enum['Month']):
    JANUARY: typing.ClassVar['Month'] = ...
    FEBRUARY: typing.ClassVar['Month'] = ...
    MARCH: typing.ClassVar['Month'] = ...
    APRIL: typing.ClassVar['Month'] = ...
    MAY: typing.ClassVar['Month'] = ...
    JUNE: typing.ClassVar['Month'] = ...
    JULY: typing.ClassVar['Month'] = ...
    AUGUST: typing.ClassVar['Month'] = ...
    SEPTEMBER: typing.ClassVar['Month'] = ...
    OCTOBER: typing.ClassVar['Month'] = ...
    NOVEMBER: typing.ClassVar['Month'] = ...
    DECEMBER: typing.ClassVar['Month'] = ...
    def getCapitalizedAbbreviation(self) -> str: ...
    def getCapitalizedName(self) -> str: ...
    def getLowerCaseAbbreviation(self) -> str: ...
    def getLowerCaseName(self) -> str: ...
    @staticmethod
    def getMonth(int: int) -> 'Month': ...
    def getNumber(self) -> int: ...
    def getUpperCaseAbbreviation(self) -> str: ...
    def getUpperCaseName(self) -> str: ...
    @staticmethod
    def parseMonth(string: str) -> 'Month': ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'Month': ...
    @staticmethod
    def values() -> typing.List['Month']: ...

class OffsetModel(java.io.Serializable):
    @typing.overload
    def __init__(self, dateComponents: DateComponents, int: int): ...
    @typing.overload
    def __init__(self, dateComponents: DateComponents, int: int, double: float, double2: float): ...
    def getMJDRef(self) -> int: ...
    def getOffset(self) -> float: ...
    def getSlope(self) -> float: ...
    def getStart(self) -> DateComponents: ...

class TimeComponents(java.io.Serializable, java.lang.Comparable['TimeComponents']):
    H00: typing.ClassVar['TimeComponents'] = ...
    H12: typing.ClassVar['TimeComponents'] = ...
    @typing.overload
    def __init__(self, double: float): ...
    @typing.overload
    def __init__(self, int: int, double: float): ...
    @typing.overload
    def __init__(self, int: int, int2: int, double: float): ...
    @typing.overload
    def __init__(self, int: int, int2: int, double: float, int3: int): ...
    def compareTo(self, timeComponents: 'TimeComponents') -> int: ...
    def equals(self, object: typing.Any) -> bool: ...
    def formatUtcOffset(self) -> str: ...
    @staticmethod
    def fromSeconds(int: int, double: float, double2: float, int2: int) -> 'TimeComponents': ...
    def getHour(self) -> int: ...
    def getMinute(self) -> int: ...
    def getMinutesFromUTC(self) -> int: ...
    def getSecond(self) -> float: ...
    def getSecondsInLocalDay(self) -> float: ...
    def getSecondsInUTCDay(self) -> float: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def parseTime(string: str) -> 'TimeComponents': ...
    def toString(self) -> str: ...
    def toStringWithoutUtcOffset(self) -> str: ...

_TimeInterpolator__T = typing.TypeVar('_TimeInterpolator__T', bound='TimeStamped')  # <T>
class TimeInterpolator(typing.Generic[_TimeInterpolator__T]):
    def getExtrapolationThreshold(self) -> float: ...
    def getNbInterpolationPoints(self) -> int: ...
    def getSubInterpolators(self) -> java.util.List['TimeInterpolator'['TimeStamped']]: ...
    @typing.overload
    def interpolate(self, absoluteDate: 'AbsoluteDate', collection: typing.Union[java.util.Collection[_TimeInterpolator__T], typing.Sequence[_TimeInterpolator__T], typing.Set[_TimeInterpolator__T]]) -> _TimeInterpolator__T: ...
    @typing.overload
    def interpolate(self, absoluteDate: 'AbsoluteDate', stream: java.util.stream.Stream[_TimeInterpolator__T]) -> _TimeInterpolator__T: ...

class TimeScalarFunction:
    _value_1__T = typing.TypeVar('_value_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def value(self, absoluteDate: 'AbsoluteDate') -> float: ...
    @typing.overload
    def value(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_value_1__T]) -> _value_1__T: ...

class TimeScale(java.io.Serializable):
    _getLeap_1__T = typing.TypeVar('_getLeap_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def getLeap(self, absoluteDate: 'AbsoluteDate') -> float: ...
    @typing.overload
    def getLeap(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_getLeap_1__T]) -> _getLeap_1__T: ...
    def getName(self) -> str: ...
    _insideLeap_1__T = typing.TypeVar('_insideLeap_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def insideLeap(self, absoluteDate: 'AbsoluteDate') -> bool: ...
    @typing.overload
    def insideLeap(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_insideLeap_1__T]) -> bool: ...
    _minuteDuration_1__T = typing.TypeVar('_minuteDuration_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def minuteDuration(self, absoluteDate: 'AbsoluteDate') -> int: ...
    @typing.overload
    def minuteDuration(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_minuteDuration_1__T]) -> int: ...
    _offsetFromTAI_1__T = typing.TypeVar('_offsetFromTAI_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def offsetFromTAI(self, absoluteDate: 'AbsoluteDate') -> float: ...
    @typing.overload
    def offsetFromTAI(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_offsetFromTAI_1__T]) -> _offsetFromTAI_1__T: ...
    def offsetToTAI(self, dateComponents: DateComponents, timeComponents: TimeComponents) -> float: ...

class TimeScales:
    def createBesselianEpoch(self, double: float) -> 'AbsoluteDate': ...
    def createJulianEpoch(self, double: float) -> 'AbsoluteDate': ...
    def getBDT(self) -> 'BDTScale': ...
    def getBeidouEpoch(self) -> 'AbsoluteDate': ...
    def getCcsdsEpoch(self) -> 'AbsoluteDate': ...
    def getFiftiesEpoch(self) -> 'AbsoluteDate': ...
    def getFutureInfinity(self) -> 'AbsoluteDate': ...
    def getGLONASS(self) -> 'GLONASSScale': ...
    def getGMST(self, iERSConventions: org.orekit.utils.IERSConventions, boolean: bool) -> 'GMSTScale': ...
    def getGPS(self) -> 'GPSScale': ...
    def getGST(self) -> 'GalileoScale': ...
    def getGalileoEpoch(self) -> 'AbsoluteDate': ...
    def getGlonassEpoch(self) -> 'AbsoluteDate': ...
    def getGpsEpoch(self) -> 'AbsoluteDate': ...
    def getIRNSS(self) -> 'IRNSSScale': ...
    def getIrnssEpoch(self) -> 'AbsoluteDate': ...
    def getJ2000Epoch(self) -> 'AbsoluteDate': ...
    def getJavaEpoch(self) -> 'AbsoluteDate': ...
    def getJulianEpoch(self) -> 'AbsoluteDate': ...
    def getModifiedJulianEpoch(self) -> 'AbsoluteDate': ...
    def getPastInfinity(self) -> 'AbsoluteDate': ...
    def getQZSS(self) -> 'QZSSScale': ...
    def getQzssEpoch(self) -> 'AbsoluteDate': ...
    def getTAI(self) -> 'TAIScale': ...
    def getTCB(self) -> 'TCBScale': ...
    def getTCG(self) -> 'TCGScale': ...
    def getTDB(self) -> 'TDBScale': ...
    def getTT(self) -> 'TTScale': ...
    def getUT1(self, iERSConventions: org.orekit.utils.IERSConventions, boolean: bool) -> 'UT1Scale': ...
    def getUTC(self) -> 'UTCScale': ...
    @staticmethod
    def of(collection: typing.Union[java.util.Collection[OffsetModel], typing.Sequence[OffsetModel], typing.Set[OffsetModel]], biFunction: typing.Union[java.util.function.BiFunction[org.orekit.utils.IERSConventions, 'TimeScales', java.util.Collection[org.orekit.frames.EOPEntry]], typing.Callable[[org.orekit.utils.IERSConventions, 'TimeScales'], java.util.Collection[org.orekit.frames.EOPEntry]]]) -> 'TimeScales': ...

class TimeScalesFactory(java.io.Serializable):
    @staticmethod
    def addDefaultUTCTAIOffsetsLoaders() -> None: ...
    @staticmethod
    def addUTCTAIOffsetsLoader(uTCTAIOffsetsLoader: 'UTCTAIOffsetsLoader') -> None: ...
    @staticmethod
    def clearUTCTAIOffsetsLoaders() -> None: ...
    @staticmethod
    def getBDT() -> 'BDTScale': ...
    @staticmethod
    def getGLONASS() -> 'GLONASSScale': ...
    @staticmethod
    def getGMST(iERSConventions: org.orekit.utils.IERSConventions, boolean: bool) -> 'GMSTScale': ...
    @staticmethod
    def getGPS() -> 'GPSScale': ...
    @staticmethod
    def getGST() -> 'GalileoScale': ...
    @staticmethod
    def getIRNSS() -> 'IRNSSScale': ...
    @staticmethod
    def getQZSS() -> 'QZSSScale': ...
    @staticmethod
    def getTAI() -> 'TAIScale': ...
    @staticmethod
    def getTCB() -> 'TCBScale': ...
    @staticmethod
    def getTCG() -> 'TCGScale': ...
    @staticmethod
    def getTDB() -> 'TDBScale': ...
    @staticmethod
    def getTT() -> 'TTScale': ...
    @staticmethod
    def getTimeScales() -> 'LazyLoadedTimeScales': ...
    @typing.overload
    @staticmethod
    def getUT1(eOPHistory: org.orekit.frames.EOPHistory) -> 'UT1Scale': ...
    @typing.overload
    @staticmethod
    def getUT1(iERSConventions: org.orekit.utils.IERSConventions, boolean: bool) -> 'UT1Scale': ...
    @staticmethod
    def getUTC() -> 'UTCScale': ...

_TimeShiftable__T = typing.TypeVar('_TimeShiftable__T', bound='TimeShiftable')  # <T>
class TimeShiftable(typing.Generic[_TimeShiftable__T]):
    def shiftedBy(self, double: float) -> _TimeShiftable__T: ...

class TimeStamped:
    def durationFrom(self, timeStamped: 'TimeStamped') -> float: ...
    def getDate(self) -> 'AbsoluteDate': ...

class TimeVectorFunction:
    _value_1__T = typing.TypeVar('_value_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def value(self, absoluteDate: 'AbsoluteDate') -> typing.List[float]: ...
    @typing.overload
    def value(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_value_1__T]) -> typing.List[_value_1__T]: ...

class UTCTAIOffsetsLoader:
    def loadOffsets(self) -> java.util.List[OffsetModel]: ...
    class Parser:
        def parse(self, inputStream: java.io.InputStream, string: str) -> java.util.List[OffsetModel]: ...

class AGILeapSecondFilesLoader(org.orekit.data.AbstractSelfFeedingLoader, UTCTAIOffsetsLoader):
    DEFAULT_SUPPORTED_NAMES: typing.ClassVar[str] = ...
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, dataProvidersManager: org.orekit.data.DataProvidersManager): ...
    def loadOffsets(self) -> java.util.List[OffsetModel]: ...
    class Parser(UTCTAIOffsetsLoader.Parser):
        def __init__(self): ...
        def parse(self, inputStream: java.io.InputStream, string: str) -> java.util.List[OffsetModel]: ...

class AbsoluteDate(TimeStamped, TimeShiftable['AbsoluteDate'], java.lang.Comparable['AbsoluteDate'], java.io.Serializable):
    JULIAN_EPOCH: typing.ClassVar['AbsoluteDate'] = ...
    MODIFIED_JULIAN_EPOCH: typing.ClassVar['AbsoluteDate'] = ...
    FIFTIES_EPOCH: typing.ClassVar['AbsoluteDate'] = ...
    CCSDS_EPOCH: typing.ClassVar['AbsoluteDate'] = ...
    GALILEO_EPOCH: typing.ClassVar['AbsoluteDate'] = ...
    GPS_EPOCH: typing.ClassVar['AbsoluteDate'] = ...
    QZSS_EPOCH: typing.ClassVar['AbsoluteDate'] = ...
    IRNSS_EPOCH: typing.ClassVar['AbsoluteDate'] = ...
    BEIDOU_EPOCH: typing.ClassVar['AbsoluteDate'] = ...
    GLONASS_EPOCH: typing.ClassVar['AbsoluteDate'] = ...
    J2000_EPOCH: typing.ClassVar['AbsoluteDate'] = ...
    JAVA_EPOCH: typing.ClassVar['AbsoluteDate'] = ...
    ARBITRARY_EPOCH: typing.ClassVar['AbsoluteDate'] = ...
    PAST_INFINITY: typing.ClassVar['AbsoluteDate'] = ...
    FUTURE_INFINITY: typing.ClassVar['AbsoluteDate'] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int, int2: int, int3: int, int4: int, int5: int, double: float, timeScale: TimeScale): ...
    @typing.overload
    def __init__(self, int: int, int2: int, int3: int, timeScale: TimeScale): ...
    @typing.overload
    def __init__(self, int: int, month: Month, int2: int, int3: int, int4: int, double: float, timeScale: TimeScale): ...
    @typing.overload
    def __init__(self, int: int, month: Month, int2: int, timeScale: TimeScale): ...
    @typing.overload
    def __init__(self, string: str, timeScale: TimeScale): ...
    @typing.overload
    def __init__(self, instant: typing.Union[java.time.Instant, datetime.datetime]): ...
    @typing.overload
    def __init__(self, instant: typing.Union[java.time.Instant, datetime.datetime], timeScale: TimeScale): ...
    @typing.overload
    def __init__(self, instant: typing.Union[java.time.Instant, datetime.datetime], uTCScale: 'UTCScale'): ...
    @typing.overload
    def __init__(self, date: java.util.Date, timeScale: TimeScale): ...
    @typing.overload
    def __init__(self, absoluteDate: 'AbsoluteDate', double: float): ...
    @typing.overload
    def __init__(self, absoluteDate: 'AbsoluteDate', double: float, timeScale: TimeScale): ...
    @typing.overload
    def __init__(self, absoluteDate: 'AbsoluteDate', long: int, timeUnit: java.util.concurrent.TimeUnit): ...
    @typing.overload
    def __init__(self, dateComponents: DateComponents, timeComponents: TimeComponents, timeScale: TimeScale): ...
    @typing.overload
    def __init__(self, dateComponents: DateComponents, timeScale: TimeScale): ...
    @typing.overload
    def __init__(self, dateTimeComponents: DateTimeComponents, timeScale: TimeScale): ...
    def compareTo(self, absoluteDate: 'AbsoluteDate') -> int: ...
    @staticmethod
    def createBesselianEpoch(double: float) -> 'AbsoluteDate': ...
    @typing.overload
    @staticmethod
    def createJDDate(int: int, double: float, timeScale: TimeScale) -> 'AbsoluteDate': ...
    @typing.overload
    @staticmethod
    def createJDDate(int: int, double: float, timeScale: TimeScale, timeScale2: TimeScale) -> 'AbsoluteDate': ...
    @staticmethod
    def createJulianEpoch(double: float) -> 'AbsoluteDate': ...
    @staticmethod
    def createMJDDate(int: int, double: float, timeScale: TimeScale) -> 'AbsoluteDate': ...
    @typing.overload
    def durationFrom(self, timeStamped: TimeStamped) -> float: ...
    @typing.overload
    def durationFrom(self, absoluteDate: 'AbsoluteDate') -> float: ...
    @typing.overload
    def durationFrom(self, absoluteDate: 'AbsoluteDate', timeUnit: java.util.concurrent.TimeUnit) -> int: ...
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    def getComponents(self, int: int) -> DateTimeComponents: ...
    @typing.overload
    def getComponents(self, int: int, timeScale: TimeScale) -> DateTimeComponents: ...
    @typing.overload
    def getComponents(self, timeZone: java.util.TimeZone) -> DateTimeComponents: ...
    @typing.overload
    def getComponents(self, timeZone: java.util.TimeZone, timeScale: TimeScale) -> DateTimeComponents: ...
    @typing.overload
    def getComponents(self, timeScale: TimeScale) -> DateTimeComponents: ...
    def getDate(self) -> 'AbsoluteDate': ...
    def hashCode(self) -> int: ...
    def isAfter(self, timeStamped: TimeStamped) -> bool: ...
    def isAfterOrEqualTo(self, timeStamped: TimeStamped) -> bool: ...
    def isBefore(self, timeStamped: TimeStamped) -> bool: ...
    def isBeforeOrEqualTo(self, timeStamped: TimeStamped) -> bool: ...
    def isBetween(self, timeStamped: TimeStamped, timeStamped2: TimeStamped) -> bool: ...
    def isBetweenOrEqualTo(self, timeStamped: TimeStamped, timeStamped2: TimeStamped) -> bool: ...
    def isCloseTo(self, timeStamped: TimeStamped, double: float) -> bool: ...
    def isEqualTo(self, timeStamped: TimeStamped) -> bool: ...
    def offsetFrom(self, absoluteDate: 'AbsoluteDate', timeScale: TimeScale) -> float: ...
    @typing.overload
    @staticmethod
    def parseCCSDSCalendarSegmentedTimeCode(byte: int, byteArray: typing.List[int]) -> 'AbsoluteDate': ...
    @typing.overload
    @staticmethod
    def parseCCSDSCalendarSegmentedTimeCode(byte: int, byteArray: typing.List[int], timeScale: TimeScale) -> 'AbsoluteDate': ...
    @typing.overload
    @staticmethod
    def parseCCSDSDaySegmentedTimeCode(byte: int, byteArray: typing.List[int], dateComponents: DateComponents) -> 'AbsoluteDate': ...
    @typing.overload
    @staticmethod
    def parseCCSDSDaySegmentedTimeCode(byte: int, byteArray: typing.List[int], dateComponents: DateComponents, timeScale: TimeScale) -> 'AbsoluteDate': ...
    @typing.overload
    @staticmethod
    def parseCCSDSUnsegmentedTimeCode(byte: int, byte2: int, byteArray: typing.List[int], absoluteDate: 'AbsoluteDate') -> 'AbsoluteDate': ...
    @typing.overload
    @staticmethod
    def parseCCSDSUnsegmentedTimeCode(byte: int, byte2: int, byteArray: typing.List[int], absoluteDate: 'AbsoluteDate', absoluteDate2: 'AbsoluteDate') -> 'AbsoluteDate': ...
    @typing.overload
    def shiftedBy(self, double: float) -> 'AbsoluteDate': ...
    @typing.overload
    def shiftedBy(self, long: int, timeUnit: java.util.concurrent.TimeUnit) -> 'AbsoluteDate': ...
    def timeScalesOffset(self, timeScale: TimeScale, timeScale2: TimeScale) -> float: ...
    def toDate(self, timeScale: TimeScale) -> java.util.Date: ...
    @typing.overload
    def toInstant(self) -> java.time.Instant: ...
    @typing.overload
    def toInstant(self, timeScales: TimeScales) -> java.time.Instant: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    def toString(self, int: int) -> str: ...
    @typing.overload
    def toString(self, int: int, timeScale: TimeScale) -> str: ...
    @typing.overload
    def toString(self, timeZone: java.util.TimeZone) -> str: ...
    @typing.overload
    def toString(self, timeZone: java.util.TimeZone, timeScale: TimeScale) -> str: ...
    @typing.overload
    def toString(self, timeScale: TimeScale) -> str: ...
    def toStringRfc3339(self, timeScale: TimeScale) -> str: ...
    def toStringWithoutUtcOffset(self, timeScale: TimeScale, int: int) -> str: ...

_AbstractFieldTimeInterpolator__T = typing.TypeVar('_AbstractFieldTimeInterpolator__T', bound=FieldTimeStamped)  # <T>
_AbstractFieldTimeInterpolator__KK = typing.TypeVar('_AbstractFieldTimeInterpolator__KK', bound=org.hipparchus.CalculusFieldElement)  # <KK>
class AbstractFieldTimeInterpolator(FieldTimeInterpolator[_AbstractFieldTimeInterpolator__T, _AbstractFieldTimeInterpolator__KK], typing.Generic[_AbstractFieldTimeInterpolator__T, _AbstractFieldTimeInterpolator__KK]):
    DEFAULT_EXTRAPOLATION_THRESHOLD_SEC: typing.ClassVar[float] = ...
    DEFAULT_INTERPOLATION_POINTS: typing.ClassVar[int] = ...
    def __init__(self, int: int, double: float): ...
    _checkInterpolatorCompatibilityWithSampleSize__T = typing.TypeVar('_checkInterpolatorCompatibilityWithSampleSize__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @staticmethod
    def checkInterpolatorCompatibilityWithSampleSize(fieldTimeInterpolator: FieldTimeInterpolator[FieldTimeStamped[_checkInterpolatorCompatibilityWithSampleSize__T], _checkInterpolatorCompatibilityWithSampleSize__T], int: int) -> None: ...
    _getCentralDate_0__KK = typing.TypeVar('_getCentralDate_0__KK', bound=org.hipparchus.CalculusFieldElement)  # <KK>
    _getCentralDate_1__T = typing.TypeVar('_getCentralDate_1__T', bound=FieldTimeStamped)  # <T>
    _getCentralDate_1__KK = typing.TypeVar('_getCentralDate_1__KK', bound=org.hipparchus.CalculusFieldElement)  # <KK>
    @typing.overload
    @staticmethod
    def getCentralDate(fieldAbsoluteDate: 'FieldAbsoluteDate'[_getCentralDate_0__KK], fieldAbsoluteDate2: 'FieldAbsoluteDate'[_getCentralDate_0__KK], fieldAbsoluteDate3: 'FieldAbsoluteDate'[_getCentralDate_0__KK], double: float) -> 'FieldAbsoluteDate'[_getCentralDate_0__KK]: ...
    @typing.overload
    @staticmethod
    def getCentralDate(fieldAbsoluteDate: 'FieldAbsoluteDate'[_getCentralDate_1__KK], immutableFieldTimeStampedCache: org.orekit.utils.ImmutableFieldTimeStampedCache[_getCentralDate_1__T, _getCentralDate_1__KK], double: float) -> 'FieldAbsoluteDate'[_getCentralDate_1__KK]: ...
    def getExtrapolationThreshold(self) -> float: ...
    def getNbInterpolationPoints(self) -> int: ...
    def getSubInterpolators(self) -> java.util.List[FieldTimeInterpolator[FieldTimeStamped[_AbstractFieldTimeInterpolator__KK], _AbstractFieldTimeInterpolator__KK]]: ...
    @typing.overload
    def interpolate(self, absoluteDate: AbsoluteDate, collection: typing.Union[java.util.Collection[_AbstractFieldTimeInterpolator__T], typing.Sequence[_AbstractFieldTimeInterpolator__T], typing.Set[_AbstractFieldTimeInterpolator__T]]) -> _AbstractFieldTimeInterpolator__T: ...
    @typing.overload
    def interpolate(self, absoluteDate: AbsoluteDate, stream: java.util.stream.Stream[_AbstractFieldTimeInterpolator__T]) -> _AbstractFieldTimeInterpolator__T: ...
    @typing.overload
    def interpolate(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_AbstractFieldTimeInterpolator__KK], collection: typing.Union[java.util.Collection[_AbstractFieldTimeInterpolator__T], typing.Sequence[_AbstractFieldTimeInterpolator__T], typing.Set[_AbstractFieldTimeInterpolator__T]]) -> _AbstractFieldTimeInterpolator__T: ...
    @typing.overload
    def interpolate(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_AbstractFieldTimeInterpolator__KK], stream: java.util.stream.Stream[_AbstractFieldTimeInterpolator__T]) -> _AbstractFieldTimeInterpolator__T: ...
    class InterpolationData:
        def getCachedSamples(self) -> org.orekit.utils.ImmutableFieldTimeStampedCache[_AbstractFieldTimeInterpolator__T, _AbstractFieldTimeInterpolator__KK]: ...
        def getField(self) -> org.hipparchus.Field[_AbstractFieldTimeInterpolator__KK]: ...
        def getInterpolationDate(self) -> 'FieldAbsoluteDate'[_AbstractFieldTimeInterpolator__KK]: ...
        def getNeighborList(self) -> java.util.List[_AbstractFieldTimeInterpolator__T]: ...
        def getOne(self) -> _AbstractFieldTimeInterpolator__KK: ...
        def getZero(self) -> _AbstractFieldTimeInterpolator__KK: ...

_AbstractTimeInterpolator__T = typing.TypeVar('_AbstractTimeInterpolator__T', bound=TimeStamped)  # <T>
class AbstractTimeInterpolator(TimeInterpolator[_AbstractTimeInterpolator__T], typing.Generic[_AbstractTimeInterpolator__T]):
    DEFAULT_EXTRAPOLATION_THRESHOLD_SEC: typing.ClassVar[float] = ...
    DEFAULT_INTERPOLATION_POINTS: typing.ClassVar[int] = ...
    def __init__(self, int: int, double: float): ...
    @staticmethod
    def checkInterpolatorCompatibilityWithSampleSize(timeInterpolator: TimeInterpolator[TimeStamped], int: int) -> None: ...
    _getCentralDate_0__T = typing.TypeVar('_getCentralDate_0__T', bound=TimeStamped)  # <T>
    _getCentralDate_1__T = typing.TypeVar('_getCentralDate_1__T', bound=TimeStamped)  # <T>
    @typing.overload
    @staticmethod
    def getCentralDate(absoluteDate: AbsoluteDate, absoluteDate2: AbsoluteDate, absoluteDate3: AbsoluteDate, double: float) -> AbsoluteDate: ...
    @typing.overload
    @staticmethod
    def getCentralDate(absoluteDate: AbsoluteDate, immutableTimeStampedCache: org.orekit.utils.ImmutableTimeStampedCache[_getCentralDate_1__T], double: float) -> AbsoluteDate: ...
    def getExtrapolationThreshold(self) -> float: ...
    def getNbInterpolationPoints(self) -> int: ...
    def getSubInterpolators(self) -> java.util.List[TimeInterpolator[TimeStamped]]: ...
    @typing.overload
    def interpolate(self, absoluteDate: AbsoluteDate, collection: typing.Union[java.util.Collection[_AbstractTimeInterpolator__T], typing.Sequence[_AbstractTimeInterpolator__T], typing.Set[_AbstractTimeInterpolator__T]]) -> _AbstractTimeInterpolator__T: ...
    @typing.overload
    def interpolate(self, absoluteDate: AbsoluteDate, stream: java.util.stream.Stream[_AbstractTimeInterpolator__T]) -> _AbstractTimeInterpolator__T: ...
    class InterpolationData:
        def getCachedSamples(self) -> org.orekit.utils.ImmutableTimeStampedCache[_AbstractTimeInterpolator__T]: ...
        def getInterpolationDate(self) -> AbsoluteDate: ...
        def getNeighborList(self) -> java.util.List[_AbstractTimeInterpolator__T]: ...

class AbstractTimeScales(TimeScales):
    def __init__(self): ...
    def createBesselianEpoch(self, double: float) -> AbsoluteDate: ...
    def createJulianEpoch(self, double: float) -> AbsoluteDate: ...
    def getBeidouEpoch(self) -> AbsoluteDate: ...
    def getCcsdsEpoch(self) -> AbsoluteDate: ...
    def getFiftiesEpoch(self) -> AbsoluteDate: ...
    def getFutureInfinity(self) -> AbsoluteDate: ...
    def getGMST(self, iERSConventions: org.orekit.utils.IERSConventions, boolean: bool) -> 'GMSTScale': ...
    def getGalileoEpoch(self) -> AbsoluteDate: ...
    def getGlonassEpoch(self) -> AbsoluteDate: ...
    def getGpsEpoch(self) -> AbsoluteDate: ...
    def getIrnssEpoch(self) -> AbsoluteDate: ...
    def getJ2000Epoch(self) -> AbsoluteDate: ...
    def getJavaEpoch(self) -> AbsoluteDate: ...
    def getJulianEpoch(self) -> AbsoluteDate: ...
    def getModifiedJulianEpoch(self) -> AbsoluteDate: ...
    def getPastInfinity(self) -> AbsoluteDate: ...
    def getQzssEpoch(self) -> AbsoluteDate: ...
    def getUT1(self, iERSConventions: org.orekit.utils.IERSConventions, boolean: bool) -> 'UT1Scale': ...

class AggregatedClockModel(ClockModel):
    def __init__(self, timeSpanMap: org.orekit.utils.TimeSpanMap[ClockModel]): ...
    def getModels(self) -> org.orekit.utils.TimeSpanMap[ClockModel]: ...
    _getOffset_1__T = typing.TypeVar('_getOffset_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def getOffset(self, absoluteDate: AbsoluteDate) -> 'ClockOffset': ...
    @typing.overload
    def getOffset(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_getOffset_1__T]) -> 'FieldClockOffset'[_getOffset_1__T]: ...
    def getValidityEnd(self) -> AbsoluteDate: ...
    def getValidityStart(self) -> AbsoluteDate: ...

class BurstSelector(DatesSelector):
    def __init__(self, int: int, double: float, double2: float, timeScale: TimeScale): ...
    def selectDates(self, absoluteDate: AbsoluteDate, absoluteDate2: AbsoluteDate) -> java.util.List[AbsoluteDate]: ...

class ClockOffset(TimeStamped):
    def __init__(self, absoluteDate: AbsoluteDate, double: float, double2: float, double3: float): ...
    def getAcceleration(self) -> float: ...
    def getDate(self) -> AbsoluteDate: ...
    def getOffset(self) -> float: ...
    def getRate(self) -> float: ...

class ClockTimeScale(TimeScale):
    def __init__(self, string: str, timeScale: TimeScale, clockModel: ClockModel): ...
    def getName(self) -> str: ...
    _offsetFromTAI_1__T = typing.TypeVar('_offsetFromTAI_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def offsetFromTAI(self, absoluteDate: AbsoluteDate) -> float: ...
    @typing.overload
    def offsetFromTAI(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_offsetFromTAI_1__T]) -> _offsetFromTAI_1__T: ...

class ConstantOffsetTimeScale(TimeScale):
    def getName(self) -> str: ...
    _offsetFromTAI_1__T = typing.TypeVar('_offsetFromTAI_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def offsetFromTAI(self, absoluteDate: AbsoluteDate) -> float: ...
    @typing.overload
    def offsetFromTAI(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_offsetFromTAI_1__T]) -> _offsetFromTAI_1__T: ...
    def offsetToTAI(self, dateComponents: DateComponents, timeComponents: TimeComponents) -> float: ...
    def toString(self) -> str: ...

_FieldClockOffset__T = typing.TypeVar('_FieldClockOffset__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
class FieldClockOffset(FieldTimeStamped[_FieldClockOffset__T], typing.Generic[_FieldClockOffset__T]):
    def __init__(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_FieldClockOffset__T], t: _FieldClockOffset__T, t2: _FieldClockOffset__T, t3: _FieldClockOffset__T): ...
    def getAcceleration(self) -> _FieldClockOffset__T: ...
    def getDate(self) -> 'FieldAbsoluteDate'[_FieldClockOffset__T]: ...
    def getOffset(self) -> _FieldClockOffset__T: ...
    def getRate(self) -> _FieldClockOffset__T: ...

_FieldTimeShiftable__T = typing.TypeVar('_FieldTimeShiftable__T', bound='FieldTimeShiftable')  # <T>
_FieldTimeShiftable__KK = typing.TypeVar('_FieldTimeShiftable__KK', bound=org.hipparchus.CalculusFieldElement)  # <KK>
class FieldTimeShiftable(TimeShiftable[_FieldTimeShiftable__T], typing.Generic[_FieldTimeShiftable__T, _FieldTimeShiftable__KK]):
    @typing.overload
    def shiftedBy(self, kK: _FieldTimeShiftable__KK) -> _FieldTimeShiftable__T: ...
    @typing.overload
    def shiftedBy(self, double: float) -> _FieldTimeShiftable__T: ...

_FieldTimeStampedPair__F = typing.TypeVar('_FieldTimeStampedPair__F', bound=FieldTimeStamped)  # <F>
_FieldTimeStampedPair__S = typing.TypeVar('_FieldTimeStampedPair__S', bound=FieldTimeStamped)  # <S>
_FieldTimeStampedPair__KK = typing.TypeVar('_FieldTimeStampedPair__KK', bound=org.hipparchus.CalculusFieldElement)  # <KK>
class FieldTimeStampedPair(FieldTimeStamped[_FieldTimeStampedPair__KK], typing.Generic[_FieldTimeStampedPair__F, _FieldTimeStampedPair__S, _FieldTimeStampedPair__KK]):
    DEFAULT_DATE_EQUALITY_THRESHOLD: typing.ClassVar[float] = ...
    @typing.overload
    def __init__(self, f: _FieldTimeStampedPair__F, s2: _FieldTimeStampedPair__S): ...
    @typing.overload
    def __init__(self, f: _FieldTimeStampedPair__F, s2: _FieldTimeStampedPair__S, double: float): ...
    def getDate(self) -> 'FieldAbsoluteDate'[_FieldTimeStampedPair__KK]: ...
    def getFirst(self) -> _FieldTimeStampedPair__F: ...
    def getSecond(self) -> _FieldTimeStampedPair__S: ...

class FixedStepSelector(DatesSelector):
    def __init__(self, double: float, timeScale: TimeScale): ...
    def selectDates(self, absoluteDate: AbsoluteDate, absoluteDate2: AbsoluteDate) -> java.util.List[AbsoluteDate]: ...

class GLONASSDate(java.io.Serializable, TimeStamped):
    @typing.overload
    def __init__(self, int: int, int2: int, double: float): ...
    @typing.overload
    def __init__(self, int: int, int2: int, double: float, timeScale: TimeScale): ...
    @typing.overload
    def __init__(self, absoluteDate: AbsoluteDate): ...
    @typing.overload
    def __init__(self, absoluteDate: AbsoluteDate, timeScale: TimeScale): ...
    def getDate(self) -> AbsoluteDate: ...
    def getDayNumber(self) -> int: ...
    def getGMST(self) -> float: ...
    def getIntervalNumber(self) -> int: ...
    def getJD0(self) -> float: ...
    def getSecInDay(self) -> float: ...

class GLONASSScale(TimeScale):
    _getLeap_1__T = typing.TypeVar('_getLeap_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def getLeap(self, absoluteDate: AbsoluteDate) -> float: ...
    @typing.overload
    def getLeap(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_getLeap_1__T]) -> _getLeap_1__T: ...
    def getName(self) -> str: ...
    _insideLeap_1__T = typing.TypeVar('_insideLeap_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def insideLeap(self, absoluteDate: AbsoluteDate) -> bool: ...
    @typing.overload
    def insideLeap(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_insideLeap_1__T]) -> bool: ...
    _minuteDuration_1__T = typing.TypeVar('_minuteDuration_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def minuteDuration(self, absoluteDate: AbsoluteDate) -> int: ...
    @typing.overload
    def minuteDuration(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_minuteDuration_1__T]) -> int: ...
    _offsetFromTAI_1__T = typing.TypeVar('_offsetFromTAI_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def offsetFromTAI(self, absoluteDate: AbsoluteDate) -> float: ...
    @typing.overload
    def offsetFromTAI(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_offsetFromTAI_1__T]) -> _offsetFromTAI_1__T: ...
    def offsetToTAI(self, dateComponents: DateComponents, timeComponents: TimeComponents) -> float: ...
    def toString(self) -> str: ...

class GMSTScale(TimeScale):
    def getName(self) -> str: ...
    _offsetFromTAI_1__T = typing.TypeVar('_offsetFromTAI_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def offsetFromTAI(self, absoluteDate: AbsoluteDate) -> float: ...
    @typing.overload
    def offsetFromTAI(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_offsetFromTAI_1__T]) -> _offsetFromTAI_1__T: ...
    def toString(self) -> str: ...

class GNSSDate(java.io.Serializable, TimeStamped):
    @typing.overload
    def __init__(self, int: int, double: float, satelliteSystem: org.orekit.gnss.SatelliteSystem): ...
    @typing.overload
    def __init__(self, int: int, double: float, satelliteSystem: org.orekit.gnss.SatelliteSystem, dateComponents: DateComponents, timeScales: TimeScales): ...
    @typing.overload
    def __init__(self, int: int, double: float, satelliteSystem: org.orekit.gnss.SatelliteSystem, timeScales: TimeScales): ...
    @typing.overload
    def __init__(self, absoluteDate: AbsoluteDate, satelliteSystem: org.orekit.gnss.SatelliteSystem): ...
    @typing.overload
    def __init__(self, absoluteDate: AbsoluteDate, satelliteSystem: org.orekit.gnss.SatelliteSystem, timeScales: TimeScales): ...
    def getDate(self) -> AbsoluteDate: ...
    def getMilliInWeek(self) -> float: ...
    @staticmethod
    def getRolloverReference() -> DateComponents: ...
    def getSecondsInWeek(self) -> float: ...
    def getWeekNumber(self) -> int: ...
    @staticmethod
    def setRolloverReference(dateComponents: DateComponents) -> None: ...

class PerfectClockModel(ClockModel):
    def __init__(self): ...
    _getOffset_1__T = typing.TypeVar('_getOffset_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def getOffset(self, absoluteDate: AbsoluteDate) -> ClockOffset: ...
    @typing.overload
    def getOffset(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_getOffset_1__T]) -> FieldClockOffset[_getOffset_1__T]: ...
    def getValidityEnd(self) -> AbsoluteDate: ...
    def getValidityStart(self) -> AbsoluteDate: ...

class PythonClockModel(ClockModel):
    def __init__(self): ...
    def finalize(self) -> None: ...
    _getOffset_1__T = typing.TypeVar('_getOffset_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def getOffset(self, absoluteDate: AbsoluteDate) -> ClockOffset: ...
    @typing.overload
    def getOffset(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_getOffset_1__T]) -> FieldClockOffset[_getOffset_1__T]: ...
    def getValidityEnd(self) -> AbsoluteDate: ...
    def getValidityStart(self) -> AbsoluteDate: ...
    def pythonDecRef(self) -> None: ...
    @typing.overload
    def pythonExtension(self) -> int: ...
    @typing.overload
    def pythonExtension(self, long: int) -> None: ...

class PythonDatesSelector(DatesSelector):
    def __init__(self): ...
    def finalize(self) -> None: ...
    def pythonDecRef(self) -> None: ...
    @typing.overload
    def pythonExtension(self) -> int: ...
    @typing.overload
    def pythonExtension(self, long: int) -> None: ...
    def selectDates(self, absoluteDate: AbsoluteDate, absoluteDate2: AbsoluteDate) -> java.util.List[AbsoluteDate]: ...

_PythonFieldTimeInterpolator__T = typing.TypeVar('_PythonFieldTimeInterpolator__T', bound=FieldTimeInterpolator)  # <T>
_PythonFieldTimeInterpolator__KK = typing.TypeVar('_PythonFieldTimeInterpolator__KK', bound=org.hipparchus.CalculusFieldElement)  # <KK>
class PythonFieldTimeInterpolator(FieldTimeInterpolator[_PythonFieldTimeInterpolator__T, _PythonFieldTimeInterpolator__KK], typing.Generic[_PythonFieldTimeInterpolator__T, _PythonFieldTimeInterpolator__KK]):
    def __init__(self): ...
    def finalize(self) -> None: ...
    def getExtrapolationThreshold(self) -> float: ...
    def getNbInterpolationPoints(self) -> int: ...
    def getSubInterpolators(self) -> java.util.List[FieldTimeInterpolator[FieldTimeStamped[_PythonFieldTimeInterpolator__KK], _PythonFieldTimeInterpolator__KK]]: ...
    @typing.overload
    def interpolate(self, absoluteDate: AbsoluteDate, collection: typing.Union[java.util.Collection[_PythonFieldTimeInterpolator__T], typing.Sequence[_PythonFieldTimeInterpolator__T], typing.Set[_PythonFieldTimeInterpolator__T]]) -> _PythonFieldTimeInterpolator__T: ...
    @typing.overload
    def interpolate(self, absoluteDate: AbsoluteDate, stream: java.util.stream.Stream[_PythonFieldTimeInterpolator__T]) -> _PythonFieldTimeInterpolator__T: ...
    @typing.overload
    def interpolate(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_PythonFieldTimeInterpolator__KK], collection: typing.Union[java.util.Collection[_PythonFieldTimeInterpolator__T], typing.Sequence[_PythonFieldTimeInterpolator__T], typing.Set[_PythonFieldTimeInterpolator__T]]) -> _PythonFieldTimeInterpolator__T: ...
    @typing.overload
    def interpolate(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_PythonFieldTimeInterpolator__KK], stream: java.util.stream.Stream[_PythonFieldTimeInterpolator__T]) -> _PythonFieldTimeInterpolator__T: ...
    def pythonDecRef(self) -> None: ...
    @typing.overload
    def pythonExtension(self) -> int: ...
    @typing.overload
    def pythonExtension(self, long: int) -> None: ...

_PythonFieldTimeStamped__T = typing.TypeVar('_PythonFieldTimeStamped__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
class PythonFieldTimeStamped(FieldTimeStamped[_PythonFieldTimeStamped__T], typing.Generic[_PythonFieldTimeStamped__T]):
    def __init__(self): ...
    def finalize(self) -> None: ...
    def getDate(self) -> 'FieldAbsoluteDate'[_PythonFieldTimeStamped__T]: ...
    def pythonDecRef(self) -> None: ...
    @typing.overload
    def pythonExtension(self) -> int: ...
    @typing.overload
    def pythonExtension(self, long: int) -> None: ...

class PythonParser(UTCTAIOffsetsLoader.Parser):
    def __init__(self): ...
    def finalize(self) -> None: ...
    def parse(self, inputStream: java.io.InputStream, string: str) -> java.util.List[OffsetModel]: ...
    def pythonDecRef(self) -> None: ...
    @typing.overload
    def pythonExtension(self) -> int: ...
    @typing.overload
    def pythonExtension(self, long: int) -> None: ...

_PythonTimeInterpolator__T = typing.TypeVar('_PythonTimeInterpolator__T', bound=TimeInterpolator)  # <T>
class PythonTimeInterpolator(TimeInterpolator[_PythonTimeInterpolator__T], typing.Generic[_PythonTimeInterpolator__T]):
    def __init__(self): ...
    def finalize(self) -> None: ...
    def getExtrapolationThreshold(self) -> float: ...
    def getNbInterpolationPoints(self) -> int: ...
    def getSubInterpolators(self) -> java.util.List[TimeInterpolator[TimeStamped]]: ...
    @typing.overload
    def interpolate(self, absoluteDate: AbsoluteDate, collection: typing.Union[java.util.Collection[_PythonTimeInterpolator__T], typing.Sequence[_PythonTimeInterpolator__T], typing.Set[_PythonTimeInterpolator__T]]) -> _PythonTimeInterpolator__T: ...
    @typing.overload
    def interpolate(self, absoluteDate: AbsoluteDate, stream: java.util.stream.Stream[_PythonTimeInterpolator__T]) -> _PythonTimeInterpolator__T: ...
    def pythonDecRef(self) -> None: ...
    @typing.overload
    def pythonExtension(self) -> int: ...
    @typing.overload
    def pythonExtension(self, long: int) -> None: ...

class PythonTimeScalarFunction(TimeScalarFunction):
    def __init__(self): ...
    def finalize(self) -> None: ...
    def pythonDecRef(self) -> None: ...
    @typing.overload
    def pythonExtension(self) -> int: ...
    @typing.overload
    def pythonExtension(self, long: int) -> None: ...
    _value_1__T = typing.TypeVar('_value_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def value(self, absoluteDate: AbsoluteDate) -> float: ...
    @typing.overload
    def value(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_value_1__T]) -> _value_1__T: ...

class PythonTimeScale(TimeScale):
    def __init__(self): ...
    def finalize(self) -> None: ...
    def getName(self) -> str: ...
    _offsetFromTAI_1__T = typing.TypeVar('_offsetFromTAI_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def offsetFromTAI(self, absoluteDate: AbsoluteDate) -> float: ...
    @typing.overload
    def offsetFromTAI(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_offsetFromTAI_1__T]) -> _offsetFromTAI_1__T: ...
    def pythonDecRef(self) -> None: ...
    @typing.overload
    def pythonExtension(self) -> int: ...
    @typing.overload
    def pythonExtension(self, long: int) -> None: ...

class PythonTimeScales(TimeScales):
    def __init__(self): ...
    def createBesselianEpoch(self, double: float) -> AbsoluteDate: ...
    def createJulianEpoch(self, double: float) -> AbsoluteDate: ...
    def finalize(self) -> None: ...
    def getBDT(self) -> 'BDTScale': ...
    def getBeidouEpoch(self) -> AbsoluteDate: ...
    def getCcsdsEpoch(self) -> AbsoluteDate: ...
    def getFiftiesEpoch(self) -> AbsoluteDate: ...
    def getFutureInfinity(self) -> AbsoluteDate: ...
    def getGLONASS(self) -> GLONASSScale: ...
    def getGMST(self, iERSConventions: org.orekit.utils.IERSConventions, boolean: bool) -> GMSTScale: ...
    def getGPS(self) -> 'GPSScale': ...
    def getGST(self) -> 'GalileoScale': ...
    def getGalileoEpoch(self) -> AbsoluteDate: ...
    def getGlonassEpoch(self) -> AbsoluteDate: ...
    def getGpsEpoch(self) -> AbsoluteDate: ...
    def getIRNSS(self) -> 'IRNSSScale': ...
    def getIrnssEpoch(self) -> AbsoluteDate: ...
    def getJ2000Epoch(self) -> AbsoluteDate: ...
    def getJavaEpoch(self) -> AbsoluteDate: ...
    def getJulianEpoch(self) -> AbsoluteDate: ...
    def getModifiedJulianEpoch(self) -> AbsoluteDate: ...
    def getPastInfinity(self) -> AbsoluteDate: ...
    def getQZSS(self) -> 'QZSSScale': ...
    def getQzssEpoch(self) -> AbsoluteDate: ...
    def getTAI(self) -> 'TAIScale': ...
    def getTCB(self) -> 'TCBScale': ...
    def getTCG(self) -> 'TCGScale': ...
    def getTDB(self) -> 'TDBScale': ...
    def getTT(self) -> 'TTScale': ...
    def getUT1(self, iERSConventions: org.orekit.utils.IERSConventions, boolean: bool) -> 'UT1Scale': ...
    def getUTC(self) -> 'UTCScale': ...
    def pythonDecRef(self) -> None: ...
    @typing.overload
    def pythonExtension(self) -> int: ...
    @typing.overload
    def pythonExtension(self, long: int) -> None: ...

_PythonTimeShiftable__T = typing.TypeVar('_PythonTimeShiftable__T', bound=TimeShiftable)  # <T>
class PythonTimeShiftable(TimeShiftable[_PythonTimeShiftable__T], typing.Generic[_PythonTimeShiftable__T]):
    def __init__(self): ...
    def finalize(self) -> None: ...
    def pythonDecRef(self) -> None: ...
    @typing.overload
    def pythonExtension(self) -> int: ...
    @typing.overload
    def pythonExtension(self, long: int) -> None: ...
    def shiftedBy(self, double: float) -> _PythonTimeShiftable__T: ...

class PythonTimeStamped(TimeStamped):
    def __init__(self): ...
    def finalize(self) -> None: ...
    def getDate(self) -> AbsoluteDate: ...
    def pythonDecRef(self) -> None: ...
    @typing.overload
    def pythonExtension(self) -> int: ...
    @typing.overload
    def pythonExtension(self, long: int) -> None: ...

class PythonTimeVectorFunction(TimeVectorFunction):
    def __init__(self): ...
    def finalize(self) -> None: ...
    def pythonDecRef(self) -> None: ...
    @typing.overload
    def pythonExtension(self) -> int: ...
    @typing.overload
    def pythonExtension(self, long: int) -> None: ...
    _value_1__T = typing.TypeVar('_value_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def value(self, absoluteDate: AbsoluteDate) -> typing.List[float]: ...
    @typing.overload
    def value(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_value_1__T]) -> typing.List[_value_1__T]: ...

class PythonUTCTAIOffsetsLoader(UTCTAIOffsetsLoader):
    def __init__(self): ...
    def finalize(self) -> None: ...
    def loadOffsets(self) -> java.util.List[OffsetModel]: ...
    def pythonDecRef(self) -> None: ...
    @typing.overload
    def pythonExtension(self) -> int: ...
    @typing.overload
    def pythonExtension(self, long: int) -> None: ...

class SampledClockModel(ClockModel):
    def __init__(self, list: java.util.List[ClockOffset], int: int): ...
    def getCache(self) -> org.orekit.utils.ImmutableTimeStampedCache[ClockOffset]: ...
    _getOffset_1__T = typing.TypeVar('_getOffset_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def getOffset(self, absoluteDate: AbsoluteDate) -> ClockOffset: ...
    @typing.overload
    def getOffset(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_getOffset_1__T]) -> FieldClockOffset[_getOffset_1__T]: ...
    def getValidityEnd(self) -> AbsoluteDate: ...
    def getValidityStart(self) -> AbsoluteDate: ...

class SatelliteClockScale(TimeScale):
    def __init__(self, string: str, absoluteDate: AbsoluteDate, timeScale: TimeScale, double: float, double2: float): ...
    def countAtDate(self, absoluteDate: AbsoluteDate) -> float: ...
    def dateAtCount(self, double: float) -> AbsoluteDate: ...
    def getName(self) -> str: ...
    _offsetFromTAI_1__T = typing.TypeVar('_offsetFromTAI_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def offsetFromTAI(self, absoluteDate: AbsoluteDate) -> float: ...
    @typing.overload
    def offsetFromTAI(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_offsetFromTAI_1__T]) -> _offsetFromTAI_1__T: ...
    def offsetToTAI(self, dateComponents: DateComponents, timeComponents: TimeComponents) -> float: ...
    def toString(self) -> str: ...

class TAIUTCDatFilesLoader(org.orekit.data.AbstractSelfFeedingLoader, UTCTAIOffsetsLoader):
    DEFAULT_SUPPORTED_NAMES: typing.ClassVar[str] = ...
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, dataProvidersManager: org.orekit.data.DataProvidersManager): ...
    def loadOffsets(self) -> java.util.List[OffsetModel]: ...
    class Parser(UTCTAIOffsetsLoader.Parser):
        def __init__(self): ...
        def parse(self, inputStream: java.io.InputStream, string: str) -> java.util.List[OffsetModel]: ...

class TCBScale(TimeScale):
    def getName(self) -> str: ...
    _offsetFromTAI_1__T = typing.TypeVar('_offsetFromTAI_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def offsetFromTAI(self, absoluteDate: AbsoluteDate) -> float: ...
    @typing.overload
    def offsetFromTAI(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_offsetFromTAI_1__T]) -> _offsetFromTAI_1__T: ...
    def toString(self) -> str: ...

class TCGScale(TimeScale):
    def getName(self) -> str: ...
    _offsetFromTAI_1__T = typing.TypeVar('_offsetFromTAI_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def offsetFromTAI(self, absoluteDate: AbsoluteDate) -> float: ...
    @typing.overload
    def offsetFromTAI(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_offsetFromTAI_1__T]) -> _offsetFromTAI_1__T: ...
    def toString(self) -> str: ...

class TDBScale(TimeScale):
    def getName(self) -> str: ...
    _offsetFromTAI_1__T = typing.TypeVar('_offsetFromTAI_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def offsetFromTAI(self, absoluteDate: AbsoluteDate) -> float: ...
    @typing.overload
    def offsetFromTAI(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_offsetFromTAI_1__T]) -> _offsetFromTAI_1__T: ...
    def toString(self) -> str: ...

class TimeStampedDouble(TimeStamped):
    def __init__(self, double: float, absoluteDate: AbsoluteDate): ...
    def getDate(self) -> AbsoluteDate: ...
    def getValue(self) -> float: ...

_TimeStampedField__KK = typing.TypeVar('_TimeStampedField__KK', bound=org.hipparchus.CalculusFieldElement)  # <KK>
class TimeStampedField(FieldTimeStamped[_TimeStampedField__KK], typing.Generic[_TimeStampedField__KK]):
    @typing.overload
    def __init__(self, kK: _TimeStampedField__KK, absoluteDate: AbsoluteDate): ...
    @typing.overload
    def __init__(self, kK: _TimeStampedField__KK, fieldAbsoluteDate: 'FieldAbsoluteDate'[_TimeStampedField__KK]): ...
    def getDate(self) -> 'FieldAbsoluteDate'[_TimeStampedField__KK]: ...
    def getValue(self) -> _TimeStampedField__KK: ...

_TimeStampedPair__K = typing.TypeVar('_TimeStampedPair__K', bound=TimeStamped)  # <K>
_TimeStampedPair__V = typing.TypeVar('_TimeStampedPair__V', bound=TimeStamped)  # <V>
class TimeStampedPair(TimeStamped, typing.Generic[_TimeStampedPair__K, _TimeStampedPair__V]):
    DEFAULT_DATE_EQUALITY_THRESHOLD: typing.ClassVar[float] = ...
    @typing.overload
    def __init__(self, k: _TimeStampedPair__K, v: _TimeStampedPair__V): ...
    @typing.overload
    def __init__(self, k: _TimeStampedPair__K, v: _TimeStampedPair__V, double: float): ...
    @staticmethod
    def checkDatesConsistency(absoluteDate: AbsoluteDate, absoluteDate2: AbsoluteDate, double: float) -> None: ...
    def getDate(self) -> AbsoluteDate: ...
    def getFirst(self) -> _TimeStampedPair__K: ...
    def getSecond(self) -> _TimeStampedPair__V: ...

class UT1Scale(TimeScale):
    def getEOPHistory(self) -> org.orekit.frames.EOPHistory: ...
    def getName(self) -> str: ...
    def getUTCScale(self) -> 'UTCScale': ...
    _offsetFromTAI_1__T = typing.TypeVar('_offsetFromTAI_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def offsetFromTAI(self, absoluteDate: AbsoluteDate) -> float: ...
    @typing.overload
    def offsetFromTAI(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_offsetFromTAI_1__T]) -> _offsetFromTAI_1__T: ...
    def toString(self) -> str: ...

class UTCScale(TimeScale):
    def getBaseOffsets(self) -> java.util.Collection[OffsetModel]: ...
    def getFirstKnownLeapSecond(self) -> AbsoluteDate: ...
    def getLastKnownLeapSecond(self) -> AbsoluteDate: ...
    _getLeap_1__T = typing.TypeVar('_getLeap_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def getLeap(self, absoluteDate: AbsoluteDate) -> float: ...
    @typing.overload
    def getLeap(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_getLeap_1__T]) -> _getLeap_1__T: ...
    def getName(self) -> str: ...
    def getUTCTAIOffsets(self) -> java.util.List['UTCTAIOffset']: ...
    _insideLeap_1__T = typing.TypeVar('_insideLeap_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def insideLeap(self, absoluteDate: AbsoluteDate) -> bool: ...
    @typing.overload
    def insideLeap(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_insideLeap_1__T]) -> bool: ...
    _minuteDuration_1__T = typing.TypeVar('_minuteDuration_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def minuteDuration(self, absoluteDate: AbsoluteDate) -> int: ...
    @typing.overload
    def minuteDuration(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_minuteDuration_1__T]) -> int: ...
    _offsetFromTAI_1__T = typing.TypeVar('_offsetFromTAI_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def offsetFromTAI(self, absoluteDate: AbsoluteDate) -> float: ...
    @typing.overload
    def offsetFromTAI(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_offsetFromTAI_1__T]) -> _offsetFromTAI_1__T: ...
    def offsetToTAI(self, dateComponents: DateComponents, timeComponents: TimeComponents) -> float: ...
    def toString(self) -> str: ...

class UTCTAIBulletinAFilesLoader(org.orekit.data.AbstractSelfFeedingLoader, UTCTAIOffsetsLoader):
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, dataProvidersManager: org.orekit.data.DataProvidersManager): ...
    def loadOffsets(self) -> java.util.List[OffsetModel]: ...

class UTCTAIHistoryFilesLoader(org.orekit.data.AbstractSelfFeedingLoader, UTCTAIOffsetsLoader):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, dataProvidersManager: org.orekit.data.DataProvidersManager): ...
    def loadOffsets(self) -> java.util.List[OffsetModel]: ...
    class Parser(UTCTAIOffsetsLoader.Parser):
        def __init__(self): ...
        def parse(self, inputStream: java.io.InputStream, string: str) -> java.util.List[OffsetModel]: ...

class UTCTAIOffset(TimeStamped, java.io.Serializable):
    def getDate(self) -> AbsoluteDate: ...
    def getLeap(self) -> float: ...
    def getMJD(self) -> int: ...
    _getOffset_2__T = typing.TypeVar('_getOffset_2__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    def getOffset(self, absoluteDate: AbsoluteDate) -> float: ...
    @typing.overload
    def getOffset(self, dateComponents: DateComponents, timeComponents: TimeComponents) -> float: ...
    @typing.overload
    def getOffset(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_getOffset_2__T]) -> _getOffset_2__T: ...
    def getValidityStart(self) -> AbsoluteDate: ...

class BDTScale(ConstantOffsetTimeScale): ...

class ClockOffsetHermiteInterpolator(AbstractTimeInterpolator[ClockOffset]):
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, double: float): ...

_FieldAbsoluteDate__T = typing.TypeVar('_FieldAbsoluteDate__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
class FieldAbsoluteDate(FieldTimeStamped[_FieldAbsoluteDate__T], FieldTimeShiftable['FieldAbsoluteDate'[_FieldAbsoluteDate__T], _FieldAbsoluteDate__T], java.lang.Comparable['FieldAbsoluteDate'[_FieldAbsoluteDate__T]], typing.Generic[_FieldAbsoluteDate__T]):
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_FieldAbsoluteDate__T]): ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_FieldAbsoluteDate__T], int: int, int2: int, int3: int, int4: int, int5: int, double: float, timeScale: TimeScale): ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_FieldAbsoluteDate__T], int: int, int2: int, int3: int, timeScale: TimeScale): ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_FieldAbsoluteDate__T], int: int, month: Month, int2: int, int3: int, int4: int, double: float, timeScale: TimeScale): ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_FieldAbsoluteDate__T], int: int, month: Month, int2: int, timeScale: TimeScale): ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_FieldAbsoluteDate__T], string: str, timeScale: TimeScale): ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_FieldAbsoluteDate__T], instant: typing.Union[java.time.Instant, datetime.datetime]): ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_FieldAbsoluteDate__T], instant: typing.Union[java.time.Instant, datetime.datetime], timeScale: TimeScale): ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_FieldAbsoluteDate__T], instant: typing.Union[java.time.Instant, datetime.datetime], uTCScale: UTCScale): ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_FieldAbsoluteDate__T], date: java.util.Date, timeScale: TimeScale): ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_FieldAbsoluteDate__T], absoluteDate: AbsoluteDate): ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_FieldAbsoluteDate__T], dateComponents: DateComponents, timeComponents: TimeComponents, timeScale: TimeScale): ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_FieldAbsoluteDate__T], dateComponents: DateComponents, timeScale: TimeScale): ...
    @typing.overload
    def __init__(self, field: org.hipparchus.Field[_FieldAbsoluteDate__T], dateTimeComponents: DateTimeComponents, timeScale: TimeScale): ...
    @typing.overload
    def __init__(self, absoluteDate: AbsoluteDate, long: int, timeUnit: java.util.concurrent.TimeUnit, field: org.hipparchus.Field[_FieldAbsoluteDate__T]): ...
    @typing.overload
    def __init__(self, absoluteDate: AbsoluteDate, t: _FieldAbsoluteDate__T): ...
    @typing.overload
    def __init__(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_FieldAbsoluteDate__T], double: float): ...
    @typing.overload
    def __init__(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_FieldAbsoluteDate__T], double: float, timeScale: TimeScale): ...
    @typing.overload
    def __init__(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_FieldAbsoluteDate__T], long: int, timeUnit: java.util.concurrent.TimeUnit): ...
    @typing.overload
    def __init__(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_FieldAbsoluteDate__T], t: _FieldAbsoluteDate__T): ...
    def compareTo(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_FieldAbsoluteDate__T]) -> int: ...
    _createBesselianEpoch_0__T = typing.TypeVar('_createBesselianEpoch_0__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _createBesselianEpoch_1__T = typing.TypeVar('_createBesselianEpoch_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def createBesselianEpoch(t: _createBesselianEpoch_0__T) -> 'FieldAbsoluteDate'[_createBesselianEpoch_0__T]: ...
    @typing.overload
    @staticmethod
    def createBesselianEpoch(t: _createBesselianEpoch_1__T, timeScales: TimeScales) -> 'FieldAbsoluteDate'[_createBesselianEpoch_1__T]: ...
    _createGPSDate_0__T = typing.TypeVar('_createGPSDate_0__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _createGPSDate_1__T = typing.TypeVar('_createGPSDate_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def createGPSDate(int: int, t: _createGPSDate_0__T) -> 'FieldAbsoluteDate'[_createGPSDate_0__T]: ...
    @typing.overload
    @staticmethod
    def createGPSDate(int: int, t: _createGPSDate_1__T, timeScale: TimeScale) -> 'FieldAbsoluteDate'[_createGPSDate_1__T]: ...
    _createJDDate_0__T = typing.TypeVar('_createJDDate_0__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _createJDDate_1__T = typing.TypeVar('_createJDDate_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def createJDDate(int: int, t: _createJDDate_0__T, timeScale: TimeScale) -> 'FieldAbsoluteDate'[_createJDDate_0__T]: ...
    @typing.overload
    @staticmethod
    def createJDDate(int: int, t: _createJDDate_1__T, timeScale: TimeScale, timeScale2: TimeScale) -> 'FieldAbsoluteDate'[_createJDDate_1__T]: ...
    _createJulianEpoch_0__T = typing.TypeVar('_createJulianEpoch_0__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _createJulianEpoch_1__T = typing.TypeVar('_createJulianEpoch_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def createJulianEpoch(t: _createJulianEpoch_0__T) -> 'FieldAbsoluteDate'[_createJulianEpoch_0__T]: ...
    @typing.overload
    @staticmethod
    def createJulianEpoch(t: _createJulianEpoch_1__T, timeScales: TimeScales) -> 'FieldAbsoluteDate'[_createJulianEpoch_1__T]: ...
    _createMJDDate__T = typing.TypeVar('_createMJDDate__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @staticmethod
    def createMJDDate(int: int, t: _createMJDDate__T, timeScale: TimeScale) -> 'FieldAbsoluteDate'[_createMJDDate__T]: ...
    @typing.overload
    def durationFrom(self, fieldTimeStamped: FieldTimeStamped[_FieldAbsoluteDate__T]) -> _FieldAbsoluteDate__T: ...
    @typing.overload
    def durationFrom(self, absoluteDate: AbsoluteDate) -> _FieldAbsoluteDate__T: ...
    @typing.overload
    def durationFrom(self, absoluteDate: AbsoluteDate, timeUnit: java.util.concurrent.TimeUnit) -> _FieldAbsoluteDate__T: ...
    @typing.overload
    def durationFrom(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_FieldAbsoluteDate__T]) -> _FieldAbsoluteDate__T: ...
    @typing.overload
    def durationFrom(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_FieldAbsoluteDate__T], timeUnit: java.util.concurrent.TimeUnit) -> _FieldAbsoluteDate__T: ...
    def equals(self, object: typing.Any) -> bool: ...
    _getArbitraryEpoch__T = typing.TypeVar('_getArbitraryEpoch__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @staticmethod
    def getArbitraryEpoch(field: org.hipparchus.Field[_getArbitraryEpoch__T]) -> 'FieldAbsoluteDate'[_getArbitraryEpoch__T]: ...
    _getCCSDSEpoch__T = typing.TypeVar('_getCCSDSEpoch__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @staticmethod
    def getCCSDSEpoch(field: org.hipparchus.Field[_getCCSDSEpoch__T]) -> 'FieldAbsoluteDate'[_getCCSDSEpoch__T]: ...
    @typing.overload
    def getComponents(self, int: int) -> DateTimeComponents: ...
    @typing.overload
    def getComponents(self, int: int, timeScale: TimeScale) -> DateTimeComponents: ...
    @typing.overload
    def getComponents(self, timeZone: java.util.TimeZone) -> DateTimeComponents: ...
    @typing.overload
    def getComponents(self, timeZone: java.util.TimeZone, timeScale: TimeScale) -> DateTimeComponents: ...
    @typing.overload
    def getComponents(self, timeScale: TimeScale) -> DateTimeComponents: ...
    def getDate(self) -> 'FieldAbsoluteDate'[_FieldAbsoluteDate__T]: ...
    def getField(self) -> org.hipparchus.Field[_FieldAbsoluteDate__T]: ...
    _getFiftiesEpoch__T = typing.TypeVar('_getFiftiesEpoch__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @staticmethod
    def getFiftiesEpoch(field: org.hipparchus.Field[_getFiftiesEpoch__T]) -> 'FieldAbsoluteDate'[_getFiftiesEpoch__T]: ...
    _getFutureInfinity__T = typing.TypeVar('_getFutureInfinity__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @staticmethod
    def getFutureInfinity(field: org.hipparchus.Field[_getFutureInfinity__T]) -> 'FieldAbsoluteDate'[_getFutureInfinity__T]: ...
    _getGPSEpoch__T = typing.TypeVar('_getGPSEpoch__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @staticmethod
    def getGPSEpoch(field: org.hipparchus.Field[_getGPSEpoch__T]) -> 'FieldAbsoluteDate'[_getGPSEpoch__T]: ...
    _getGalileoEpoch__T = typing.TypeVar('_getGalileoEpoch__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @staticmethod
    def getGalileoEpoch(field: org.hipparchus.Field[_getGalileoEpoch__T]) -> 'FieldAbsoluteDate'[_getGalileoEpoch__T]: ...
    _getJ2000Epoch__T = typing.TypeVar('_getJ2000Epoch__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @staticmethod
    def getJ2000Epoch(field: org.hipparchus.Field[_getJ2000Epoch__T]) -> 'FieldAbsoluteDate'[_getJ2000Epoch__T]: ...
    _getJavaEpoch__T = typing.TypeVar('_getJavaEpoch__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @staticmethod
    def getJavaEpoch(field: org.hipparchus.Field[_getJavaEpoch__T]) -> 'FieldAbsoluteDate'[_getJavaEpoch__T]: ...
    _getJulianEpoch__T = typing.TypeVar('_getJulianEpoch__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @staticmethod
    def getJulianEpoch(field: org.hipparchus.Field[_getJulianEpoch__T]) -> 'FieldAbsoluteDate'[_getJulianEpoch__T]: ...
    _getModifiedJulianEpoch__T = typing.TypeVar('_getModifiedJulianEpoch__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @staticmethod
    def getModifiedJulianEpoch(field: org.hipparchus.Field[_getModifiedJulianEpoch__T]) -> 'FieldAbsoluteDate'[_getModifiedJulianEpoch__T]: ...
    _getPastInfinity__T = typing.TypeVar('_getPastInfinity__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @staticmethod
    def getPastInfinity(field: org.hipparchus.Field[_getPastInfinity__T]) -> 'FieldAbsoluteDate'[_getPastInfinity__T]: ...
    def hasZeroField(self) -> bool: ...
    def hashCode(self) -> int: ...
    def isAfter(self, fieldTimeStamped: FieldTimeStamped[_FieldAbsoluteDate__T]) -> bool: ...
    def isAfterOrEqualTo(self, fieldTimeStamped: FieldTimeStamped[_FieldAbsoluteDate__T]) -> bool: ...
    def isBefore(self, fieldTimeStamped: FieldTimeStamped[_FieldAbsoluteDate__T]) -> bool: ...
    def isBeforeOrEqualTo(self, fieldTimeStamped: FieldTimeStamped[_FieldAbsoluteDate__T]) -> bool: ...
    def isBetween(self, fieldTimeStamped: FieldTimeStamped[_FieldAbsoluteDate__T], fieldTimeStamped2: FieldTimeStamped[_FieldAbsoluteDate__T]) -> bool: ...
    def isBetweenOrEqualTo(self, fieldTimeStamped: FieldTimeStamped[_FieldAbsoluteDate__T], fieldTimeStamped2: FieldTimeStamped[_FieldAbsoluteDate__T]) -> bool: ...
    def isCloseTo(self, fieldTimeStamped: FieldTimeStamped[_FieldAbsoluteDate__T], double: float) -> bool: ...
    def isEqualTo(self, fieldTimeStamped: FieldTimeStamped[_FieldAbsoluteDate__T]) -> bool: ...
    def offsetFrom(self, fieldAbsoluteDate: 'FieldAbsoluteDate'[_FieldAbsoluteDate__T], timeScale: TimeScale) -> _FieldAbsoluteDate__T: ...
    @typing.overload
    def parseCCSDSCalendarSegmentedTimeCode(self, byte: int, byteArray: typing.List[int]) -> 'FieldAbsoluteDate'[_FieldAbsoluteDate__T]: ...
    @typing.overload
    def parseCCSDSCalendarSegmentedTimeCode(self, byte: int, byteArray: typing.List[int], timeScale: TimeScale) -> 'FieldAbsoluteDate'[_FieldAbsoluteDate__T]: ...
    _parseCCSDSDaySegmentedTimeCode_0__T = typing.TypeVar('_parseCCSDSDaySegmentedTimeCode_0__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _parseCCSDSDaySegmentedTimeCode_1__T = typing.TypeVar('_parseCCSDSDaySegmentedTimeCode_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def parseCCSDSDaySegmentedTimeCode(field: org.hipparchus.Field[_parseCCSDSDaySegmentedTimeCode_0__T], byte: int, byteArray: typing.List[int], dateComponents: DateComponents) -> 'FieldAbsoluteDate'[_parseCCSDSDaySegmentedTimeCode_0__T]: ...
    @typing.overload
    @staticmethod
    def parseCCSDSDaySegmentedTimeCode(field: org.hipparchus.Field[_parseCCSDSDaySegmentedTimeCode_1__T], byte: int, byteArray: typing.List[int], dateComponents: DateComponents, timeScale: TimeScale) -> 'FieldAbsoluteDate'[_parseCCSDSDaySegmentedTimeCode_1__T]: ...
    _parseCCSDSUnsegmentedTimeCode_0__T = typing.TypeVar('_parseCCSDSUnsegmentedTimeCode_0__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    _parseCCSDSUnsegmentedTimeCode_1__T = typing.TypeVar('_parseCCSDSUnsegmentedTimeCode_1__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
    @typing.overload
    @staticmethod
    def parseCCSDSUnsegmentedTimeCode(field: org.hipparchus.Field[_parseCCSDSUnsegmentedTimeCode_0__T], byte: int, byte2: int, byteArray: typing.List[int], fieldAbsoluteDate: 'FieldAbsoluteDate'[_parseCCSDSUnsegmentedTimeCode_0__T]) -> 'FieldAbsoluteDate'[_parseCCSDSUnsegmentedTimeCode_0__T]: ...
    @typing.overload
    @staticmethod
    def parseCCSDSUnsegmentedTimeCode(field: org.hipparchus.Field[_parseCCSDSUnsegmentedTimeCode_1__T], byte: int, byte2: int, byteArray: typing.List[int], fieldAbsoluteDate: 'FieldAbsoluteDate'[_parseCCSDSUnsegmentedTimeCode_1__T], fieldAbsoluteDate2: 'FieldAbsoluteDate'[_parseCCSDSUnsegmentedTimeCode_1__T]) -> 'FieldAbsoluteDate'[_parseCCSDSUnsegmentedTimeCode_1__T]: ...
    @typing.overload
    def shiftedBy(self, double: float) -> 'FieldAbsoluteDate'[_FieldAbsoluteDate__T]: ...
    @typing.overload
    def shiftedBy(self, long: int, timeUnit: java.util.concurrent.TimeUnit) -> 'FieldAbsoluteDate'[_FieldAbsoluteDate__T]: ...
    @typing.overload
    def shiftedBy(self, t: _FieldAbsoluteDate__T) -> 'FieldAbsoluteDate'[_FieldAbsoluteDate__T]: ...
    def timeScalesOffset(self, timeScale: TimeScale, timeScale2: TimeScale) -> _FieldAbsoluteDate__T: ...
    def toAbsoluteDate(self) -> AbsoluteDate: ...
    def toDate(self, timeScale: TimeScale) -> java.util.Date: ...
    @typing.overload
    def toInstant(self) -> java.time.Instant: ...
    @typing.overload
    def toInstant(self, timeScales: TimeScales) -> java.time.Instant: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    def toString(self, int: int) -> str: ...
    @typing.overload
    def toString(self, int: int, timeScale: TimeScale) -> str: ...
    @typing.overload
    def toString(self, timeZone: java.util.TimeZone) -> str: ...
    @typing.overload
    def toString(self, timeZone: java.util.TimeZone, timeScale: TimeScale) -> str: ...
    @typing.overload
    def toString(self, timeScale: TimeScale) -> str: ...
    def toStringWithoutUtcOffset(self, timeScale: TimeScale, int: int) -> str: ...

_FieldClockOffsetHermiteInterpolator__T = typing.TypeVar('_FieldClockOffsetHermiteInterpolator__T', bound=org.hipparchus.CalculusFieldElement)  # <T>
class FieldClockOffsetHermiteInterpolator(AbstractFieldTimeInterpolator[FieldClockOffset[_FieldClockOffsetHermiteInterpolator__T], _FieldClockOffsetHermiteInterpolator__T], typing.Generic[_FieldClockOffsetHermiteInterpolator__T]):
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, double: float): ...

class GPSScale(ConstantOffsetTimeScale): ...

class GalileoScale(ConstantOffsetTimeScale): ...

class IRNSSScale(ConstantOffsetTimeScale): ...

class LazyLoadedTimeScales(AbstractTimeScales):
    def __init__(self, lazyLoadedEop: org.orekit.frames.LazyLoadedEop): ...
    def addDefaultUTCTAIOffsetsLoaders(self) -> None: ...
    def addUTCTAIOffsetsLoader(self, uTCTAIOffsetsLoader: UTCTAIOffsetsLoader) -> None: ...
    def clearUTCTAIOffsetsLoaders(self) -> None: ...
    def getBDT(self) -> BDTScale: ...
    def getGLONASS(self) -> GLONASSScale: ...
    def getGMST(self, iERSConventions: org.orekit.utils.IERSConventions, boolean: bool) -> GMSTScale: ...
    def getGPS(self) -> GPSScale: ...
    def getGST(self) -> GalileoScale: ...
    def getIRNSS(self) -> IRNSSScale: ...
    def getQZSS(self) -> 'QZSSScale': ...
    def getTAI(self) -> 'TAIScale': ...
    def getTCB(self) -> TCBScale: ...
    def getTCG(self) -> TCGScale: ...
    def getTDB(self) -> TDBScale: ...
    def getTT(self) -> 'TTScale': ...
    @typing.overload
    def getUT1(self, eOPHistory: org.orekit.frames.EOPHistory) -> UT1Scale: ...
    @typing.overload
    def getUT1(self, iERSConventions: org.orekit.utils.IERSConventions, boolean: bool) -> UT1Scale: ...
    def getUTC(self) -> UTCScale: ...

class PythonAbstractTimeScales(AbstractTimeScales):
    def __init__(self): ...
    def finalize(self) -> None: ...
    def getBDT(self) -> BDTScale: ...
    def getEopHistory(self, iERSConventions: org.orekit.utils.IERSConventions, boolean: bool) -> org.orekit.frames.EOPHistory: ...
    def getGLONASS(self) -> GLONASSScale: ...
    def getGPS(self) -> GPSScale: ...
    def getGST(self) -> GalileoScale: ...
    def getIRNSS(self) -> IRNSSScale: ...
    def getQZSS(self) -> 'QZSSScale': ...
    def getTAI(self) -> 'TAIScale': ...
    def getTCB(self) -> TCBScale: ...
    def getTCG(self) -> TCGScale: ...
    def getTDB(self) -> TDBScale: ...
    def getTT(self) -> 'TTScale': ...
    @typing.overload
    def getUT1(self, iERSConventions: org.orekit.utils.IERSConventions, boolean: bool) -> UT1Scale: ...
    @typing.overload
    def getUT1(self, eOPHistory: org.orekit.frames.EOPHistory) -> UT1Scale: ...
    def getUTC(self) -> UTCScale: ...
    def pythonDecRef(self) -> None: ...
    @typing.overload
    def pythonExtension(self) -> int: ...
    @typing.overload
    def pythonExtension(self, long: int) -> None: ...

_PythonFieldTimeShiftable__T = typing.TypeVar('_PythonFieldTimeShiftable__T', bound=FieldTimeShiftable)  # <T>
_PythonFieldTimeShiftable__KK = typing.TypeVar('_PythonFieldTimeShiftable__KK', bound=org.hipparchus.CalculusFieldElement)  # <KK>
class PythonFieldTimeShiftable(FieldTimeShiftable[_PythonFieldTimeShiftable__T, _PythonFieldTimeShiftable__KK], typing.Generic[_PythonFieldTimeShiftable__T, _PythonFieldTimeShiftable__KK]):
    def __init__(self): ...
    def finalize(self) -> None: ...
    def pythonDecRef(self) -> None: ...
    @typing.overload
    def pythonExtension(self) -> int: ...
    @typing.overload
    def pythonExtension(self, long: int) -> None: ...
    @typing.overload
    def shiftedBy(self, double: float) -> _PythonFieldTimeShiftable__T: ...
    @typing.overload
    def shiftedBy(self, kK: _PythonFieldTimeShiftable__KK) -> _PythonFieldTimeShiftable__T: ...
    def shiftedBy_KK(self, kK: _PythonFieldTimeShiftable__KK) -> _PythonFieldTimeShiftable__T: ...

class QZSSScale(ConstantOffsetTimeScale): ...

class TAIScale(ConstantOffsetTimeScale): ...

class TTScale(ConstantOffsetTimeScale): ...

class TimeStampedDoubleAndDerivative(TimeStampedDouble):
    def __init__(self, double: float, double2: float, absoluteDate: AbsoluteDate): ...
    def getDerivative(self) -> float: ...

class TimeStampedDoubleAndDerivativeHermiteInterpolator(AbstractTimeInterpolator[TimeStampedDoubleAndDerivative]):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, double: float): ...

class TimeStampedDoubleHermiteInterpolator(AbstractTimeInterpolator[TimeStampedDouble]):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, double: float): ...

_TimeStampedFieldHermiteInterpolator__KK = typing.TypeVar('_TimeStampedFieldHermiteInterpolator__KK', bound=org.hipparchus.CalculusFieldElement)  # <KK>
class TimeStampedFieldHermiteInterpolator(AbstractFieldTimeInterpolator[TimeStampedField[_TimeStampedFieldHermiteInterpolator__KK], _TimeStampedFieldHermiteInterpolator__KK], typing.Generic[_TimeStampedFieldHermiteInterpolator__KK]):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, double: float): ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.orekit.time")``.

    AGILeapSecondFilesLoader: typing.Type[AGILeapSecondFilesLoader]
    AbsoluteDate: typing.Type[AbsoluteDate]
    AbstractFieldTimeInterpolator: typing.Type[AbstractFieldTimeInterpolator]
    AbstractTimeInterpolator: typing.Type[AbstractTimeInterpolator]
    AbstractTimeScales: typing.Type[AbstractTimeScales]
    AggregatedClockModel: typing.Type[AggregatedClockModel]
    BDTScale: typing.Type[BDTScale]
    BurstSelector: typing.Type[BurstSelector]
    ChronologicalComparator: typing.Type[ChronologicalComparator]
    ClockModel: typing.Type[ClockModel]
    ClockOffset: typing.Type[ClockOffset]
    ClockOffsetHermiteInterpolator: typing.Type[ClockOffsetHermiteInterpolator]
    ClockTimeScale: typing.Type[ClockTimeScale]
    ConstantOffsetTimeScale: typing.Type[ConstantOffsetTimeScale]
    DateComponents: typing.Type[DateComponents]
    DateTimeComponents: typing.Type[DateTimeComponents]
    DatesSelector: typing.Type[DatesSelector]
    FieldAbsoluteDate: typing.Type[FieldAbsoluteDate]
    FieldChronologicalComparator: typing.Type[FieldChronologicalComparator]
    FieldClockOffset: typing.Type[FieldClockOffset]
    FieldClockOffsetHermiteInterpolator: typing.Type[FieldClockOffsetHermiteInterpolator]
    FieldTimeInterpolator: typing.Type[FieldTimeInterpolator]
    FieldTimeShiftable: typing.Type[FieldTimeShiftable]
    FieldTimeStamped: typing.Type[FieldTimeStamped]
    FieldTimeStampedPair: typing.Type[FieldTimeStampedPair]
    FixedStepSelector: typing.Type[FixedStepSelector]
    GLONASSDate: typing.Type[GLONASSDate]
    GLONASSScale: typing.Type[GLONASSScale]
    GMSTScale: typing.Type[GMSTScale]
    GNSSDate: typing.Type[GNSSDate]
    GPSScale: typing.Type[GPSScale]
    GalileoScale: typing.Type[GalileoScale]
    IRNSSScale: typing.Type[IRNSSScale]
    LazyLoadedTimeScales: typing.Type[LazyLoadedTimeScales]
    Month: typing.Type[Month]
    OffsetModel: typing.Type[OffsetModel]
    PerfectClockModel: typing.Type[PerfectClockModel]
    PythonAbstractTimeScales: typing.Type[PythonAbstractTimeScales]
    PythonClockModel: typing.Type[PythonClockModel]
    PythonDatesSelector: typing.Type[PythonDatesSelector]
    PythonFieldTimeInterpolator: typing.Type[PythonFieldTimeInterpolator]
    PythonFieldTimeShiftable: typing.Type[PythonFieldTimeShiftable]
    PythonFieldTimeStamped: typing.Type[PythonFieldTimeStamped]
    PythonParser: typing.Type[PythonParser]
    PythonTimeInterpolator: typing.Type[PythonTimeInterpolator]
    PythonTimeScalarFunction: typing.Type[PythonTimeScalarFunction]
    PythonTimeScale: typing.Type[PythonTimeScale]
    PythonTimeScales: typing.Type[PythonTimeScales]
    PythonTimeShiftable: typing.Type[PythonTimeShiftable]
    PythonTimeStamped: typing.Type[PythonTimeStamped]
    PythonTimeVectorFunction: typing.Type[PythonTimeVectorFunction]
    PythonUTCTAIOffsetsLoader: typing.Type[PythonUTCTAIOffsetsLoader]
    QZSSScale: typing.Type[QZSSScale]
    SampledClockModel: typing.Type[SampledClockModel]
    SatelliteClockScale: typing.Type[SatelliteClockScale]
    TAIScale: typing.Type[TAIScale]
    TAIUTCDatFilesLoader: typing.Type[TAIUTCDatFilesLoader]
    TCBScale: typing.Type[TCBScale]
    TCGScale: typing.Type[TCGScale]
    TDBScale: typing.Type[TDBScale]
    TTScale: typing.Type[TTScale]
    TimeComponents: typing.Type[TimeComponents]
    TimeInterpolator: typing.Type[TimeInterpolator]
    TimeScalarFunction: typing.Type[TimeScalarFunction]
    TimeScale: typing.Type[TimeScale]
    TimeScales: typing.Type[TimeScales]
    TimeScalesFactory: typing.Type[TimeScalesFactory]
    TimeShiftable: typing.Type[TimeShiftable]
    TimeStamped: typing.Type[TimeStamped]
    TimeStampedDouble: typing.Type[TimeStampedDouble]
    TimeStampedDoubleAndDerivative: typing.Type[TimeStampedDoubleAndDerivative]
    TimeStampedDoubleAndDerivativeHermiteInterpolator: typing.Type[TimeStampedDoubleAndDerivativeHermiteInterpolator]
    TimeStampedDoubleHermiteInterpolator: typing.Type[TimeStampedDoubleHermiteInterpolator]
    TimeStampedField: typing.Type[TimeStampedField]
    TimeStampedFieldHermiteInterpolator: typing.Type[TimeStampedFieldHermiteInterpolator]
    TimeStampedPair: typing.Type[TimeStampedPair]
    TimeVectorFunction: typing.Type[TimeVectorFunction]
    UT1Scale: typing.Type[UT1Scale]
    UTCScale: typing.Type[UTCScale]
    UTCTAIBulletinAFilesLoader: typing.Type[UTCTAIBulletinAFilesLoader]
    UTCTAIHistoryFilesLoader: typing.Type[UTCTAIHistoryFilesLoader]
    UTCTAIOffset: typing.Type[UTCTAIOffset]
    UTCTAIOffsetsLoader: typing.Type[UTCTAIOffsetsLoader]
