import java.lang
import java.util
import java.util.function
import org.hipparchus.complex
import org.hipparchus.geometry.euclidean.threed
import org.hipparchus.linear
import org.orekit.attitudes
import org.orekit.data
import org.orekit.files.ccsds.definitions
import org.orekit.files.ccsds.ndm
import org.orekit.files.ccsds.ndm.adm
import org.orekit.files.ccsds.section
import org.orekit.files.ccsds.utils
import org.orekit.files.ccsds.utils.generation
import org.orekit.files.ccsds.utils.lexical
import org.orekit.frames
import org.orekit.time
import org.orekit.utils
import typing



class AngularVelocity(org.orekit.files.ccsds.section.CommentsContainer):
    def __init__(self): ...
    def getAngVelX(self) -> float: ...
    def getAngVelY(self) -> float: ...
    def getAngVelZ(self) -> float: ...
    def getEndpoints(self) -> org.orekit.files.ccsds.ndm.adm.AttitudeEndpoints: ...
    def getFrame(self) -> org.orekit.files.ccsds.definitions.FrameFacade: ...
    def setAngVelX(self, double: float) -> None: ...
    def setAngVelY(self, double: float) -> None: ...
    def setAngVelZ(self, double: float) -> None: ...
    def setFrame(self, frameFacade: org.orekit.files.ccsds.definitions.FrameFacade) -> None: ...
    def validate(self, double: float) -> None: ...

class AngularVelocityKey(java.lang.Enum['AngularVelocityKey']):
    COMMENT: typing.ClassVar['AngularVelocityKey'] = ...
    REF_FRAME_A: typing.ClassVar['AngularVelocityKey'] = ...
    REF_FRAME_B: typing.ClassVar['AngularVelocityKey'] = ...
    ANGVEL_FRAME: typing.ClassVar['AngularVelocityKey'] = ...
    ANGVEL_X: typing.ClassVar['AngularVelocityKey'] = ...
    ANGVEL_Y: typing.ClassVar['AngularVelocityKey'] = ...
    ANGVEL_Z: typing.ClassVar['AngularVelocityKey'] = ...
    def process(self, parseToken: org.orekit.files.ccsds.utils.lexical.ParseToken, contextBinding: org.orekit.files.ccsds.utils.ContextBinding, angularVelocity: AngularVelocity) -> bool: ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'AngularVelocityKey': ...
    @staticmethod
    def values() -> typing.List['AngularVelocityKey']: ...

class Apm(org.orekit.files.ccsds.ndm.NdmConstituent[org.orekit.files.ccsds.ndm.adm.AdmHeader, org.orekit.files.ccsds.section.Segment[org.orekit.files.ccsds.ndm.adm.AdmMetadata, 'ApmData']]):
    ROOT: typing.ClassVar[str] = ...
    FORMAT_VERSION_KEY: typing.ClassVar[str] = ...
    def __init__(self, admHeader: org.orekit.files.ccsds.ndm.adm.AdmHeader, list: java.util.List[org.orekit.files.ccsds.section.Segment[org.orekit.files.ccsds.ndm.adm.AdmMetadata, 'ApmData']], iERSConventions: org.orekit.utils.IERSConventions, dataContext: org.orekit.data.DataContext): ...
    def getAttitude(self, frame: org.orekit.frames.Frame, pVCoordinatesProvider: org.orekit.utils.PVCoordinatesProvider) -> org.orekit.attitudes.Attitude: ...
    def getData(self) -> 'ApmData': ...
    def getMetadata(self) -> org.orekit.files.ccsds.ndm.adm.AdmMetadata: ...

class ApmData(org.orekit.files.ccsds.section.Data):
    def __init__(self, commentsContainer: org.orekit.files.ccsds.section.CommentsContainer, absoluteDate: org.orekit.time.AbsoluteDate, apmQuaternion: 'ApmQuaternion', euler: 'Euler', angularVelocity: AngularVelocity, spinStabilized: 'SpinStabilized', inertia: 'Inertia'): ...
    def addManeuver(self, maneuver: 'Maneuver') -> None: ...
    def getAngularVelocityBlock(self) -> AngularVelocity: ...
    def getAttitude(self, frame: org.orekit.frames.Frame, pVCoordinatesProvider: org.orekit.utils.PVCoordinatesProvider) -> org.orekit.attitudes.Attitude: ...
    def getComments(self) -> java.util.List[str]: ...
    def getEpoch(self) -> org.orekit.time.AbsoluteDate: ...
    def getEulerBlock(self) -> 'Euler': ...
    def getInertiaBlock(self) -> 'Inertia': ...
    def getManeuver(self, int: int) -> 'Maneuver': ...
    def getManeuvers(self) -> java.util.List['Maneuver']: ...
    def getNbManeuvers(self) -> int: ...
    def getQuaternionBlock(self) -> 'ApmQuaternion': ...
    def getSpinStabilizedBlock(self) -> 'SpinStabilized': ...
    def hasManeuvers(self) -> bool: ...
    def validate(self, double: float) -> None: ...

class ApmParser(org.orekit.files.ccsds.ndm.adm.AdmParser[Apm, 'ApmParser']):
    def __init__(self, iERSConventions: org.orekit.utils.IERSConventions, boolean: bool, dataContext: org.orekit.data.DataContext, absoluteDate: org.orekit.time.AbsoluteDate, parsedUnitsBehavior: org.orekit.files.ccsds.ndm.ParsedUnitsBehavior, functionArray: typing.List[java.util.function.Function[org.orekit.files.ccsds.utils.lexical.ParseToken, java.util.List[org.orekit.files.ccsds.utils.lexical.ParseToken]]]): ...
    def build(self) -> Apm: ...
    def finalizeData(self) -> bool: ...
    def finalizeHeader(self) -> bool: ...
    def finalizeMetadata(self) -> bool: ...
    def getHeader(self) -> org.orekit.files.ccsds.ndm.adm.AdmHeader: ...
    def inData(self) -> bool: ...
    def inHeader(self) -> bool: ...
    def inMetadata(self) -> bool: ...
    def prepareData(self) -> bool: ...
    def prepareHeader(self) -> bool: ...
    def prepareMetadata(self) -> bool: ...
    def reset(self, fileFormat: org.orekit.files.ccsds.utils.FileFormat) -> None: ...

class ApmQuaternion(org.orekit.files.ccsds.section.CommentsContainer):
    def __init__(self): ...
    def getEndpoints(self) -> org.orekit.files.ccsds.ndm.adm.AttitudeEndpoints: ...
    def getQuaternion(self) -> org.hipparchus.complex.Quaternion: ...
    def getQuaternionDot(self) -> org.hipparchus.complex.Quaternion: ...
    def hasRates(self) -> bool: ...
    def setQ(self, int: int, double: float) -> None: ...
    def setQDot(self, int: int, double: float) -> None: ...
    def validate(self, double: float) -> None: ...

class ApmQuaternionKey(java.lang.Enum['ApmQuaternionKey']):
    quaternion: typing.ClassVar['ApmQuaternionKey'] = ...
    quaternionRate: typing.ClassVar['ApmQuaternionKey'] = ...
    quaternionDot: typing.ClassVar['ApmQuaternionKey'] = ...
    COMMENT: typing.ClassVar['ApmQuaternionKey'] = ...
    EPOCH: typing.ClassVar['ApmQuaternionKey'] = ...
    Q_FRAME_A: typing.ClassVar['ApmQuaternionKey'] = ...
    REF_FRAME_A: typing.ClassVar['ApmQuaternionKey'] = ...
    Q_FRAME_B: typing.ClassVar['ApmQuaternionKey'] = ...
    REF_FRAME_B: typing.ClassVar['ApmQuaternionKey'] = ...
    Q_DIR: typing.ClassVar['ApmQuaternionKey'] = ...
    QC: typing.ClassVar['ApmQuaternionKey'] = ...
    Q1: typing.ClassVar['ApmQuaternionKey'] = ...
    Q2: typing.ClassVar['ApmQuaternionKey'] = ...
    Q3: typing.ClassVar['ApmQuaternionKey'] = ...
    QC_DOT: typing.ClassVar['ApmQuaternionKey'] = ...
    Q1_DOT: typing.ClassVar['ApmQuaternionKey'] = ...
    Q2_DOT: typing.ClassVar['ApmQuaternionKey'] = ...
    Q3_DOT: typing.ClassVar['ApmQuaternionKey'] = ...
    def process(self, parseToken: org.orekit.files.ccsds.utils.lexical.ParseToken, contextBinding: org.orekit.files.ccsds.utils.ContextBinding, apmQuaternion: ApmQuaternion, dateConsumer: org.orekit.files.ccsds.utils.lexical.ParseToken.DateConsumer) -> bool: ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'ApmQuaternionKey': ...
    @staticmethod
    def values() -> typing.List['ApmQuaternionKey']: ...

class ApmWriter(org.orekit.files.ccsds.utils.generation.AbstractMessageWriter[org.orekit.files.ccsds.ndm.adm.AdmHeader, org.orekit.files.ccsds.section.Segment[org.orekit.files.ccsds.ndm.adm.AdmMetadata, ApmData], Apm]):
    CCSDS_APM_VERS: typing.ClassVar[float] = ...
    KVN_PADDING_WIDTH: typing.ClassVar[int] = ...
    def __init__(self, iERSConventions: org.orekit.utils.IERSConventions, dataContext: org.orekit.data.DataContext, absoluteDate: org.orekit.time.AbsoluteDate): ...

class Euler(org.orekit.files.ccsds.section.CommentsContainer):
    def __init__(self): ...
    def getEndpoints(self) -> org.orekit.files.ccsds.ndm.adm.AttitudeEndpoints: ...
    def getEulerRotSeq(self) -> org.hipparchus.geometry.euclidean.threed.RotationOrder: ...
    def getRotationAngles(self) -> typing.List[float]: ...
    def getRotationRates(self) -> typing.List[float]: ...
    def hasAngles(self) -> bool: ...
    def hasRates(self) -> bool: ...
    def isSpacecraftBodyRate(self) -> bool: ...
    def rateFrameIsA(self) -> bool: ...
    def setEulerRotSeq(self, rotationOrder: org.hipparchus.geometry.euclidean.threed.RotationOrder) -> None: ...
    def setInRotationAngles(self, boolean: bool) -> None: ...
    def setIndexedRotationAngle(self, int: int, double: float) -> None: ...
    def setIndexedRotationRate(self, int: int, double: float) -> None: ...
    def setLabeledRotationAngle(self, char: str, double: float) -> None: ...
    def setLabeledRotationRate(self, char: str, double: float) -> None: ...
    def setRateFrameIsA(self, boolean: bool) -> None: ...
    def validate(self, double: float) -> None: ...

class EulerKey(java.lang.Enum['EulerKey']):
    rotationAngles: typing.ClassVar['EulerKey'] = ...
    rotationRates: typing.ClassVar['EulerKey'] = ...
    COMMENT: typing.ClassVar['EulerKey'] = ...
    EULER_FRAME_A: typing.ClassVar['EulerKey'] = ...
    REF_FRAME_A: typing.ClassVar['EulerKey'] = ...
    EULER_FRAME_B: typing.ClassVar['EulerKey'] = ...
    REF_FRAME_B: typing.ClassVar['EulerKey'] = ...
    EULER_DIR: typing.ClassVar['EulerKey'] = ...
    EULER_ROT_SEQ: typing.ClassVar['EulerKey'] = ...
    RATE_FRAME: typing.ClassVar['EulerKey'] = ...
    X_ANGLE: typing.ClassVar['EulerKey'] = ...
    Y_ANGLE: typing.ClassVar['EulerKey'] = ...
    Z_ANGLE: typing.ClassVar['EulerKey'] = ...
    X_RATE: typing.ClassVar['EulerKey'] = ...
    Y_RATE: typing.ClassVar['EulerKey'] = ...
    Z_RATE: typing.ClassVar['EulerKey'] = ...
    ANGLE_1: typing.ClassVar['EulerKey'] = ...
    ANGLE_2: typing.ClassVar['EulerKey'] = ...
    ANGLE_3: typing.ClassVar['EulerKey'] = ...
    ANGLE_1_DOT: typing.ClassVar['EulerKey'] = ...
    ANGLE_2_DOT: typing.ClassVar['EulerKey'] = ...
    ANGLE_3_DOT: typing.ClassVar['EulerKey'] = ...
    def process(self, parseToken: org.orekit.files.ccsds.utils.lexical.ParseToken, contextBinding: org.orekit.files.ccsds.utils.ContextBinding, euler: Euler) -> bool: ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'EulerKey': ...
    @staticmethod
    def values() -> typing.List['EulerKey']: ...

class Inertia(org.orekit.files.ccsds.ndm.CommonPhysicalProperties):
    def __init__(self): ...
    def getFrame(self) -> org.orekit.files.ccsds.definitions.FrameFacade: ...
    def getInertiaMatrix(self) -> org.hipparchus.linear.RealMatrix: ...
    def setFrame(self, frameFacade: org.orekit.files.ccsds.definitions.FrameFacade) -> None: ...
    def setInertiaMatrixEntry(self, int: int, int2: int, double: float) -> None: ...
    def validate(self, double: float) -> None: ...

class InertiaKey(java.lang.Enum['InertiaKey']):
    COMMENT: typing.ClassVar['InertiaKey'] = ...
    INERTIA_REF_FRAME: typing.ClassVar['InertiaKey'] = ...
    I11: typing.ClassVar['InertiaKey'] = ...
    IXX: typing.ClassVar['InertiaKey'] = ...
    I22: typing.ClassVar['InertiaKey'] = ...
    IYY: typing.ClassVar['InertiaKey'] = ...
    I33: typing.ClassVar['InertiaKey'] = ...
    IZZ: typing.ClassVar['InertiaKey'] = ...
    I12: typing.ClassVar['InertiaKey'] = ...
    IXY: typing.ClassVar['InertiaKey'] = ...
    I13: typing.ClassVar['InertiaKey'] = ...
    IXZ: typing.ClassVar['InertiaKey'] = ...
    I23: typing.ClassVar['InertiaKey'] = ...
    IYZ: typing.ClassVar['InertiaKey'] = ...
    def process(self, parseToken: org.orekit.files.ccsds.utils.lexical.ParseToken, contextBinding: org.orekit.files.ccsds.utils.ContextBinding, inertia: Inertia) -> bool: ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'InertiaKey': ...
    @staticmethod
    def values() -> typing.List['InertiaKey']: ...

class Maneuver(org.orekit.files.ccsds.section.CommentsContainer):
    def __init__(self): ...
    def getDeltaMass(self) -> float: ...
    def getDuration(self) -> float: ...
    def getEpochStart(self) -> org.orekit.time.AbsoluteDate: ...
    def getFrame(self) -> org.orekit.files.ccsds.definitions.FrameFacade: ...
    def getTorque(self) -> org.hipparchus.geometry.euclidean.threed.Vector3D: ...
    def setDeltaMass(self, double: float) -> None: ...
    def setDuration(self, double: float) -> None: ...
    def setEpochStart(self, absoluteDate: org.orekit.time.AbsoluteDate) -> None: ...
    def setFrame(self, frameFacade: org.orekit.files.ccsds.definitions.FrameFacade) -> None: ...
    def setTorque(self, int: int, double: float) -> None: ...
    def validate(self, double: float) -> None: ...

class ManeuverKey(java.lang.Enum['ManeuverKey']):
    COMMENT: typing.ClassVar['ManeuverKey'] = ...
    MAN_EPOCH_START: typing.ClassVar['ManeuverKey'] = ...
    MAN_DURATION: typing.ClassVar['ManeuverKey'] = ...
    MAN_REF_FRAME: typing.ClassVar['ManeuverKey'] = ...
    MAN_TOR_1: typing.ClassVar['ManeuverKey'] = ...
    MAN_TOR_X: typing.ClassVar['ManeuverKey'] = ...
    MAN_TOR_2: typing.ClassVar['ManeuverKey'] = ...
    MAN_TOR_Y: typing.ClassVar['ManeuverKey'] = ...
    MAN_TOR_3: typing.ClassVar['ManeuverKey'] = ...
    MAN_TOR_Z: typing.ClassVar['ManeuverKey'] = ...
    MAN_DELTA_MASS: typing.ClassVar['ManeuverKey'] = ...
    def process(self, parseToken: org.orekit.files.ccsds.utils.lexical.ParseToken, contextBinding: org.orekit.files.ccsds.utils.ContextBinding, maneuver: Maneuver) -> bool: ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'ManeuverKey': ...
    @staticmethod
    def values() -> typing.List['ManeuverKey']: ...

class SpinStabilized(org.orekit.files.ccsds.section.CommentsContainer):
    def __init__(self): ...
    def getEndpoints(self) -> org.orekit.files.ccsds.ndm.adm.AttitudeEndpoints: ...
    def getMomentumAlpha(self) -> float: ...
    def getMomentumDelta(self) -> float: ...
    def getNutation(self) -> float: ...
    def getNutationPeriod(self) -> float: ...
    def getNutationPhase(self) -> float: ...
    def getNutationVel(self) -> float: ...
    def getSpinAlpha(self) -> float: ...
    def getSpinAngle(self) -> float: ...
    def getSpinAngleVel(self) -> float: ...
    def getSpinDelta(self) -> float: ...
    def hasMomentum(self) -> bool: ...
    def hasNutation(self) -> bool: ...
    def setMomentumAlpha(self, double: float) -> None: ...
    def setMomentumDelta(self, double: float) -> None: ...
    def setNutation(self, double: float) -> None: ...
    def setNutationPeriod(self, double: float) -> None: ...
    def setNutationPhase(self, double: float) -> None: ...
    def setNutationVel(self, double: float) -> None: ...
    def setSpinAlpha(self, double: float) -> None: ...
    def setSpinAngle(self, double: float) -> None: ...
    def setSpinAngleVel(self, double: float) -> None: ...
    def setSpinDelta(self, double: float) -> None: ...
    def validate(self, double: float) -> None: ...

class SpinStabilizedKey(java.lang.Enum['SpinStabilizedKey']):
    COMMENT: typing.ClassVar['SpinStabilizedKey'] = ...
    SPIN_FRAME_A: typing.ClassVar['SpinStabilizedKey'] = ...
    REF_FRAME_A: typing.ClassVar['SpinStabilizedKey'] = ...
    SPIN_FRAME_B: typing.ClassVar['SpinStabilizedKey'] = ...
    REF_FRAME_B: typing.ClassVar['SpinStabilizedKey'] = ...
    SPIN_DIR: typing.ClassVar['SpinStabilizedKey'] = ...
    SPIN_ALPHA: typing.ClassVar['SpinStabilizedKey'] = ...
    SPIN_DELTA: typing.ClassVar['SpinStabilizedKey'] = ...
    SPIN_ANGLE: typing.ClassVar['SpinStabilizedKey'] = ...
    SPIN_ANGLE_VEL: typing.ClassVar['SpinStabilizedKey'] = ...
    NUTATION: typing.ClassVar['SpinStabilizedKey'] = ...
    NUTATION_PER: typing.ClassVar['SpinStabilizedKey'] = ...
    NUTATION_PHASE: typing.ClassVar['SpinStabilizedKey'] = ...
    MOMENTUM_ALPHA: typing.ClassVar['SpinStabilizedKey'] = ...
    MOMENTUM_DELTA: typing.ClassVar['SpinStabilizedKey'] = ...
    NUTATION_VEL: typing.ClassVar['SpinStabilizedKey'] = ...
    def process(self, parseToken: org.orekit.files.ccsds.utils.lexical.ParseToken, contextBinding: org.orekit.files.ccsds.utils.ContextBinding, spinStabilized: SpinStabilized) -> bool: ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'SpinStabilizedKey': ...
    @staticmethod
    def values() -> typing.List['SpinStabilizedKey']: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.orekit.files.ccsds.ndm.adm.apm")``.

    AngularVelocity: typing.Type[AngularVelocity]
    AngularVelocityKey: typing.Type[AngularVelocityKey]
    Apm: typing.Type[Apm]
    ApmData: typing.Type[ApmData]
    ApmParser: typing.Type[ApmParser]
    ApmQuaternion: typing.Type[ApmQuaternion]
    ApmQuaternionKey: typing.Type[ApmQuaternionKey]
    ApmWriter: typing.Type[ApmWriter]
    Euler: typing.Type[Euler]
    EulerKey: typing.Type[EulerKey]
    Inertia: typing.Type[Inertia]
    InertiaKey: typing.Type[InertiaKey]
    Maneuver: typing.Type[Maneuver]
    ManeuverKey: typing.Type[ManeuverKey]
    SpinStabilized: typing.Type[SpinStabilized]
    SpinStabilizedKey: typing.Type[SpinStabilizedKey]
