import java.lang
import java.util
import org.hipparchus.geometry.euclidean.threed
import org.orekit.bodies
import org.orekit.data
import org.orekit.errors
import org.orekit.files.ccsds.definitions
import org.orekit.files.ccsds.ndm
import org.orekit.files.ccsds.ndm.cdm
import org.orekit.files.ccsds.utils
import org.orekit.time
import org.orekit.utils.units
import typing



class LexicalAnalyzer:
    _accept__T = typing.TypeVar('_accept__T')  # <T>
    def accept(self, messageParser: 'MessageParser'[_accept__T]) -> _accept__T: ...

class LexicalAnalyzerSelector:
    @staticmethod
    def select(dataSource: org.orekit.data.DataSource) -> LexicalAnalyzer: ...

_MessageParser__T = typing.TypeVar('_MessageParser__T')  # <T>
class MessageParser(typing.Generic[_MessageParser__T]):
    def build(self) -> _MessageParser__T: ...
    def getFileFormat(self) -> org.orekit.files.ccsds.utils.FileFormat: ...
    def getFormatVersionKey(self) -> str: ...
    def getSpecialXmlElementsBuilders(self) -> java.util.Map[str, 'XmlTokenBuilder']: ...
    def parseMessage(self, dataSource: org.orekit.data.DataSource) -> _MessageParser__T: ...
    def process(self, parseToken: 'ParseToken') -> None: ...
    def reset(self, fileFormat: org.orekit.files.ccsds.utils.FileFormat) -> None: ...

_ParseToken__EnumConsumer__T = typing.TypeVar('_ParseToken__EnumConsumer__T', bound=java.lang.Enum)  # <T>
_ParseToken__EnumListConsumer__T = typing.TypeVar('_ParseToken__EnumListConsumer__T', bound=java.lang.Enum)  # <T>
class ParseToken:
    def __init__(self, tokenType: 'TokenType', string: str, string2: str, unit: org.orekit.utils.units.Unit, int: int, string3: str): ...
    def generateException(self, exception: java.lang.Exception) -> org.orekit.errors.OrekitException: ...
    def getContentAsBoolean(self) -> bool: ...
    def getContentAsDouble(self) -> float: ...
    _getContentAsEnum__T = typing.TypeVar('_getContentAsEnum__T', bound=java.lang.Enum)  # <T>
    def getContentAsEnum(self, class_: typing.Type[_getContentAsEnum__T]) -> _getContentAsEnum__T: ...
    _getContentAsEnumList__T = typing.TypeVar('_getContentAsEnumList__T', bound=java.lang.Enum)  # <T>
    def getContentAsEnumList(self, class_: typing.Type[_getContentAsEnumList__T]) -> java.util.List[_getContentAsEnumList__T]: ...
    def getContentAsFreeTextList(self) -> java.util.List[str]: ...
    def getContentAsInt(self) -> int: ...
    def getContentAsNormalizedList(self) -> java.util.List[str]: ...
    def getContentAsNormalizedString(self) -> str: ...
    def getContentAsUppercaseCharacter(self) -> str: ...
    def getContentAsUppercaseList(self) -> java.util.List[str]: ...
    def getContentAsUppercaseString(self) -> str: ...
    def getContentAsVector(self) -> org.hipparchus.geometry.euclidean.threed.Vector3D: ...
    def getFileName(self) -> str: ...
    def getLineNumber(self) -> int: ...
    def getName(self) -> str: ...
    def getRawContent(self) -> str: ...
    def getType(self) -> 'TokenType': ...
    def getUnits(self) -> org.orekit.utils.units.Unit: ...
    def processAsBoolean(self, booleanConsumer: 'ParseToken.BooleanConsumer') -> bool: ...
    def processAsCenter(self, centerConsumer: 'ParseToken.CenterConsumer', celestialBodies: org.orekit.bodies.CelestialBodies) -> bool: ...
    def processAsCenterList(self, centerListConsumer: 'ParseToken.CenterListConsumer', celestialBodies: org.orekit.bodies.CelestialBodies) -> bool: ...
    def processAsDate(self, dateConsumer: 'ParseToken.DateConsumer', contextBinding: org.orekit.files.ccsds.utils.ContextBinding) -> bool: ...
    def processAsDouble(self, unit: org.orekit.utils.units.Unit, parsedUnitsBehavior: org.orekit.files.ccsds.ndm.ParsedUnitsBehavior, doubleConsumer: 'ParseToken.DoubleConsumer') -> bool: ...
    def processAsDoubleArray(self, unit: org.orekit.utils.units.Unit, parsedUnitsBehavior: org.orekit.files.ccsds.ndm.ParsedUnitsBehavior, doubleArrayConsumer: 'ParseToken.DoubleArrayConsumer') -> bool: ...
    def processAsDoublyIndexedDouble(self, int: int, int2: int, unit: org.orekit.utils.units.Unit, parsedUnitsBehavior: org.orekit.files.ccsds.ndm.ParsedUnitsBehavior, doublyIndexedDoubleConsumer: 'ParseToken.DoublyIndexedDoubleConsumer') -> bool: ...
    _processAsEnum__T = typing.TypeVar('_processAsEnum__T', bound=java.lang.Enum)  # <T>
    def processAsEnum(self, class_: typing.Type[_processAsEnum__T], enumConsumer: 'ParseToken.EnumConsumer'[_processAsEnum__T]) -> bool: ...
    _processAsEnumsList__T = typing.TypeVar('_processAsEnumsList__T', bound=java.lang.Enum)  # <T>
    def processAsEnumsList(self, class_: typing.Type[_processAsEnumsList__T], enumListConsumer: 'ParseToken.EnumListConsumer'[_processAsEnumsList__T]) -> bool: ...
    def processAsFrame(self, frameConsumer: 'ParseToken.FrameConsumer', contextBinding: org.orekit.files.ccsds.utils.ContextBinding, boolean: bool, boolean2: bool, boolean3: bool) -> bool: ...
    def processAsFreeTextList(self, stringListConsumer: 'ParseToken.StringListConsumer') -> bool: ...
    def processAsFreeTextString(self, stringConsumer: 'ParseToken.StringConsumer') -> bool: ...
    def processAsIndexedDouble(self, int: int, unit: org.orekit.utils.units.Unit, parsedUnitsBehavior: org.orekit.files.ccsds.ndm.ParsedUnitsBehavior, indexedDoubleConsumer: 'ParseToken.IndexedDoubleConsumer') -> bool: ...
    def processAsIndexedDoubleArray(self, int: int, unit: org.orekit.utils.units.Unit, parsedUnitsBehavior: org.orekit.files.ccsds.ndm.ParsedUnitsBehavior, indexedDoubleArrayConsumer: 'ParseToken.IndexedDoubleArrayConsumer') -> bool: ...
    def processAsIndexedInteger(self, int: int, indexedIntConsumer: 'ParseToken.IndexedIntConsumer') -> bool: ...
    def processAsIndexedNormalizedString(self, int: int, indexedStringConsumer: 'ParseToken.IndexedStringConsumer') -> bool: ...
    def processAsIndexedUppercaseString(self, int: int, indexedStringConsumer: 'ParseToken.IndexedStringConsumer') -> bool: ...
    def processAsInteger(self, intConsumer: 'ParseToken.IntConsumer') -> bool: ...
    def processAsIntegerArray(self, integerArrayConsumer: 'ParseToken.IntegerArrayConsumer') -> bool: ...
    def processAsIntegerArrayNoSpace(self, integerArrayConsumer: 'ParseToken.IntegerArrayConsumer') -> bool: ...
    def processAsLabeledDouble(self, char: str, unit: org.orekit.utils.units.Unit, parsedUnitsBehavior: org.orekit.files.ccsds.ndm.ParsedUnitsBehavior, labeledDoubleConsumer: 'ParseToken.LabeledDoubleConsumer') -> bool: ...
    def processAsManeuvrableEnum(self, maneuvrableConsumer: 'ParseToken.ManeuvrableConsumer') -> bool: ...
    def processAsNormalizedCharacter(self, charConsumer: 'ParseToken.CharConsumer') -> bool: ...
    def processAsNormalizedList(self, stringListConsumer: 'ParseToken.StringListConsumer') -> bool: ...
    def processAsNormalizedString(self, stringConsumer: 'ParseToken.StringConsumer') -> bool: ...
    def processAsRotationOrder(self, rotationOrderConsumer: 'ParseToken.RotationOrderConsumer') -> bool: ...
    def processAsTimeSystem(self, timeSystemConsumer: 'ParseToken.TimeSystemConsumer') -> bool: ...
    def processAsUnitList(self, unitListConsumer: 'ParseToken.UnitListConsumer') -> bool: ...
    def processAsUppercaseList(self, stringListConsumer: 'ParseToken.StringListConsumer') -> bool: ...
    def processAsUppercaseString(self, stringConsumer: 'ParseToken.StringConsumer') -> bool: ...
    def processAsVector(self, unit: org.orekit.utils.units.Unit, parsedUnitsBehavior: org.orekit.files.ccsds.ndm.ParsedUnitsBehavior, vectorConsumer: 'ParseToken.VectorConsumer') -> bool: ...
    class BooleanConsumer:
        def accept(self, boolean: bool) -> None: ...
    class CenterConsumer:
        def accept(self, bodyFacade: org.orekit.files.ccsds.definitions.BodyFacade) -> None: ...
    class CenterListConsumer:
        def accept(self, list: java.util.List[org.orekit.files.ccsds.definitions.BodyFacade]) -> None: ...
    class CharConsumer:
        def accept(self, char: str) -> None: ...
    class DateConsumer:
        def accept(self, absoluteDate: org.orekit.time.AbsoluteDate) -> None: ...
    class DoubleArrayConsumer:
        def accept(self, doubleArray: typing.List[float]) -> None: ...
    class DoubleConsumer:
        def accept(self, double: float) -> None: ...
    class DoublyIndexedDoubleConsumer:
        def accept(self, int: int, int2: int, double: float) -> None: ...
    class EnumConsumer(typing.Generic[_ParseToken__EnumConsumer__T]):
        def accept(self, t: _ParseToken__EnumConsumer__T) -> None: ...
    class EnumListConsumer(typing.Generic[_ParseToken__EnumListConsumer__T]):
        def accept(self, list: java.util.List[_ParseToken__EnumListConsumer__T]) -> None: ...
    class FrameConsumer:
        def accept(self, frameFacade: org.orekit.files.ccsds.definitions.FrameFacade) -> None: ...
    class IndexedDoubleArrayConsumer:
        def accept(self, int: int, doubleArray: typing.List[float]) -> None: ...
    class IndexedDoubleConsumer:
        def accept(self, int: int, double: float) -> None: ...
    class IndexedIntConsumer:
        def accept(self, int: int, int2: int) -> None: ...
    class IndexedStringConsumer:
        def accept(self, int: int, string: str) -> None: ...
    class IntConsumer:
        def accept(self, int: int) -> None: ...
    class IntegerArrayConsumer:
        def accept(self, intArray: typing.List[int]) -> None: ...
    class LabeledDoubleConsumer:
        def accept(self, char: str, double: float) -> None: ...
    class ManeuvrableConsumer:
        def accept(self, maneuvrable: org.orekit.files.ccsds.ndm.cdm.Maneuvrable) -> None: ...
    class RotationOrderConsumer:
        def accept(self, rotationOrder: org.hipparchus.geometry.euclidean.threed.RotationOrder) -> None: ...
    class StringConsumer:
        def accept(self, string: str) -> None: ...
    class StringListConsumer:
        def accept(self, list: java.util.List[str]) -> None: ...
    class TimeSystemConsumer:
        def accept(self, timeSystem: org.orekit.files.ccsds.definitions.TimeSystem) -> None: ...
    class UnitListConsumer:
        def accept(self, list: java.util.List[org.orekit.utils.units.Unit]) -> None: ...
    class VectorConsumer:
        def accept(self, vector3D: org.hipparchus.geometry.euclidean.threed.Vector3D) -> None: ...

class TokenType(java.lang.Enum['TokenType']):
    START: typing.ClassVar['TokenType'] = ...
    ENTRY: typing.ClassVar['TokenType'] = ...
    STOP: typing.ClassVar['TokenType'] = ...
    RAW_LINE: typing.ClassVar['TokenType'] = ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'TokenType': ...
    @staticmethod
    def values() -> typing.List['TokenType']: ...

class XmlTokenBuilder:
    def buildTokens(self, boolean: bool, boolean2: bool, string: str, string2: str, map: typing.Union[java.util.Map[str, str], typing.Mapping[str, str]], int: int, string3: str) -> java.util.List[ParseToken]: ...

class KvnLexicalAnalyzer(LexicalAnalyzer):
    def __init__(self, dataSource: org.orekit.data.DataSource): ...
    _accept__T = typing.TypeVar('_accept__T')  # <T>
    def accept(self, messageParser: MessageParser[_accept__T]) -> _accept__T: ...

class MessageVersionXmlTokenBuilder(XmlTokenBuilder):
    def __init__(self): ...
    def buildTokens(self, boolean: bool, boolean2: bool, string: str, string2: str, map: typing.Union[java.util.Map[str, str], typing.Mapping[str, str]], int: int, string3: str) -> java.util.List[ParseToken]: ...

class PythonLexicalAnalyzer(LexicalAnalyzer):
    def __init__(self): ...
    _accept__T = typing.TypeVar('_accept__T')  # <T>
    def accept(self, messageParser: MessageParser[_accept__T]) -> _accept__T: ...
    def finalize(self) -> None: ...
    def pythonDecRef(self) -> None: ...
    @typing.overload
    def pythonExtension(self) -> int: ...
    @typing.overload
    def pythonExtension(self, long: int) -> None: ...

_PythonMessageParser__T = typing.TypeVar('_PythonMessageParser__T')  # <T>
class PythonMessageParser(MessageParser[_PythonMessageParser__T], typing.Generic[_PythonMessageParser__T]):
    def __init__(self): ...
    def build(self) -> _PythonMessageParser__T: ...
    def finalize(self) -> None: ...
    def getFileFormat(self) -> org.orekit.files.ccsds.utils.FileFormat: ...
    def getFormatVersionKey(self) -> str: ...
    def getSpecialXmlElementsBuilders(self) -> java.util.Map[str, XmlTokenBuilder]: ...
    def parseMessage(self, dataSource: org.orekit.data.DataSource) -> _PythonMessageParser__T: ...
    def process(self, parseToken: ParseToken) -> None: ...
    def pythonDecRef(self) -> None: ...
    @typing.overload
    def pythonExtension(self) -> int: ...
    @typing.overload
    def pythonExtension(self, long: int) -> None: ...
    def reset(self, fileFormat: org.orekit.files.ccsds.utils.FileFormat) -> None: ...

class PythonXmlTokenBuilder(XmlTokenBuilder):
    def __init__(self): ...
    def buildTokens(self, boolean: bool, boolean2: bool, string: str, string2: str, map: typing.Union[java.util.Map[str, str], typing.Mapping[str, str]], int: int, string3: str) -> java.util.List[ParseToken]: ...
    def finalize(self) -> None: ...
    def pythonDecRef(self) -> None: ...
    @typing.overload
    def pythonExtension(self) -> int: ...
    @typing.overload
    def pythonExtension(self, long: int) -> None: ...

class RegularXmlTokenBuilder(XmlTokenBuilder):
    def __init__(self): ...
    def buildTokens(self, boolean: bool, boolean2: bool, string: str, string2: str, map: typing.Union[java.util.Map[str, str], typing.Mapping[str, str]], int: int, string3: str) -> java.util.List[ParseToken]: ...

class UserDefinedXmlTokenBuilder(XmlTokenBuilder):
    def __init__(self): ...
    def buildTokens(self, boolean: bool, boolean2: bool, string: str, string2: str, map: typing.Union[java.util.Map[str, str], typing.Mapping[str, str]], int: int, string3: str) -> java.util.List[ParseToken]: ...

class XmlLexicalAnalyzer(LexicalAnalyzer):
    def __init__(self, dataSource: org.orekit.data.DataSource): ...
    _accept__T = typing.TypeVar('_accept__T')  # <T>
    def accept(self, messageParser: MessageParser[_accept__T]) -> _accept__T: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.orekit.files.ccsds.utils.lexical")``.

    KvnLexicalAnalyzer: typing.Type[KvnLexicalAnalyzer]
    LexicalAnalyzer: typing.Type[LexicalAnalyzer]
    LexicalAnalyzerSelector: typing.Type[LexicalAnalyzerSelector]
    MessageParser: typing.Type[MessageParser]
    MessageVersionXmlTokenBuilder: typing.Type[MessageVersionXmlTokenBuilder]
    ParseToken: typing.Type[ParseToken]
    PythonLexicalAnalyzer: typing.Type[PythonLexicalAnalyzer]
    PythonMessageParser: typing.Type[PythonMessageParser]
    PythonXmlTokenBuilder: typing.Type[PythonXmlTokenBuilder]
    RegularXmlTokenBuilder: typing.Type[RegularXmlTokenBuilder]
    TokenType: typing.Type[TokenType]
    UserDefinedXmlTokenBuilder: typing.Type[UserDefinedXmlTokenBuilder]
    XmlLexicalAnalyzer: typing.Type[XmlLexicalAnalyzer]
    XmlTokenBuilder: typing.Type[XmlTokenBuilder]
