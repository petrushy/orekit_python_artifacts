import java.io
import java.util.stream
import org.hipparchus.analysis.differentiation
import org.hipparchus.geometry.euclidean.threed
import org.orekit.rugged.los
import org.orekit.rugged.utils
import org.orekit.time
import org.orekit.utils
import typing



class LineDatation:
    def getDate(self, double: float) -> org.orekit.time.AbsoluteDate: ...
    def getLine(self, absoluteDate: org.orekit.time.AbsoluteDate) -> float: ...
    def getRate(self, double: float) -> float: ...

class LineSensor:
    def __init__(self, string: str, lineDatation: LineDatation, vector3D: org.hipparchus.geometry.euclidean.threed.Vector3D, timeDependentLOS: org.orekit.rugged.los.TimeDependentLOS): ...
    def dumpRate(self, double: float) -> None: ...
    def getDate(self, double: float) -> org.orekit.time.AbsoluteDate: ...
    @typing.overload
    def getLOS(self, absoluteDate: org.orekit.time.AbsoluteDate, double: float) -> org.hipparchus.geometry.euclidean.threed.Vector3D: ...
    @typing.overload
    def getLOS(self, absoluteDate: org.orekit.time.AbsoluteDate, int: int) -> org.hipparchus.geometry.euclidean.threed.Vector3D: ...
    _getLOSDerivatives_0__T = typing.TypeVar('_getLOSDerivatives_0__T', bound=org.hipparchus.analysis.differentiation.Derivative)  # <T>
    _getLOSDerivatives_1__T = typing.TypeVar('_getLOSDerivatives_1__T', bound=org.hipparchus.analysis.differentiation.Derivative)  # <T>
    @typing.overload
    def getLOSDerivatives(self, absoluteDate: org.orekit.time.AbsoluteDate, double: float, derivativeGenerator: org.orekit.rugged.utils.DerivativeGenerator[_getLOSDerivatives_0__T]) -> org.hipparchus.geometry.euclidean.threed.FieldVector3D[_getLOSDerivatives_0__T]: ...
    @typing.overload
    def getLOSDerivatives(self, absoluteDate: org.orekit.time.AbsoluteDate, int: int, derivativeGenerator: org.orekit.rugged.utils.DerivativeGenerator[_getLOSDerivatives_1__T]) -> org.hipparchus.geometry.euclidean.threed.FieldVector3D[_getLOSDerivatives_1__T]: ...
    def getLine(self, absoluteDate: org.orekit.time.AbsoluteDate) -> float: ...
    def getName(self) -> str: ...
    def getNbPixels(self) -> int: ...
    def getParametersDrivers(self) -> java.util.stream.Stream[org.orekit.utils.ParameterDriver]: ...
    def getPosition(self) -> org.hipparchus.geometry.euclidean.threed.Vector3D: ...
    def getRate(self, double: float) -> float: ...

class SensorMeanPlaneCrossing:
    @typing.overload
    def __init__(self, lineSensor: LineSensor, spacecraftToObservedBody: org.orekit.rugged.utils.SpacecraftToObservedBody, int: int, int2: int, boolean: bool, boolean2: bool, int3: int, double: float): ...
    @typing.overload
    def __init__(self, lineSensor: LineSensor, spacecraftToObservedBody: org.orekit.rugged.utils.SpacecraftToObservedBody, int: int, int2: int, boolean: bool, boolean2: bool, int3: int, double: float, vector3D: org.hipparchus.geometry.euclidean.threed.Vector3D, stream: java.util.stream.Stream['SensorMeanPlaneCrossing.CrossingResult']): ...
    def find(self, vector3D: org.hipparchus.geometry.euclidean.threed.Vector3D) -> 'SensorMeanPlaneCrossing.CrossingResult': ...
    def getAccuracy(self) -> float: ...
    def getCachedResults(self) -> java.util.stream.Stream['SensorMeanPlaneCrossing.CrossingResult']: ...
    def getMaxEval(self) -> int: ...
    def getMaxLine(self) -> int: ...
    def getMeanPlaneNormal(self) -> org.hipparchus.geometry.euclidean.threed.Vector3D: ...
    def getMinLine(self) -> int: ...
    def getScToBody(self) -> org.orekit.rugged.utils.SpacecraftToObservedBody: ...
    def getSensor(self) -> LineSensor: ...
    class CrossingResult:
        def __init__(self, absoluteDate: org.orekit.time.AbsoluteDate, double: float, vector3D: org.hipparchus.geometry.euclidean.threed.Vector3D, vector3D2: org.hipparchus.geometry.euclidean.threed.Vector3D, vector3D3: org.hipparchus.geometry.euclidean.threed.Vector3D): ...
        def getDate(self) -> org.orekit.time.AbsoluteDate: ...
        def getLine(self) -> float: ...
        def getTarget(self) -> org.hipparchus.geometry.euclidean.threed.Vector3D: ...
        def getTargetDirection(self) -> org.hipparchus.geometry.euclidean.threed.Vector3D: ...
        def getTargetDirectionDerivative(self) -> org.hipparchus.geometry.euclidean.threed.Vector3D: ...

class SensorPixel(java.io.Serializable):
    def __init__(self, double: float, double2: float): ...
    def getLineNumber(self) -> float: ...
    def getPixelNumber(self) -> float: ...

class SensorPixelCrossing:
    def __init__(self, lineSensor: LineSensor, vector3D: org.hipparchus.geometry.euclidean.threed.Vector3D, vector3D2: org.hipparchus.geometry.euclidean.threed.Vector3D, int: int, double: float): ...
    def locatePixel(self, absoluteDate: org.orekit.time.AbsoluteDate) -> float: ...

class LinearLineDatation(LineDatation):
    def __init__(self, absoluteDate: org.orekit.time.AbsoluteDate, double: float, double2: float): ...
    def getDate(self, double: float) -> org.orekit.time.AbsoluteDate: ...
    def getLine(self, absoluteDate: org.orekit.time.AbsoluteDate) -> float: ...
    def getRate(self, double: float) -> float: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.orekit.rugged.linesensor")``.

    LineDatation: typing.Type[LineDatation]
    LineSensor: typing.Type[LineSensor]
    LinearLineDatation: typing.Type[LinearLineDatation]
    SensorMeanPlaneCrossing: typing.Type[SensorMeanPlaneCrossing]
    SensorPixel: typing.Type[SensorPixel]
    SensorPixelCrossing: typing.Type[SensorPixelCrossing]
