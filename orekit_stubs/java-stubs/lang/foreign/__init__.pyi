import java
import java.lang
import java.lang.invoke
import java.lang.ref
import java.nio
import java.nio.file
import java.util
import java.util.function
import java.util.stream
import jpype.protocol
import typing



class Addressable:
    def address(self) -> 'MemoryAddress': ...

class FunctionDescriptor:
    def appendArgumentLayouts(self, *memoryLayout: 'MemoryLayout') -> 'FunctionDescriptor': ...
    def argumentLayouts(self) -> java.util.List['MemoryLayout']: ...
    def asVariadic(self, *memoryLayout: 'MemoryLayout') -> 'FunctionDescriptor': ...
    def changeReturnLayout(self, memoryLayout: 'MemoryLayout') -> 'FunctionDescriptor': ...
    def dropReturnLayout(self) -> 'FunctionDescriptor': ...
    def equals(self, object: typing.Any) -> bool: ...
    def firstVariadicArgumentIndex(self) -> int: ...
    def hashCode(self) -> int: ...
    def insertArgumentLayouts(self, int: int, *memoryLayout: 'MemoryLayout') -> 'FunctionDescriptor': ...
    @staticmethod
    def of(memoryLayout: 'MemoryLayout', *memoryLayout2: 'MemoryLayout') -> 'FunctionDescriptor': ...
    @staticmethod
    def ofVoid(*memoryLayout: 'MemoryLayout') -> 'FunctionDescriptor': ...
    def returnLayout(self) -> java.util.Optional['MemoryLayout']: ...
    def toString(self) -> str: ...

class Linker:
    def defaultLookup(self) -> 'SymbolLookup': ...
    @typing.overload
    def downcallHandle(self, functionDescriptor: FunctionDescriptor) -> java.lang.invoke.MethodHandle: ...
    @typing.overload
    def downcallHandle(self, addressable: Addressable, functionDescriptor: FunctionDescriptor) -> java.lang.invoke.MethodHandle: ...
    @staticmethod
    def downcallType(functionDescriptor: FunctionDescriptor) -> java.lang.invoke.MethodType: ...
    @staticmethod
    def nativeLinker() -> 'Linker': ...
    def upcallStub(self, methodHandle: java.lang.invoke.MethodHandle, functionDescriptor: FunctionDescriptor, memorySession: 'MemorySession') -> 'MemorySegment': ...
    @staticmethod
    def upcallType(functionDescriptor: FunctionDescriptor) -> java.lang.invoke.MethodType: ...

class MemoryLayout:
    def bitAlignment(self) -> int: ...
    def bitOffset(self, *pathElement: 'MemoryLayout.PathElement') -> int: ...
    def bitOffsetHandle(self, *pathElement: 'MemoryLayout.PathElement') -> java.lang.invoke.MethodHandle: ...
    def bitSize(self) -> int: ...
    def byteAlignment(self) -> int: ...
    def byteOffset(self, *pathElement: 'MemoryLayout.PathElement') -> int: ...
    def byteOffsetHandle(self, *pathElement: 'MemoryLayout.PathElement') -> java.lang.invoke.MethodHandle: ...
    def byteSize(self) -> int: ...
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def isPadding(self) -> bool: ...
    def name(self) -> java.util.Optional[str]: ...
    @staticmethod
    def paddingLayout(long: int) -> 'MemoryLayout': ...
    def select(self, *pathElement: 'MemoryLayout.PathElement') -> 'MemoryLayout': ...
    @staticmethod
    def sequenceLayout(long: int, memoryLayout: 'MemoryLayout') -> 'SequenceLayout': ...
    def sliceHandle(self, *pathElement: 'MemoryLayout.PathElement') -> java.lang.invoke.MethodHandle: ...
    @staticmethod
    def structLayout(*memoryLayout: 'MemoryLayout') -> 'GroupLayout': ...
    def toString(self) -> str: ...
    @staticmethod
    def unionLayout(*memoryLayout: 'MemoryLayout') -> 'GroupLayout': ...
    @staticmethod
    def valueLayout(class_: typing.Type[typing.Any], byteOrder: java.nio.ByteOrder) -> 'ValueLayout': ...
    def varHandle(self, *pathElement: 'MemoryLayout.PathElement') -> java.lang.invoke.VarHandle: ...
    def withBitAlignment(self, long: int) -> 'MemoryLayout': ...
    def withName(self, string: str) -> 'MemoryLayout': ...
    class PathElement:
        @staticmethod
        def groupElement(string: str) -> 'MemoryLayout.PathElement': ...
        @typing.overload
        @staticmethod
        def sequenceElement() -> 'MemoryLayout.PathElement': ...
        @typing.overload
        @staticmethod
        def sequenceElement(long: int) -> 'MemoryLayout.PathElement': ...
        @typing.overload
        @staticmethod
        def sequenceElement(long: int, long2: int) -> 'MemoryLayout.PathElement': ...

class SegmentAllocator:
    @typing.overload
    def allocate(self, long: int, long2: int) -> 'MemorySegment': ...
    @typing.overload
    def allocate(self, memoryLayout: MemoryLayout) -> 'MemorySegment': ...
    @typing.overload
    def allocate(self, ofAddress: 'ValueLayout.OfAddress', addressable: Addressable) -> 'MemorySegment': ...
    @typing.overload
    def allocate(self, ofByte: 'ValueLayout.OfByte', byte: int) -> 'MemorySegment': ...
    @typing.overload
    def allocate(self, ofChar: 'ValueLayout.OfChar', char: str) -> 'MemorySegment': ...
    @typing.overload
    def allocate(self, ofDouble: 'ValueLayout.OfDouble', double: float) -> 'MemorySegment': ...
    @typing.overload
    def allocate(self, ofFloat: 'ValueLayout.OfFloat', float: float) -> 'MemorySegment': ...
    @typing.overload
    def allocate(self, ofInt: 'ValueLayout.OfInt', int: int) -> 'MemorySegment': ...
    @typing.overload
    def allocate(self, ofLong: 'ValueLayout.OfLong', long: int) -> 'MemorySegment': ...
    @typing.overload
    def allocate(self, ofShort: 'ValueLayout.OfShort', short: int) -> 'MemorySegment': ...
    @typing.overload
    def allocate(self, long: int) -> 'MemorySegment': ...
    @typing.overload
    def allocateArray(self, memoryLayout: MemoryLayout, long: int) -> 'MemorySegment': ...
    @typing.overload
    def allocateArray(self, ofByte: 'ValueLayout.OfByte', *byte: int) -> 'MemorySegment': ...
    @typing.overload
    def allocateArray(self, ofChar: 'ValueLayout.OfChar', *char: str) -> 'MemorySegment': ...
    @typing.overload
    def allocateArray(self, ofDouble: 'ValueLayout.OfDouble', *double: float) -> 'MemorySegment': ...
    @typing.overload
    def allocateArray(self, ofFloat: 'ValueLayout.OfFloat', *float: float) -> 'MemorySegment': ...
    @typing.overload
    def allocateArray(self, ofInt: 'ValueLayout.OfInt', *int: int) -> 'MemorySegment': ...
    @typing.overload
    def allocateArray(self, ofLong: 'ValueLayout.OfLong', *long: int) -> 'MemorySegment': ...
    @typing.overload
    def allocateArray(self, ofShort: 'ValueLayout.OfShort', *short: int) -> 'MemorySegment': ...
    def allocateUtf8String(self, string: str) -> 'MemorySegment': ...
    @staticmethod
    def implicitAllocator() -> 'SegmentAllocator': ...
    @typing.overload
    @staticmethod
    def newNativeArena(memorySession: 'MemorySession') -> 'SegmentAllocator': ...
    @typing.overload
    @staticmethod
    def newNativeArena(long: int, memorySession: 'MemorySession') -> 'SegmentAllocator': ...
    @typing.overload
    @staticmethod
    def newNativeArena(long: int, long2: int, memorySession: 'MemorySession') -> 'SegmentAllocator': ...
    @staticmethod
    def prefixAllocator(memorySegment: 'MemorySegment') -> 'SegmentAllocator': ...

class SymbolLookup:
    @typing.overload
    @staticmethod
    def libraryLookup(string: str, memorySession: 'MemorySession') -> 'SymbolLookup': ...
    @typing.overload
    @staticmethod
    def libraryLookup(path: typing.Union[java.nio.file.Path, jpype.protocol.SupportsPath], memorySession: 'MemorySession') -> 'SymbolLookup': ...
    @staticmethod
    def loaderLookup() -> 'SymbolLookup': ...
    def lookup(self, string: str) -> java.util.Optional['MemorySegment']: ...

class MemoryAddress(Addressable):
    NULL: typing.ClassVar['MemoryAddress'] = ...
    def addOffset(self, long: int) -> 'MemoryAddress': ...
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    def get(self, ofBoolean: 'ValueLayout.OfBoolean', long: int) -> bool: ...
    @typing.overload
    def get(self, ofByte: 'ValueLayout.OfByte', long: int) -> int: ...
    @typing.overload
    def get(self, ofChar: 'ValueLayout.OfChar', long: int) -> str: ...
    @typing.overload
    def get(self, ofDouble: 'ValueLayout.OfDouble', long: int) -> float: ...
    @typing.overload
    def get(self, ofFloat: 'ValueLayout.OfFloat', long: int) -> float: ...
    @typing.overload
    def get(self, ofInt: 'ValueLayout.OfInt', long: int) -> int: ...
    @typing.overload
    def get(self, ofAddress: 'ValueLayout.OfAddress', long: int) -> 'MemoryAddress': ...
    @typing.overload
    def get(self, ofLong: 'ValueLayout.OfLong', long: int) -> int: ...
    @typing.overload
    def get(self, ofShort: 'ValueLayout.OfShort', long: int) -> int: ...
    @typing.overload
    def getAtIndex(self, ofChar: 'ValueLayout.OfChar', long: int) -> str: ...
    @typing.overload
    def getAtIndex(self, ofDouble: 'ValueLayout.OfDouble', long: int) -> float: ...
    @typing.overload
    def getAtIndex(self, ofFloat: 'ValueLayout.OfFloat', long: int) -> float: ...
    @typing.overload
    def getAtIndex(self, ofInt: 'ValueLayout.OfInt', long: int) -> int: ...
    @typing.overload
    def getAtIndex(self, ofAddress: 'ValueLayout.OfAddress', long: int) -> 'MemoryAddress': ...
    @typing.overload
    def getAtIndex(self, ofLong: 'ValueLayout.OfLong', long: int) -> int: ...
    @typing.overload
    def getAtIndex(self, ofShort: 'ValueLayout.OfShort', long: int) -> int: ...
    def getUtf8String(self, long: int) -> str: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def ofLong(long: int) -> 'MemoryAddress': ...
    @typing.overload
    def set(self, ofAddress: 'ValueLayout.OfAddress', long: int, addressable: Addressable) -> None: ...
    @typing.overload
    def set(self, ofBoolean: 'ValueLayout.OfBoolean', long: int, boolean: bool) -> None: ...
    @typing.overload
    def set(self, ofByte: 'ValueLayout.OfByte', long: int, byte: int) -> None: ...
    @typing.overload
    def set(self, ofChar: 'ValueLayout.OfChar', long: int, char: str) -> None: ...
    @typing.overload
    def set(self, ofDouble: 'ValueLayout.OfDouble', long: int, double: float) -> None: ...
    @typing.overload
    def set(self, ofFloat: 'ValueLayout.OfFloat', long: int, float: float) -> None: ...
    @typing.overload
    def set(self, ofInt: 'ValueLayout.OfInt', long: int, int: int) -> None: ...
    @typing.overload
    def set(self, ofLong: 'ValueLayout.OfLong', long: int, long2: int) -> None: ...
    @typing.overload
    def set(self, ofShort: 'ValueLayout.OfShort', long: int, short: int) -> None: ...
    @typing.overload
    def setAtIndex(self, ofAddress: 'ValueLayout.OfAddress', long: int, addressable: Addressable) -> None: ...
    @typing.overload
    def setAtIndex(self, ofChar: 'ValueLayout.OfChar', long: int, char: str) -> None: ...
    @typing.overload
    def setAtIndex(self, ofDouble: 'ValueLayout.OfDouble', long: int, double: float) -> None: ...
    @typing.overload
    def setAtIndex(self, ofFloat: 'ValueLayout.OfFloat', long: int, float: float) -> None: ...
    @typing.overload
    def setAtIndex(self, ofInt: 'ValueLayout.OfInt', long: int, int: int) -> None: ...
    @typing.overload
    def setAtIndex(self, ofLong: 'ValueLayout.OfLong', long: int, long2: int) -> None: ...
    @typing.overload
    def setAtIndex(self, ofShort: 'ValueLayout.OfShort', long: int, short: int) -> None: ...
    def setUtf8String(self, long: int, string: str) -> None: ...
    def toRawLongValue(self) -> int: ...

class MemorySegment(Addressable):
    def address(self) -> MemoryAddress: ...
    @typing.overload
    @staticmethod
    def allocateNative(memoryLayout: MemoryLayout, memorySession: 'MemorySession') -> 'MemorySegment': ...
    @typing.overload
    @staticmethod
    def allocateNative(long: int, memorySession: 'MemorySession') -> 'MemorySegment': ...
    @typing.overload
    @staticmethod
    def allocateNative(long: int, long2: int, memorySession: 'MemorySession') -> 'MemorySegment': ...
    def asByteBuffer(self) -> java.nio.ByteBuffer: ...
    def asOverlappingSlice(self, memorySegment: 'MemorySegment') -> java.util.Optional['MemorySegment']: ...
    def asReadOnly(self) -> 'MemorySegment': ...
    @typing.overload
    def asSlice(self, long: int, long2: int) -> 'MemorySegment': ...
    @typing.overload
    def asSlice(self, long: int) -> 'MemorySegment': ...
    def byteSize(self) -> int: ...
    @typing.overload
    @staticmethod
    def copy(object: typing.Any, int: int, memorySegment: 'MemorySegment', valueLayout: 'ValueLayout', long: int, int2: int) -> None: ...
    @typing.overload
    @staticmethod
    def copy(memorySegment: 'MemorySegment', valueLayout: 'ValueLayout', long: int, object: typing.Any, int: int, int2: int) -> None: ...
    @typing.overload
    @staticmethod
    def copy(memorySegment: 'MemorySegment', valueLayout: 'ValueLayout', long: int, memorySegment2: 'MemorySegment', valueLayout2: 'ValueLayout', long2: int, long3: int) -> None: ...
    @typing.overload
    @staticmethod
    def copy(memorySegment: 'MemorySegment', long: int, memorySegment2: 'MemorySegment', long2: int, long3: int) -> None: ...
    def copyFrom(self, memorySegment: 'MemorySegment') -> 'MemorySegment': ...
    def elements(self, memoryLayout: MemoryLayout) -> java.util.stream.Stream['MemorySegment']: ...
    def equals(self, object: typing.Any) -> bool: ...
    def fill(self, byte: int) -> 'MemorySegment': ...
    def force(self) -> None: ...
    @typing.overload
    def get(self, ofBoolean: 'ValueLayout.OfBoolean', long: int) -> bool: ...
    @typing.overload
    def get(self, ofByte: 'ValueLayout.OfByte', long: int) -> int: ...
    @typing.overload
    def get(self, ofChar: 'ValueLayout.OfChar', long: int) -> str: ...
    @typing.overload
    def get(self, ofDouble: 'ValueLayout.OfDouble', long: int) -> float: ...
    @typing.overload
    def get(self, ofFloat: 'ValueLayout.OfFloat', long: int) -> float: ...
    @typing.overload
    def get(self, ofInt: 'ValueLayout.OfInt', long: int) -> int: ...
    @typing.overload
    def get(self, ofAddress: 'ValueLayout.OfAddress', long: int) -> MemoryAddress: ...
    @typing.overload
    def get(self, ofLong: 'ValueLayout.OfLong', long: int) -> int: ...
    @typing.overload
    def get(self, ofShort: 'ValueLayout.OfShort', long: int) -> int: ...
    @typing.overload
    def getAtIndex(self, ofChar: 'ValueLayout.OfChar', long: int) -> str: ...
    @typing.overload
    def getAtIndex(self, ofDouble: 'ValueLayout.OfDouble', long: int) -> float: ...
    @typing.overload
    def getAtIndex(self, ofFloat: 'ValueLayout.OfFloat', long: int) -> float: ...
    @typing.overload
    def getAtIndex(self, ofInt: 'ValueLayout.OfInt', long: int) -> int: ...
    @typing.overload
    def getAtIndex(self, ofAddress: 'ValueLayout.OfAddress', long: int) -> MemoryAddress: ...
    @typing.overload
    def getAtIndex(self, ofLong: 'ValueLayout.OfLong', long: int) -> int: ...
    @typing.overload
    def getAtIndex(self, ofShort: 'ValueLayout.OfShort', long: int) -> int: ...
    def getUtf8String(self, long: int) -> str: ...
    def hashCode(self) -> int: ...
    def isLoaded(self) -> bool: ...
    def isMapped(self) -> bool: ...
    def isNative(self) -> bool: ...
    def isReadOnly(self) -> bool: ...
    def load(self) -> None: ...
    def mismatch(self, memorySegment: 'MemorySegment') -> int: ...
    @staticmethod
    def ofAddress(memoryAddress: MemoryAddress, long: int, memorySession: 'MemorySession') -> 'MemorySegment': ...
    @typing.overload
    @staticmethod
    def ofArray(byteArray: typing.List[int]) -> 'MemorySegment': ...
    @typing.overload
    @staticmethod
    def ofArray(charArray: typing.List[str]) -> 'MemorySegment': ...
    @typing.overload
    @staticmethod
    def ofArray(doubleArray: typing.List[float]) -> 'MemorySegment': ...
    @typing.overload
    @staticmethod
    def ofArray(floatArray: typing.List[float]) -> 'MemorySegment': ...
    @typing.overload
    @staticmethod
    def ofArray(intArray: typing.List[int]) -> 'MemorySegment': ...
    @typing.overload
    @staticmethod
    def ofArray(longArray: typing.List[int]) -> 'MemorySegment': ...
    @typing.overload
    @staticmethod
    def ofArray(shortArray: typing.List[int]) -> 'MemorySegment': ...
    @staticmethod
    def ofBuffer(buffer: java.nio.Buffer) -> 'MemorySegment': ...
    def segmentOffset(self, memorySegment: 'MemorySegment') -> int: ...
    def session(self) -> 'MemorySession': ...
    @typing.overload
    def set(self, ofAddress: 'ValueLayout.OfAddress', long: int, addressable: Addressable) -> None: ...
    @typing.overload
    def set(self, ofBoolean: 'ValueLayout.OfBoolean', long: int, boolean: bool) -> None: ...
    @typing.overload
    def set(self, ofByte: 'ValueLayout.OfByte', long: int, byte: int) -> None: ...
    @typing.overload
    def set(self, ofChar: 'ValueLayout.OfChar', long: int, char: str) -> None: ...
    @typing.overload
    def set(self, ofDouble: 'ValueLayout.OfDouble', long: int, double: float) -> None: ...
    @typing.overload
    def set(self, ofFloat: 'ValueLayout.OfFloat', long: int, float: float) -> None: ...
    @typing.overload
    def set(self, ofInt: 'ValueLayout.OfInt', long: int, int: int) -> None: ...
    @typing.overload
    def set(self, ofLong: 'ValueLayout.OfLong', long: int, long2: int) -> None: ...
    @typing.overload
    def set(self, ofShort: 'ValueLayout.OfShort', long: int, short: int) -> None: ...
    @typing.overload
    def setAtIndex(self, ofAddress: 'ValueLayout.OfAddress', long: int, addressable: Addressable) -> None: ...
    @typing.overload
    def setAtIndex(self, ofChar: 'ValueLayout.OfChar', long: int, char: str) -> None: ...
    @typing.overload
    def setAtIndex(self, ofDouble: 'ValueLayout.OfDouble', long: int, double: float) -> None: ...
    @typing.overload
    def setAtIndex(self, ofFloat: 'ValueLayout.OfFloat', long: int, float: float) -> None: ...
    @typing.overload
    def setAtIndex(self, ofInt: 'ValueLayout.OfInt', long: int, int: int) -> None: ...
    @typing.overload
    def setAtIndex(self, ofLong: 'ValueLayout.OfLong', long: int, long2: int) -> None: ...
    @typing.overload
    def setAtIndex(self, ofShort: 'ValueLayout.OfShort', long: int, short: int) -> None: ...
    def setUtf8String(self, long: int, string: str) -> None: ...
    def spliterator(self, memoryLayout: MemoryLayout) -> java.util.Spliterator['MemorySegment']: ...
    @typing.overload
    def toArray(self, ofByte: 'ValueLayout.OfByte') -> typing.List[int]: ...
    @typing.overload
    def toArray(self, ofChar: 'ValueLayout.OfChar') -> typing.List[str]: ...
    @typing.overload
    def toArray(self, ofDouble: 'ValueLayout.OfDouble') -> typing.List[float]: ...
    @typing.overload
    def toArray(self, ofFloat: 'ValueLayout.OfFloat') -> typing.List[float]: ...
    @typing.overload
    def toArray(self, ofInt: 'ValueLayout.OfInt') -> typing.List[int]: ...
    @typing.overload
    def toArray(self, ofLong: 'ValueLayout.OfLong') -> typing.List[int]: ...
    @typing.overload
    def toArray(self, ofShort: 'ValueLayout.OfShort') -> typing.List[int]: ...
    def unload(self) -> None: ...

class MemorySession(java.lang.AutoCloseable, SegmentAllocator):
    def addCloseAction(self, runnable: typing.Union[java.lang.Runnable, typing.Callable]) -> None: ...
    @typing.overload
    def allocate(self, long: int, long2: int) -> MemorySegment: ...
    @typing.overload
    def allocate(self, memoryLayout: MemoryLayout) -> MemorySegment: ...
    @typing.overload
    def allocate(self, ofAddress: 'ValueLayout.OfAddress', addressable: Addressable) -> MemorySegment: ...
    @typing.overload
    def allocate(self, ofByte: 'ValueLayout.OfByte', byte: int) -> MemorySegment: ...
    @typing.overload
    def allocate(self, ofChar: 'ValueLayout.OfChar', char: str) -> MemorySegment: ...
    @typing.overload
    def allocate(self, ofDouble: 'ValueLayout.OfDouble', double: float) -> MemorySegment: ...
    @typing.overload
    def allocate(self, ofFloat: 'ValueLayout.OfFloat', float: float) -> MemorySegment: ...
    @typing.overload
    def allocate(self, ofInt: 'ValueLayout.OfInt', int: int) -> MemorySegment: ...
    @typing.overload
    def allocate(self, ofLong: 'ValueLayout.OfLong', long: int) -> MemorySegment: ...
    @typing.overload
    def allocate(self, ofShort: 'ValueLayout.OfShort', short: int) -> MemorySegment: ...
    @typing.overload
    def allocate(self, long: int) -> MemorySegment: ...
    def asNonCloseable(self) -> 'MemorySession': ...
    def close(self) -> None: ...
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def isAlive(self) -> bool: ...
    def isCloseable(self) -> bool: ...
    @typing.overload
    @staticmethod
    def openConfined() -> 'MemorySession': ...
    @typing.overload
    @staticmethod
    def openConfined(cleaner: java.lang.ref.Cleaner) -> 'MemorySession': ...
    @staticmethod
    def openImplicit() -> 'MemorySession': ...
    @typing.overload
    @staticmethod
    def openShared() -> 'MemorySession': ...
    @typing.overload
    @staticmethod
    def openShared(cleaner: java.lang.ref.Cleaner) -> 'MemorySession': ...
    def ownerThread(self) -> java.lang.Thread: ...
    def whileAlive(self, runnable: typing.Union[java.lang.Runnable, typing.Callable]) -> None: ...

class VaList(Addressable):
    def address(self) -> MemoryAddress: ...
    def copy(self) -> 'VaList': ...
    @staticmethod
    def empty() -> 'VaList': ...
    @staticmethod
    def make(consumer: typing.Union[java.util.function.Consumer['VaList.Builder'], typing.Callable[['VaList.Builder'], None]], memorySession: MemorySession) -> 'VaList': ...
    @typing.overload
    def nextVarg(self, ofDouble: 'ValueLayout.OfDouble') -> float: ...
    @typing.overload
    def nextVarg(self, ofInt: 'ValueLayout.OfInt') -> int: ...
    @typing.overload
    def nextVarg(self, ofAddress: 'ValueLayout.OfAddress') -> MemoryAddress: ...
    @typing.overload
    def nextVarg(self, groupLayout: 'GroupLayout', segmentAllocator: typing.Union[SegmentAllocator, typing.Callable]) -> MemorySegment: ...
    @typing.overload
    def nextVarg(self, ofLong: 'ValueLayout.OfLong') -> int: ...
    @staticmethod
    def ofAddress(memoryAddress: MemoryAddress, memorySession: MemorySession) -> 'VaList': ...
    def session(self) -> MemorySession: ...
    def skip(self, *memoryLayout: MemoryLayout) -> None: ...
    class Builder:
        @typing.overload
        def addVarg(self, groupLayout: 'GroupLayout', memorySegment: MemorySegment) -> 'VaList.Builder': ...
        @typing.overload
        def addVarg(self, ofAddress: 'ValueLayout.OfAddress', addressable: Addressable) -> 'VaList.Builder': ...
        @typing.overload
        def addVarg(self, ofDouble: 'ValueLayout.OfDouble', double: float) -> 'VaList.Builder': ...
        @typing.overload
        def addVarg(self, ofInt: 'ValueLayout.OfInt', int: int) -> 'VaList.Builder': ...
        @typing.overload
        def addVarg(self, ofLong: 'ValueLayout.OfLong', long: int) -> 'VaList.Builder': ...

class GroupLayout(java.lang.foreign.AbstractLayout, MemoryLayout):
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def isStruct(self) -> bool: ...
    def isUnion(self) -> bool: ...
    def memberLayouts(self) -> java.util.List[MemoryLayout]: ...
    def toString(self) -> str: ...
    def withBitAlignment(self, long: int) -> 'GroupLayout': ...
    def withName(self, string: str) -> 'GroupLayout': ...

class SequenceLayout(java.lang.foreign.AbstractLayout, MemoryLayout):
    def elementCount(self) -> int: ...
    def elementLayout(self) -> MemoryLayout: ...
    def equals(self, object: typing.Any) -> bool: ...
    def flatten(self) -> 'SequenceLayout': ...
    def hashCode(self) -> int: ...
    def reshape(self, *long: int) -> 'SequenceLayout': ...
    def toString(self) -> str: ...
    def withBitAlignment(self, long: int) -> 'SequenceLayout': ...
    def withElementCount(self, long: int) -> 'SequenceLayout': ...
    def withName(self, string: str) -> 'SequenceLayout': ...

class ValueLayout(java.lang.foreign.AbstractLayout, MemoryLayout):
    ADDRESS: typing.ClassVar['ValueLayout.OfAddress'] = ...
    JAVA_BYTE: typing.ClassVar['ValueLayout.OfByte'] = ...
    JAVA_BOOLEAN: typing.ClassVar['ValueLayout.OfBoolean'] = ...
    JAVA_CHAR: typing.ClassVar['ValueLayout.OfChar'] = ...
    JAVA_SHORT: typing.ClassVar['ValueLayout.OfShort'] = ...
    JAVA_INT: typing.ClassVar['ValueLayout.OfInt'] = ...
    JAVA_LONG: typing.ClassVar['ValueLayout.OfLong'] = ...
    JAVA_FLOAT: typing.ClassVar['ValueLayout.OfFloat'] = ...
    JAVA_DOUBLE: typing.ClassVar['ValueLayout.OfDouble'] = ...
    def arrayElementVarHandle(self, *int: int) -> java.lang.invoke.VarHandle: ...
    def carrier(self) -> typing.Type[typing.Any]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def order(self) -> java.nio.ByteOrder: ...
    def toString(self) -> str: ...
    def withBitAlignment(self, long: int) -> 'ValueLayout': ...
    def withName(self, string: str) -> 'ValueLayout': ...
    def withOrder(self, byteOrder: java.nio.ByteOrder) -> 'ValueLayout': ...
    class OfAddress(java.lang.foreign.ValueLayout):
        def withBitAlignment(self, long: int) -> 'ValueLayout.OfAddress': ...
        def withName(self, string: str) -> 'ValueLayout.OfAddress': ...
        def withOrder(self, byteOrder: java.nio.ByteOrder) -> 'ValueLayout.OfAddress': ...
    class OfBoolean(java.lang.foreign.ValueLayout):
        def withBitAlignment(self, long: int) -> 'ValueLayout.OfBoolean': ...
        def withName(self, string: str) -> 'ValueLayout.OfBoolean': ...
        def withOrder(self, byteOrder: java.nio.ByteOrder) -> 'ValueLayout.OfBoolean': ...
    class OfByte(java.lang.foreign.ValueLayout):
        def withBitAlignment(self, long: int) -> 'ValueLayout.OfByte': ...
        def withName(self, string: str) -> 'ValueLayout.OfByte': ...
        def withOrder(self, byteOrder: java.nio.ByteOrder) -> 'ValueLayout.OfByte': ...
    class OfChar(java.lang.foreign.ValueLayout):
        def withBitAlignment(self, long: int) -> 'ValueLayout.OfChar': ...
        def withName(self, string: str) -> 'ValueLayout.OfChar': ...
        def withOrder(self, byteOrder: java.nio.ByteOrder) -> 'ValueLayout.OfChar': ...
    class OfDouble(java.lang.foreign.ValueLayout):
        def withBitAlignment(self, long: int) -> 'ValueLayout.OfDouble': ...
        def withName(self, string: str) -> 'ValueLayout.OfDouble': ...
        def withOrder(self, byteOrder: java.nio.ByteOrder) -> 'ValueLayout.OfDouble': ...
    class OfFloat(java.lang.foreign.ValueLayout):
        def withBitAlignment(self, long: int) -> 'ValueLayout.OfFloat': ...
        def withName(self, string: str) -> 'ValueLayout.OfFloat': ...
        def withOrder(self, byteOrder: java.nio.ByteOrder) -> 'ValueLayout.OfFloat': ...
    class OfInt(java.lang.foreign.ValueLayout):
        def withBitAlignment(self, long: int) -> 'ValueLayout.OfInt': ...
        def withName(self, string: str) -> 'ValueLayout.OfInt': ...
        def withOrder(self, byteOrder: java.nio.ByteOrder) -> 'ValueLayout.OfInt': ...
    class OfLong(java.lang.foreign.ValueLayout):
        def withBitAlignment(self, long: int) -> 'ValueLayout.OfLong': ...
        def withName(self, string: str) -> 'ValueLayout.OfLong': ...
        def withOrder(self, byteOrder: java.nio.ByteOrder) -> 'ValueLayout.OfLong': ...
    class OfShort(java.lang.foreign.ValueLayout):
        def withBitAlignment(self, long: int) -> 'ValueLayout.OfShort': ...
        def withName(self, string: str) -> 'ValueLayout.OfShort': ...
        def withOrder(self, byteOrder: java.nio.ByteOrder) -> 'ValueLayout.OfShort': ...

class AbstractLayout: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("java.lang.foreign")``.

    AbstractLayout: typing.Type[AbstractLayout]
    Addressable: typing.Type[Addressable]
    FunctionDescriptor: typing.Type[FunctionDescriptor]
    GroupLayout: typing.Type[GroupLayout]
    Linker: typing.Type[Linker]
    MemoryAddress: typing.Type[MemoryAddress]
    MemoryLayout: typing.Type[MemoryLayout]
    MemorySegment: typing.Type[MemorySegment]
    MemorySession: typing.Type[MemorySession]
    SegmentAllocator: typing.Type[SegmentAllocator]
    SequenceLayout: typing.Type[SequenceLayout]
    SymbolLookup: typing.Type[SymbolLookup]
    VaList: typing.Type[VaList]
    ValueLayout: typing.Type[ValueLayout]
