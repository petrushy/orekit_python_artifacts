import java.io
import java.lang
import java.lang.reflect
import java.util
import typing



class CallSite:
    def dynamicInvoker(self) -> 'MethodHandle': ...
    def getTarget(self) -> 'MethodHandle': ...
    def setTarget(self, methodHandle: 'MethodHandle') -> None: ...
    def type(self) -> 'MethodType': ...

class LambdaConversionException(java.lang.Exception):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, throwable: java.lang.Throwable): ...
    @typing.overload
    def __init__(self, string: str, throwable: java.lang.Throwable, boolean: bool, boolean2: bool): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

class LambdaMetafactory:
    FLAG_SERIALIZABLE: typing.ClassVar[int] = ...
    FLAG_MARKERS: typing.ClassVar[int] = ...
    FLAG_BRIDGES: typing.ClassVar[int] = ...
    def __init__(self): ...
    @staticmethod
    def altMetafactory(lookup: 'MethodHandles.Lookup', string: str, methodType: 'MethodType', *object: typing.Any) -> CallSite: ...
    @staticmethod
    def metafactory(lookup: 'MethodHandles.Lookup', string: str, methodType: 'MethodType', methodType2: 'MethodType', methodHandle: 'MethodHandle', methodType3: 'MethodType') -> CallSite: ...

class MethodHandle:
    def asCollector(self, class_: typing.Type[typing.Any], int: int) -> 'MethodHandle': ...
    def asFixedArity(self) -> 'MethodHandle': ...
    def asSpreader(self, class_: typing.Type[typing.Any], int: int) -> 'MethodHandle': ...
    def asType(self, methodType: 'MethodType') -> 'MethodHandle': ...
    def asVarargsCollector(self, class_: typing.Type[typing.Any]) -> 'MethodHandle': ...
    def bindTo(self, object: typing.Any) -> 'MethodHandle': ...
    def invoke(self, *object: typing.Any) -> typing.Any: ...
    def invokeExact(self, *object: typing.Any) -> typing.Any: ...
    @typing.overload
    def invokeWithArguments(self, *object: typing.Any) -> typing.Any: ...
    @typing.overload
    def invokeWithArguments(self, list: java.util.List[typing.Any]) -> typing.Any: ...
    def isVarargsCollector(self) -> bool: ...
    def toString(self) -> str: ...
    def type(self) -> 'MethodType': ...

class MethodHandleInfo:
    REF_getField: typing.ClassVar[int] = ...
    REF_getStatic: typing.ClassVar[int] = ...
    REF_putField: typing.ClassVar[int] = ...
    REF_putStatic: typing.ClassVar[int] = ...
    REF_invokeVirtual: typing.ClassVar[int] = ...
    REF_invokeStatic: typing.ClassVar[int] = ...
    REF_invokeSpecial: typing.ClassVar[int] = ...
    REF_newInvokeSpecial: typing.ClassVar[int] = ...
    REF_invokeInterface: typing.ClassVar[int] = ...
    def getDeclaringClass(self) -> typing.Type[typing.Any]: ...
    def getMethodType(self) -> 'MethodType': ...
    def getModifiers(self) -> int: ...
    def getName(self) -> str: ...
    def getReferenceKind(self) -> int: ...
    def isVarArgs(self) -> bool: ...
    @staticmethod
    def referenceKindToString(int: int) -> str: ...
    _reflectAs__T = typing.TypeVar('_reflectAs__T', bound=java.lang.reflect.Member)  # <T>
    def reflectAs(self, class_: typing.Type[_reflectAs__T], lookup: 'MethodHandles.Lookup') -> _reflectAs__T: ...
    @staticmethod
    def toString(int: int, class_: typing.Type[typing.Any], string: str, methodType: 'MethodType') -> str: ...

class MethodHandleProxies:
    _asInterfaceInstance__T = typing.TypeVar('_asInterfaceInstance__T')  # <T>
    @staticmethod
    def asInterfaceInstance(class_: typing.Type[_asInterfaceInstance__T], methodHandle: MethodHandle) -> _asInterfaceInstance__T: ...
    @staticmethod
    def isWrapperInstance(object: typing.Any) -> bool: ...
    @staticmethod
    def wrapperInstanceTarget(object: typing.Any) -> MethodHandle: ...
    @staticmethod
    def wrapperInstanceType(object: typing.Any) -> typing.Type[typing.Any]: ...

class MethodHandles:
    @staticmethod
    def arrayElementGetter(class_: typing.Type[typing.Any]) -> MethodHandle: ...
    @staticmethod
    def arrayElementSetter(class_: typing.Type[typing.Any]) -> MethodHandle: ...
    @staticmethod
    def catchException(methodHandle: MethodHandle, class_: typing.Type[java.lang.Throwable], methodHandle2: MethodHandle) -> MethodHandle: ...
    @staticmethod
    def collectArguments(methodHandle: MethodHandle, int: int, methodHandle2: MethodHandle) -> MethodHandle: ...
    @staticmethod
    def constant(class_: typing.Type[typing.Any], object: typing.Any) -> MethodHandle: ...
    @typing.overload
    @staticmethod
    def dropArguments(methodHandle: MethodHandle, int: int, *class_: typing.Type[typing.Any]) -> MethodHandle: ...
    @typing.overload
    @staticmethod
    def dropArguments(methodHandle: MethodHandle, int: int, list: java.util.List[typing.Type[typing.Any]]) -> MethodHandle: ...
    @staticmethod
    def exactInvoker(methodType: 'MethodType') -> MethodHandle: ...
    @staticmethod
    def explicitCastArguments(methodHandle: MethodHandle, methodType: 'MethodType') -> MethodHandle: ...
    @staticmethod
    def filterArguments(methodHandle: MethodHandle, int: int, *methodHandle2: MethodHandle) -> MethodHandle: ...
    @staticmethod
    def filterReturnValue(methodHandle: MethodHandle, methodHandle2: MethodHandle) -> MethodHandle: ...
    @staticmethod
    def foldArguments(methodHandle: MethodHandle, methodHandle2: MethodHandle) -> MethodHandle: ...
    @staticmethod
    def guardWithTest(methodHandle: MethodHandle, methodHandle2: MethodHandle, methodHandle3: MethodHandle) -> MethodHandle: ...
    @staticmethod
    def identity(class_: typing.Type[typing.Any]) -> MethodHandle: ...
    @staticmethod
    def insertArguments(methodHandle: MethodHandle, int: int, *object: typing.Any) -> MethodHandle: ...
    @staticmethod
    def invoker(methodType: 'MethodType') -> MethodHandle: ...
    @staticmethod
    def lookup() -> 'MethodHandles.Lookup': ...
    @staticmethod
    def permuteArguments(methodHandle: MethodHandle, methodType: 'MethodType', *int: int) -> MethodHandle: ...
    @staticmethod
    def publicLookup() -> 'MethodHandles.Lookup': ...
    _reflectAs__T = typing.TypeVar('_reflectAs__T', bound=java.lang.reflect.Member)  # <T>
    @staticmethod
    def reflectAs(class_: typing.Type[_reflectAs__T], methodHandle: MethodHandle) -> _reflectAs__T: ...
    @staticmethod
    def spreadInvoker(methodType: 'MethodType', int: int) -> MethodHandle: ...
    @staticmethod
    def throwException(class_: typing.Type[typing.Any], class2: typing.Type[java.lang.Throwable]) -> MethodHandle: ...
    class Lookup:
        PUBLIC: typing.ClassVar[int] = ...
        PRIVATE: typing.ClassVar[int] = ...
        PROTECTED: typing.ClassVar[int] = ...
        PACKAGE: typing.ClassVar[int] = ...
        def bind(self, object: typing.Any, string: str, methodType: 'MethodType') -> MethodHandle: ...
        def findConstructor(self, class_: typing.Type[typing.Any], methodType: 'MethodType') -> MethodHandle: ...
        def findGetter(self, class_: typing.Type[typing.Any], string: str, class2: typing.Type[typing.Any]) -> MethodHandle: ...
        def findSetter(self, class_: typing.Type[typing.Any], string: str, class2: typing.Type[typing.Any]) -> MethodHandle: ...
        def findSpecial(self, class_: typing.Type[typing.Any], string: str, methodType: 'MethodType', class2: typing.Type[typing.Any]) -> MethodHandle: ...
        def findStatic(self, class_: typing.Type[typing.Any], string: str, methodType: 'MethodType') -> MethodHandle: ...
        def findStaticGetter(self, class_: typing.Type[typing.Any], string: str, class2: typing.Type[typing.Any]) -> MethodHandle: ...
        def findStaticSetter(self, class_: typing.Type[typing.Any], string: str, class2: typing.Type[typing.Any]) -> MethodHandle: ...
        def findVirtual(self, class_: typing.Type[typing.Any], string: str, methodType: 'MethodType') -> MethodHandle: ...
        def lookupClass(self) -> typing.Type[typing.Any]: ...
        def lookupModes(self) -> int: ...
        def revealDirect(self, methodHandle: MethodHandle) -> MethodHandleInfo: ...
        def toString(self) -> str: ...
        def unreflect(self, method: java.lang.reflect.Method) -> MethodHandle: ...
        def unreflectConstructor(self, constructor: java.lang.reflect.Constructor[typing.Any]) -> MethodHandle: ...
        def unreflectGetter(self, field: java.lang.reflect.Field) -> MethodHandle: ...
        def unreflectSetter(self, field: java.lang.reflect.Field) -> MethodHandle: ...
        def unreflectSpecial(self, method: java.lang.reflect.Method, class_: typing.Type[typing.Any]) -> MethodHandle: ...

class MethodType(java.io.Serializable):
    @typing.overload
    def appendParameterTypes(self, *class_: typing.Type[typing.Any]) -> 'MethodType': ...
    @typing.overload
    def appendParameterTypes(self, list: java.util.List[typing.Type[typing.Any]]) -> 'MethodType': ...
    def changeParameterType(self, int: int, class_: typing.Type[typing.Any]) -> 'MethodType': ...
    def changeReturnType(self, class_: typing.Type[typing.Any]) -> 'MethodType': ...
    def dropParameterTypes(self, int: int, int2: int) -> 'MethodType': ...
    def equals(self, object: typing.Any) -> bool: ...
    def erase(self) -> 'MethodType': ...
    @staticmethod
    def fromMethodDescriptorString(string: str, classLoader: java.lang.ClassLoader) -> 'MethodType': ...
    def generic(self) -> 'MethodType': ...
    @typing.overload
    @staticmethod
    def genericMethodType(int: int) -> 'MethodType': ...
    @typing.overload
    @staticmethod
    def genericMethodType(int: int, boolean: bool) -> 'MethodType': ...
    def hasPrimitives(self) -> bool: ...
    def hasWrappers(self) -> bool: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def insertParameterTypes(self, int: int, *class_: typing.Type[typing.Any]) -> 'MethodType': ...
    @typing.overload
    def insertParameterTypes(self, int: int, list: java.util.List[typing.Type[typing.Any]]) -> 'MethodType': ...
    @typing.overload
    @staticmethod
    def methodType(class_: typing.Type[typing.Any]) -> 'MethodType': ...
    @typing.overload
    @staticmethod
    def methodType(class_: typing.Type[typing.Any], class2: typing.Type[typing.Any]) -> 'MethodType': ...
    @typing.overload
    @staticmethod
    def methodType(class_: typing.Type[typing.Any], class2: typing.Type[typing.Any], *class3: typing.Type[typing.Any]) -> 'MethodType': ...
    @typing.overload
    @staticmethod
    def methodType(class_: typing.Type[typing.Any], classArray: typing.List[typing.Type[typing.Any]]) -> 'MethodType': ...
    @typing.overload
    @staticmethod
    def methodType(class_: typing.Type[typing.Any], methodType: 'MethodType') -> 'MethodType': ...
    @typing.overload
    @staticmethod
    def methodType(class_: typing.Type[typing.Any], list: java.util.List[typing.Type[typing.Any]]) -> 'MethodType': ...
    def parameterArray(self) -> typing.List[typing.Type[typing.Any]]: ...
    def parameterCount(self) -> int: ...
    def parameterList(self) -> java.util.List[typing.Type[typing.Any]]: ...
    def parameterType(self, int: int) -> typing.Type[typing.Any]: ...
    def returnType(self) -> typing.Type[typing.Any]: ...
    def toMethodDescriptorString(self) -> str: ...
    def toString(self) -> str: ...
    def unwrap(self) -> 'MethodType': ...
    def wrap(self) -> 'MethodType': ...

class SerializedLambda(java.io.Serializable):
    def __init__(self, class_: typing.Type[typing.Any], string: str, string2: str, string3: str, int: int, string4: str, string5: str, string6: str, string7: str, objectArray: typing.List[typing.Any]): ...
    def getCapturedArg(self, int: int) -> typing.Any: ...
    def getCapturedArgCount(self) -> int: ...
    def getCapturingClass(self) -> str: ...
    def getFunctionalInterfaceClass(self) -> str: ...
    def getFunctionalInterfaceMethodName(self) -> str: ...
    def getFunctionalInterfaceMethodSignature(self) -> str: ...
    def getImplClass(self) -> str: ...
    def getImplMethodKind(self) -> int: ...
    def getImplMethodName(self) -> str: ...
    def getImplMethodSignature(self) -> str: ...
    def getInstantiatedMethodType(self) -> str: ...
    def toString(self) -> str: ...

class SwitchPoint:
    def __init__(self): ...
    def guardWithTest(self, methodHandle: MethodHandle, methodHandle2: MethodHandle) -> MethodHandle: ...
    def hasBeenInvalidated(self) -> bool: ...
    @staticmethod
    def invalidateAll(switchPointArray: typing.List['SwitchPoint']) -> None: ...

class WrongMethodTypeException(java.lang.RuntimeException):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: str): ...

class ConstantCallSite(CallSite):
    def __init__(self, methodHandle: MethodHandle): ...
    def dynamicInvoker(self) -> MethodHandle: ...
    def getTarget(self) -> MethodHandle: ...
    def setTarget(self, methodHandle: MethodHandle) -> None: ...

class MutableCallSite(CallSite):
    @typing.overload
    def __init__(self, methodHandle: MethodHandle): ...
    @typing.overload
    def __init__(self, methodType: MethodType): ...
    def dynamicInvoker(self) -> MethodHandle: ...
    def getTarget(self) -> MethodHandle: ...
    def setTarget(self, methodHandle: MethodHandle) -> None: ...
    @staticmethod
    def syncAll(mutableCallSiteArray: typing.List['MutableCallSite']) -> None: ...

class VolatileCallSite(CallSite):
    @typing.overload
    def __init__(self, methodHandle: MethodHandle): ...
    @typing.overload
    def __init__(self, methodType: MethodType): ...
    def dynamicInvoker(self) -> MethodHandle: ...
    def getTarget(self) -> MethodHandle: ...
    def setTarget(self, methodHandle: MethodHandle) -> None: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("java.lang.invoke")``.

    CallSite: typing.Type[CallSite]
    ConstantCallSite: typing.Type[ConstantCallSite]
    LambdaConversionException: typing.Type[LambdaConversionException]
    LambdaMetafactory: typing.Type[LambdaMetafactory]
    MethodHandle: typing.Type[MethodHandle]
    MethodHandleInfo: typing.Type[MethodHandleInfo]
    MethodHandleProxies: typing.Type[MethodHandleProxies]
    MethodHandles: typing.Type[MethodHandles]
    MethodType: typing.Type[MethodType]
    MutableCallSite: typing.Type[MutableCallSite]
    SerializedLambda: typing.Type[SerializedLambda]
    SwitchPoint: typing.Type[SwitchPoint]
    VolatileCallSite: typing.Type[VolatileCallSite]
    WrongMethodTypeException: typing.Type[WrongMethodTypeException]
